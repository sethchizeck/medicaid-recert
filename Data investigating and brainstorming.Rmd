---
title: "Medicaid recertification requirements study - Data investigating and brainstorming"
author: "Seth Chizeck and Lori Leu"
date: "`r Sys.Date()`"
knit: (function(rmdfile, ...) { rmarkdown::render(rmdfile, output_file = 'Discounted Fares Pilot tables and figures.pdf', output_dir = 'C:/Users/K011014/OneDrive - Allegheny County/Medicaid/Effect of Medicaid recertification deadlines project/Data analysis/Tables and figures') })
output: 
  bookdown::pdf_document2:
      toc: FALSE
      number_sections: FALSE
      keep_tex: TRUE
header-includes: 
  - \setlength{\parindent}{2em}
  - \setlength{\parskip}{0em}
  - \usepackage{indentfirst, setspace, booktabs, floatrow, longtable, pdflscape, dcolumn, adjustbox, graphicx, threeparttablex}
  - \usepackage[skip = 0.5\baselineskip]{caption}
  - \floatplacement{figure}{H}
  - \floatsetup[figure]{capposition = top}
  - \floatsetup[table]{capposition = top}
  - \newcommand{\blandscape}{\begin{landscape}}
  - \newcommand{\elandscape}{\end{landscape}}
linkcolor: red
---

```{r, include = FALSE}

#----------------------------------------------------------------------------
# Clear space

rm(list=ls())

#----------------------------------------------------------------------------
# Load packages 

library(cowplot)
library(data.table)
library(fixest)
library(kableExtra)
library(lubridate)
library(sandwich)
library(scales)
library(tidyverse)

#----------------------------------------------------------------------------
# Set chunk options

knitr::opts_chunk$set(echo = FALSE, eval = FALSE, message = FALSE, warning = FALSE, cache = FALSE)

options(scipen=999)

#----------------------------------------------------------------------------
# Set filepath 

filepath <- 'C:/Users/K011014/OneDrive - Allegheny County/Medicaid/Effect of Medicaid recertification deadlines project/Data analysis'

#----------------------------------------------------------------------------
# Create necessary functions

# Function that calculates the number of calendar quarters between two dates that are formatted as yyyyq. 

quarter_diff <- function(date1, date2) {
  year1 <- as.integer(substr(date1, 1, 4))
  quarter1 <- as.integer(substr(date1, 5, 5))
  year2 <- as.integer(substr(date2, 1, 4))
  quarter2 <- as.integer(substr(date2, 5, 5))
  quarters <- (year2 - year1) * 4 + quarter2 - quarter1
  return(quarters)
}
```

# Explore the most common reasons for Medicaid disenrollment

```{r}

db_con <- dhs_dw(database = "ACPRD1", stored_db = TRUE, stored_creds = TRUE)

medicaid_disenrollment_reasons <- dbGetQuery(conn = db_con, 
                          statement = 
'select  
    a.ma_term_reason_code,
    c.ma_term_reason_desc,
    count(*)
from 
    ac_mh.pa_client_elig_daily a 
    left join ac_mh.LKP_PA_MA_TERM_REASON  c on c.ma_term_reason_code = a.ma_term_reason_code
where 
    a.ma_term_reason_code is not null
group by 
    a.ma_term_reason_code, 
    c.ma_term_reason_desc
order by 
    count(*) desc')

names(medicaid_disenrollment_reasons) <- tolower(names(medicaid_disenrollment_reasons))

# Save data

save(medicaid_disenrollment_reasons, file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_disenrollment_reasons.rda"))
```

# Explore different sources of Medicaid enrollment dates 

## Enrollment dates according to the 'BH' dates in the CCBH daily transaction table

```{r, eval = TRUE}

#-------------------------------------------------------------------------
#-------------------------------------------------------------------------
# Load raw data

db_con <- dhs_dw(database = "ACPRD1", stored_db = TRUE, stored_creds = TRUE)

medicaid_enrollment_dates_ccbh_daily_transact1_raw <- dbGetQuery(conn = db_con, 
                          statement = 
                            
'with medicaid_enrollees_04012023 as
(select distinct 
    ma_receipt_num
from 
    ac_mh.ccbh_hc_eligibility 
where
    elig_from_date <= to_date(\'01-APR-2023\', \'DD-MON-YYYY\')
    and elig_to_date >= to_date(\'01-APR-2023\', \'DD-MON-YYYY\'))
    
select distinct
    a.ma_receipt_num, 
    c.batch_date,
    c.ma_begin_date, 
    c.ma_end_date,
    c.bh_begin_date, 
    c.bh_end_date
from 
    medicaid_enrollees_04012023 a
    left join ac_mh.pa_client_elig_daily c on c.recipient_nbr = a.ma_receipt_num
order by 
    a.ma_receipt_num')

# Make var names lowercase

names(medicaid_enrollment_dates_ccbh_daily_transact1_raw) <- tolower(names(medicaid_enrollment_dates_ccbh_daily_transact1_raw))

# Save the data 

save(medicaid_enrollment_dates_ccbh_daily_transact1_raw, file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_ccbh_daily_transact1_raw.rda"))

#-------------------------------------------------------------------------
#-------------------------------------------------------------------------
# Clean up the data

# Reload the raw data

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_ccbh_daily_transact1_raw.rda"))

# Convert dates to R date format

medicaid_enrollment_dates_ccbh_daily_transact1 <- medicaid_enrollment_dates_ccbh_daily_transact1_raw %>%
  mutate_at(vars(batch_date, ma_begin_date, ma_end_date, bh_begin_date, bh_end_date), ~ as.Date(substring(as.character(.), 1, 10), '%Y-%m-%d')) %>%
  rename(elig_from_date = bh_begin_date, 
          elig_to_date = bh_end_date) %>%
  
# Clean up the dates as follows: order the rows by client and transaction date. If the episode start date is missing, impute the subsequent value of start date for the given client. Then, drop all obs that have a missing value of episode end date unless the obs has the last value of start date for the given client. 
  
  arrange(ma_receipt_num, batch_date) %>%
  group_by(ma_receipt_num) %>%
  mutate(elig_from_date = if_else(is.na(elig_from_date), dplyr::lag(elig_from_date, n = 1), elig_from_date), 
         max_from_date = if_else(elig_from_date == max(elig_from_date), 1, 0)) %>%
  ungroup() %>%
  mutate(drop = ifelse(is.na(elig_to_date) & max_from_date == 0, 1, 0)) %>%
  filter(drop == 0) %>%
  
# Deduplicate the data by client ID, start date, and end date, in case there are any dups
  
  distinct(ma_receipt_num, elig_from_date, elig_to_date) %>%
  
# Now count the number of obs with the same start date for each client. If there are multiple obs with the same start date, keep the obs that has a non-missing value of 'end date'. There should only be a maximum of one obs per client that has a missing end date. 
  
  group_by(ma_receipt_num, elig_from_date) %>%
  mutate(from_date_count = n()) %>%
  ungroup() %>%
  mutate(drop = ifelse(from_date_count > 1 & is.na(elig_to_date), 1, 0)) %>%
  filter(drop == 0) %>%
  select(-from_date_count, -drop) %>%
  
# Remove any obs where the episode start date is after the episode end date. 
  
  filter(elig_from_date <= elig_to_date | is.na(elig_to_date)) 
  
# Save data

save(medicaid_enrollment_dates_ccbh_daily_transact1, file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_ccbh_daily_transact1.rda"))

#-------------------------------------------------------------------------
#-------------------------------------------------------------------------
# Create analytic data sets

#----------------------------------------------------------------------------
# Data frame with 1 obs for each day that each procedurally-disenrolled sample member was enrolled in Medicaid between 4/1/2022 and 10/31/2024. I will use this for examining the concordance of the enrollment dates across sources. 

# Load relevant data

load(file = paste0(filepath, "/Data/Medicaid enrollment data/earliest_procedural_disenroll_dates.rda"))
load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_ccbh_daily_transact1.rda"))
load(file = paste0(filepath, "/Data/Sample demographics/base_sample_demographics.rda"))

# Use only the people in the base sample

medicaid_enrollment_dates_long_daily_transact1 <- earliest_procedural_disenroll_dates %>%
  distinct(ma_receipt_num) %>%
  inner_join(medicaid_enrollment_dates_ccbh_daily_transact1, by = c('ma_receipt_num')) %>%
  
# Remove obs in which the start date of the enrollment episode is after 10/31/2024
  
  filter(elig_from_date <= as.Date('2024-10-31')) %>%
  
# Recode missing values of the enrollment episode end date as 10/31/2024
  
  mutate(elig_to_date = replace_na(elig_to_date, as.Date('2024-10-31'))) %>%
  
# Remove obs where the episode end date was before 4/1/2022
  
  filter(elig_to_date >= as.Date('2022-04-01')) %>%
  
# Recode any episode start dates as 4/1/2022 if they are before 4/1/2022
  
  mutate(elig_from_date = if_else(elig_from_date < as.Date('2022-04-01'), as.Date('2022-04-01'), elig_from_date)) %>%
  
# Deduplicate the data
  
  distinct(ma_receipt_num, elig_from_date, elig_to_date) %>%
  
# Reshape the data to have 1 obs for each day during each enrollment episode
  
  group_by(ma_receipt_num, elig_from_date, elig_to_date) %>%
  reframe(date = list(seq.Date(from = elig_from_date,
                               to = elig_to_date,
                               by = "day"))) %>%
  unnest(date) %>%
  ungroup() %>%
  distinct(ma_receipt_num, date) %>%
  mutate(medicaid_enrolled = 1)

# Save data

save(medicaid_enrollment_dates_long_daily_transact1, file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_long_daily_transact1.rda"))
```

## Enrollment dates according to the 'MA' dates in the CCBH daily transaction table

```{r, eval = TRUE}

#-------------------------------------------------------------------------
#-------------------------------------------------------------------------
# Load raw data

medicaid_enrollment_dates_ccbh_daily_transact2_raw <- dbGetQuery(conn = db_con, 
                          statement = 
'with medicaid_enrollees_04012023 as
(select distinct 
    ma_receipt_num
from 
    ac_mh.ccbh_hc_eligibility 
where
    elig_from_date <= to_date(\'01-APR-2023\', \'DD-MON-YYYY\')
    and elig_to_date >= to_date(\'01-APR-2023\', \'DD-MON-YYYY\'))
    
select distinct
    a.ma_receipt_num, 
    c.change_type,
    c.ma_begin_date, 
    c.ma_end_date
from 
    medicaid_enrollees_04012023 a
    left join ac_mh.pa_client_elig_daily c on c.recipient_nbr = a.ma_receipt_num
order by 
    a.ma_receipt_num')

# Make var names lowercase

names(medicaid_enrollment_dates_ccbh_daily_transact2_raw) <- tolower(names(medicaid_enrollment_dates_ccbh_daily_transact2_raw))

# Save the data 

save(medicaid_enrollment_dates_ccbh_daily_transact2_raw, file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_ccbh_daily_transact2_raw.rda"))

#-------------------------------------------------------------------------
#-------------------------------------------------------------------------
# Clean up the data

# Reload the raw data 

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_ccbh_daily_transact2_raw.rda"))

# Convert dates to R date format

medicaid_enrollment_dates_ccbh_daily_transact2 <- medicaid_enrollment_dates_ccbh_daily_transact2_raw %>%
  rename(elig_from_date = ma_begin_date, 
         elig_to_date = ma_end_date) %>%
  mutate_at(vars(elig_from_date, elig_to_date), ~ as.Date(substring(as.character(.), 1, 10), '%Y-%m-%d')) %>%
  
# Remove obs that have missing values of both start date and end date
  
  filter(!is.na(elig_from_date) | !is.na(elig_to_date)) %>%
  
# If the obs has a missing end date, impute the value of the start date of the next sequential obs for the given client, minus one day
  
  arrange(ma_receipt_num, elig_from_date) %>%
  group_by(ma_receipt_num) %>%
  mutate(elig_to_date = if_else(is.na(elig_to_date), dplyr::lead(elig_from_date - 1, n = 1), elig_to_date)) %>%
  ungroup() %>%
  
# Remove any obs where the episode start date is after the episode end date. These are data quality issues I think. 
  
  filter(elig_from_date <= elig_to_date | is.na(elig_to_date)) %>%
  
# Round any end dates up to the last day of the month, to match the BH end dates. I assume that a person's Medicaid enrollment only ever terminates at the end of a month, not in the middle of the month. Remove this code if that assumptions turns out not to be true
  
  mutate(elig_to_date = ceiling_date(elig_to_date, "month") - days(1)) %>%
  
# Deduplicate the data by client ID, start date, and end date, in case there are any dups
  
  distinct(ma_receipt_num, elig_from_date, elig_to_date) 

# Save data

save(medicaid_enrollment_dates_ccbh_daily_transact2, file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_ccbh_daily_transact2.rda"))

#-------------------------------------------------------------------------
#-------------------------------------------------------------------------
# Create analytic data sets

#-------------------------------------------------------------------------
# Data frame with 1 obs for each day that each procedurally-disenrolled sample member was enrolled in Medicaid between 4/1/2022 and 10/31/2024. I will use this for examining the concordance of the enrollment dates across sources. 

# Load relevant data

load(file = paste0(filepath, "/Data/Medicaid enrollment data/earliest_procedural_disenroll_dates.rda"))
load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_ccbh_daily_transact2.rda"))
load(file = paste0(filepath, "/Data/Sample demographics/base_sample_demographics.rda"))

# Use only the people in the base sample

medicaid_enrollment_dates_long_daily_transact2 <- earliest_procedural_disenroll_dates %>%
  distinct(ma_receipt_num) %>%
  inner_join(medicaid_enrollment_dates_ccbh_daily_transact2, by = c('ma_receipt_num')) %>%

# Remove obs in which the start date of the enrollment episode is after 10/31/2024
  
  filter(elig_from_date <= as.Date('2024-10-31')) %>%
  
# Recode missing values of the enrollment episode end date as 10/31/2024
  
  mutate(elig_to_date = replace_na(elig_to_date, as.Date('2024-10-31'))) %>%
  
# Remove obs where the episode end date was before 4/1/2022
  
  filter(elig_to_date >= as.Date('2022-04-01')) %>%
  
# Recode any episode start dates as 4/1/2022 if they are before 4/1/2022
  
  mutate(elig_from_date = if_else(elig_from_date < as.Date('2022-04-01'), as.Date('2022-04-01'), elig_from_date)) %>%
  
# Deduplicate the data
  
  distinct(ma_receipt_num, elig_from_date, elig_to_date) %>%
  
# Reshape the data to have 1 obs for each day during each enrollment episode
  
  group_by(ma_receipt_num, elig_from_date, elig_to_date) %>%
  reframe(date = list(seq.Date(from = elig_from_date,
                               to = elig_to_date,
                               by = "day"))) %>%
  unnest(date) %>%
  ungroup() %>%
  distinct(ma_receipt_num, date) %>%
  mutate(medicaid_enrolled = 1)

# Save data

save(medicaid_enrollment_dates_long_daily_transact2, file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_long_daily_transact2.rda"))
```

## Enrollment dates according to the CCBH weekly episode table

```{r, eval = TRUE}

#-------------------------------------------------------------------------
#-------------------------------------------------------------------------
# Load raw data

medicaid_enrollment_dates_ccbh_episodes_raw <- dbGetQuery(conn = db_con, 
                          statement = 
'with medicaid_enrollees_04012023 as
(select distinct
    ma_receipt_num
from 
    ac_mh.ccbh_hc_eligibility 
where
    elig_from_date <= to_date(\'01-APR-2023\', \'DD-MON-YYYY\')
    and elig_to_date >= to_date(\'01-APR-2023\', \'DD-MON-YYYY\'))

select distinct
  a.ma_receipt_num, 
  c.category, 
  c.program_status,
  c.elig_from_date, 
  c.elig_to_date
from 
  medicaid_enrollees_04012023 a
  left join ac_mh.ccbh_hc_eligibility c on c.ma_receipt_num = a.ma_receipt_num')

# Make var names lowercase

names(medicaid_enrollment_dates_ccbh_episodes_raw) <- tolower(names(medicaid_enrollment_dates_ccbh_episodes_raw))

# Save data

save(medicaid_enrollment_dates_ccbh_episodes_raw, file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_ccbh_episodes_raw.rda"))

#-------------------------------------------------------------------------
#-------------------------------------------------------------------------
# Clean up the data

# Reload raw data

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_ccbh_episodes_raw.rda"))

# Convert dates to R date format

medicaid_enrollment_dates_ccbh_episodes <- medicaid_enrollment_dates_ccbh_episodes_raw %>%
  mutate_at(vars(elig_from_date, elig_to_date), ~ as.Date(substring(as.character(.), 1, 10), '%Y-%m-%d')) %>%
  
# Remove any obs where the episode start date is after the episode end date. These are data quality issues I think. 
  
  filter(elig_from_date <= elig_to_date) %>%
  
# Deduplicate the data by client ID, start date, and end date, in case there are any dups
  
  distinct(ma_receipt_num, elig_from_date, elig_to_date, .keep_all = TRUE) %>%
  
# Recode certain end dates as missing values, meaning the benefit episode is still ongoing
  
  mutate(elig_to_date = if_else(elig_to_date == as.Date('2079-06-06'), NA, elig_to_date)) 
  
# Save data

save(medicaid_enrollment_dates_ccbh_episodes, file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_ccbh_episodes.rda"))

#-------------------------------------------------------------------------
#-------------------------------------------------------------------------
# Create analytic data sets

#-------------------------------------------------------------------------
# Data frame with 1 obs for each day that each procedurally-disenrolled sample member was enrolled in Medicaid between 4/1/2022 and 10/31/2024. I will use this for examining the concordance of the enrollment dates across sources. 

# Load relevant data

load(file = paste0(filepath, "/Data/Medicaid enrollment data/earliest_procedural_disenroll_dates.rda"))
load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_ccbh_episodes.rda"))
load(file = paste0(filepath, "/Data/Sample demographics/base_sample_demographics.rda"))

# Use only the people in the base sample

medicaid_enrollment_dates_long_ccbh_episodes <- earliest_procedural_disenroll_dates %>%
  distinct(ma_receipt_num) %>%
  inner_join(medicaid_enrollment_dates_ccbh_episodes, by = c('ma_receipt_num')) %>%

# Remove obs in which the start date of the enrollment episode is after 10/31/2024
  
  filter(elig_from_date <= as.Date('2024-10-31')) %>%
  
# Recode missing values of the enrollment episode end date as 10/31/2024
  
  mutate(elig_to_date = replace_na(elig_to_date, as.Date('2024-10-31'))) %>%
  
# Remove obs where the episode end date was before 4/1/2022
  
  filter(elig_to_date >= as.Date('2022-04-01')) %>%
  
# Recode any episode start dates as 4/1/2022 if they are before 4/1/2022
  
  mutate(elig_from_date = if_else(elig_from_date < as.Date('2022-04-01'), as.Date('2022-04-01'), elig_from_date)) %>%
  
# Deduplicate the data
  
  distinct(ma_receipt_num, elig_from_date, elig_to_date) %>%
  
# Reshape the data to have 1 obs for each day during each enrollment episode
  
  group_by(ma_receipt_num, elig_from_date, elig_to_date) %>%
  reframe(date = list(seq.Date(from = elig_from_date,
                               to = elig_to_date,
                               by = "day"))) %>%
  unnest(date) %>%
  ungroup() %>%
  distinct(ma_receipt_num, date) %>%
  mutate(medicaid_enrolled = 1)

# Save data

save(medicaid_enrollment_dates_long_ccbh_episodes, file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_long_ccbh_episodes.rda"))
```

## Enrollment dates according to PADHS

```{r, eval = TRUE}

#-------------------------------------------------------------------------
#-------------------------------------------------------------------------
# Load raw data

medicaid_enrollment_dates_padhs_raw <- dbGetQuery(conn = db_con, 
                          statement = 
'with medicaid_enrollees_04012023 as
(select distinct
    ma_receipt_num
from 
    ac_mh.ccbh_hc_eligibility 
where
    elig_from_date <= to_date(\'01-APR-2023\', \'DD-MON-YYYY\')
    and elig_to_date >= to_date(\'01-APR-2023\', \'DD-MON-YYYY\'))
    
select distinct
    a.ma_receipt_num, 
    c.mci_uniq_id, 
    g.category, 
    g.program_status_cd, 
    g.elig_begin_date as elig_from_date, 
    g.elig_end_date as elig_to_date
from 
    medicaid_enrollees_04012023 a
    left join ac_mh.t_ahci_clients c on c.ma_receipt_num = a.ma_receipt_num
    left join ac_padhs.client @AC e on e.mci_uniq_id = c.mci_uniq_id
    left join ac_padhs.eligibility @AC g on g.padhs_id = e.padhs_id
where 
    g.dpw_scu_cd = \'DPWOM\'')

# Make var names lowercase

names(medicaid_enrollment_dates_padhs_raw) <- tolower(names(medicaid_enrollment_dates_padhs_raw))

# Save data

save(medicaid_enrollment_dates_padhs_raw, file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_padhs_raw.rda"))

#-------------------------------------------------------------------------
#-------------------------------------------------------------------------
# Clean up the data

# Load relevant data

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_padhs_raw.rda"))

# Convert dates to R date format

medicaid_enrollment_dates_padhs <- medicaid_enrollment_dates_padhs_raw %>%
  mutate_at(vars(elig_from_date, elig_to_date), ~ as.Date(substring(as.character(.), 1, 10), '%Y-%m-%d')) %>%
  
# Remove any obs where the episode start date is after the episode end date. These are data quality issues I think. 
  
  mutate(drop = ifelse(!is.na(elig_to_date) & elig_from_date > elig_to_date, 1, 0)) %>%
  filter(drop == 0) %>%
  select(-drop) %>%
  
# Deduplicate the data by client ID, start date, and end date, in case there are any dups. 
  
  distinct(mci_uniq_id, ma_receipt_num, elig_from_date, elig_to_date, .keep_all = TRUE) 
  
# Save data

save(medicaid_enrollment_dates_padhs, file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_padhs.rda"))

#-------------------------------------------------------------------------
#-------------------------------------------------------------------------
# Create analytic data sets

#-------------------------------------------------------------------------
# Data frame with 1 obs for each day that each procedurally-disenrolled sample member was enrolled in Medicaid between 4/1/2022 and 10/31/2024. I will use this for examining the concordance of the enrollment dates across sources. 

# Load relevant data

load(file = paste0(filepath, "/Data/Medicaid enrollment data/earliest_procedural_disenroll_dates.rda"))
load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_padhs.rda"))
load(file = paste0(filepath, "/Data/Sample demographics/base_sample_demographics.rda"))

# Use only the people in the base sample

medicaid_enrollment_dates_long_padhs <- earliest_procedural_disenroll_dates %>%
  distinct(ma_receipt_num) %>%
  inner_join(medicaid_enrollment_dates_padhs, by = c('ma_receipt_num')) %>%

# Remove obs in which the start date of the enrollment episode is after 10/31/2024
  
  filter(elig_from_date <= as.Date('2024-10-31')) %>%
  
# Recode missing values of the enrollment episode end date as 10/31/2024
  
  mutate(elig_to_date = replace_na(elig_to_date, as.Date('2024-10-31'))) %>%
  
# Remove obs where the episode end date was before 4/1/2022
  
  filter(elig_to_date >= as.Date('2022-04-01')) %>%
  
# Recode any episode start dates as 4/1/2022 if they are before 4/1/2022
  
  mutate(elig_from_date = if_else(elig_from_date < as.Date('2022-04-01'), as.Date('2022-04-01'), elig_from_date)) %>%
  
# Deduplicate the data
  
  distinct(ma_receipt_num, elig_from_date, elig_to_date) %>%
  
# Reshape the data to have 1 obs for each day during each enrollment episode
  
  group_by(ma_receipt_num, elig_from_date, elig_to_date) %>%
  reframe(date = list(seq.Date(from = elig_from_date,
                               to = elig_to_date,
                               by = "day"))) %>%
  unnest(date) %>%
  ungroup() %>%
  distinct(ma_receipt_num, date) %>%
  mutate(medicaid_enrolled = 1)

# Save data

save(medicaid_enrollment_dates_long_padhs, file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_long_padhs.rda"))
```

# Study idea: Isolate the effect of procedural disenrollments during PHE unwinding year

## Pull base study sample

```{r}

#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
# Import raw data

#------------------------------------------------------------------------------
# Unique Medicaid clients who were enrolled in Medicaid on April 1, 2023 and who experienced at least one procedural disenrollment between 4/1/2023 and 4/1/2024

db_con <- dhs_dw(database = "ACPRD1", stored_db = TRUE, stored_creds = TRUE)

base_pd_sample <- dbGetQuery(conn = db_con, 
                          statement = 
'with medicaid_enrollees_04012023 as
(select distinct ma_receipt_num
 from 
    ac_mh.ccbh_hc_eligibility
 where
    elig_from_date <= to_date(\'01-APR-2023\', \'DD-MON-YYYY\')
    and elig_to_date >= to_date(\'01-APR-2023\', \'DD-MON-YYYY\')),

procedural_disenrollees as 
(select distinct 
  recipient_nbr as ma_receipt_num
 from 
    ac_mh.pa_client_elig_daily
 where 
    ma_term_reason_code = \'042\'
    and batch_date >= to_date(\'01-APR-2023\', \'DD-MON-YYYY\')
    and batch_date <= to_date(\'01-APR-2024\', \'DD-MON-YYYY\'))
    
select 
  a.ma_receipt_num,
  e.mci_uniq_id, 
  e.ssn, 
  e.date_of_birth as dob_medicaid, 
  g.dob as dob_dw, 
  g.dod, 
  e.member_gender as gender_medicaid,
  g.gender_common_desc as gender_dw, 
  e.race as race_medicaid, 
  g.race_common_desc as race_dw, 
  e.education_status, 
  e.living_situation,
  e.phone_number, 
  e.address_line_1, 
  e.address_line_2, 
  e.city,
  e.state, 
  e.zip_code
from 
    medicaid_enrollees_04012023 a 
    inner join procedural_disenrollees c on c.ma_receipt_num = a.ma_receipt_num
    left join ac_mh.t_ahci_clients e on e.ma_receipt_num = c.ma_receipt_num
    left join dw.dim_mci_unique @DW g on g.mci_uniq_id = e.mci_uniq_id')

# Make var names lowercase

names(base_pd_sample) <- tolower(names(base_pd_sample))

# Call this sample the 'PD' sample

base_pd_sample <- base_pd_sample %>% 
  mutate(treat = 1)

#------------------------------------------------------------------------------
# Unique Medicaid clients who were enrolled in Medicaid on April 1, 2023 and who did not experience a procedural disenrollment after that date

base_non_pd_sample <- dbGetQuery(conn = db_con, 
                          statement = 
'with medicaid_enrollees_04012023 as
(select distinct ma_receipt_num
 from 
    ac_mh.ccbh_hc_eligibility
 where
    elig_from_date <= to_date(\'01-APR-2023\', \'DD-MON-YYYY\')
    and elig_to_date >= to_date(\'01-APR-2023\', \'DD-MON-YYYY\')),
    
procedural_disenrollees as 
(select distinct 
  recipient_nbr as ma_receipt_num
 from 
    ac_mh.pa_client_elig_daily
 where 
    ma_term_reason_code = \'042\'
    and batch_date >= to_date(\'01-APR-2023\', \'DD-MON-YYYY\')), 
    
non_procedural_disenrollees as 
(select 
  ma_receipt_num
 from
  medicaid_enrollees_04012023 
 where
  ma_receipt_num not in (select * from procedural_disenrollees))
    
select 
  a.ma_receipt_num,
  e.mci_uniq_id, 
  e.ssn, 
  e.date_of_birth as dob_medicaid, 
  g.dob as dob_dw, 
  g.dod, 
  e.member_gender as gender_medicaid,
  g.gender_common_desc as gender_dw, 
  e.race as race_medicaid, 
  g.race_common_desc as race_dw, 
  e.education_status, 
  e.living_situation,
  e.phone_number, 
  e.address_line_1, 
  e.address_line_2, 
  e.city,
  e.state, 
  e.zip_code
from 
    non_procedural_disenrollees a 
    left join ac_mh.t_ahci_clients e on e.ma_receipt_num = a.ma_receipt_num
    left join dw.dim_mci_unique @DW g on g.mci_uniq_id = e.mci_uniq_id')

# Make var names lowercase

names(base_non_pd_sample) <- tolower(names(base_non_pd_sample))

# Call this sample the 'untreated' sample

base_non_pd_sample <- base_non_pd_sample %>% 
  mutate(treat = 0)

#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
# Clean up the data

#------------------------------------------------------------------------------
# Combine the treated and untreated samples

study1_base_sample <- bind_rows(base_pd_sample, base_non_pd_sample) %>%

# Drop the clients who have more than one Medicaid ID number associated with the same MCI unique ID. We will not use these clients in the analysis because it's difficult to discern their true identify
  
  group_by(mci_uniq_id) %>%
  mutate(count = n()) %>%
  ungroup() %>%
  filter(count == 1) %>%
  select(-count) %>%
  
# Convert dates to R date format
  
  mutate_at(vars(dob_dw, dob_medicaid, dod), ~ as.Date(substring(as.character(.), 1, 10), '%Y-%m-%d')) %>%
  
# Decode some values
  
  mutate(living_situation_desc = ifelse(living_situation == 'L70', 'Living independently',
                            ifelse(living_situation == 'L71', 'Family setting',
                            ifelse(living_situation == 'L72', 'Living dependently',
                            ifelse(living_situation == 'L73', 'Supervised setting',
                            ifelse(living_situation == 'L74', 'Restrictive setting',
                            ifelse(living_situation == 'L75', 'Homeless',
                            NA))))))) %>%
  select(-living_situation) %>%
  
# Look for discrepancies between DOB from the Medicaid table and DOB from the Golden Record table. Use the DOB from one source if it's missing in the other source. Use the DOB from the Golden Record for any mismatches.
  
  mutate(dob_match = ifelse(dob_medicaid == dob_dw, 1, 0), 
         dob = if_else(dob_match == 1, dob_medicaid, 
               if_else(is.na(dob_medicaid), dob_dw, 
               if_else(is.na(dob_dw), dob_medicaid, 
               NA)))) %>%
  select(-dob_medicaid, -dob_dw, -dob_match) %>%
  
#------------------------------------------------------------------------------
# Look for discrepancies between gender from the Medicaid table and gender from the Golden Record table. Use the gender from one source if it's missing in the other source. Use the gender from the Golden Record table for any mismatches
  
  mutate(gender_medicaid = ifelse(gender_medicaid == 'M', 'Male', 
                           ifelse(gender_medicaid == 'F', 'Female', 
                           NA)), 
         gender_dw = ifelse(gender_dw == '1~Male', 'Male', 
                     ifelse(gender_dw == '2~Female', 'Female', 
                     NA)), 
         gender_match = ifelse(gender_medicaid == gender_dw, 1, 0),
         gender = if_else(gender_match == 1, gender_medicaid, 
                  if_else(is.na(gender_medicaid), gender_dw, 
                  if_else(is.na(gender_dw), gender_medicaid, 
               NA)))) %>%
  select(-gender_medicaid, -gender_dw, -gender_match) %>%
  
#------------------------------------------------------------------------------
# Look for discrepancies between race from the Medicaid table and race from the Golden Record table. Use the race from one source if it's missing in the other source. Use the race from the Golden Record table for any mismatches
  
  mutate(race_medicaid = ifelse(race_medicaid == 'W', 'White', 
                         ifelse(race_medicaid == 'B', 'Black', 
                         ifelse(race_medicaid %in% c('A', 'O'), 'Other', 
                         NA))),
         race_dw = ifelse(race_dw == "1~White", 'White', 
                   ifelse(race_dw == "2~Black/African American", 'Black', 
                   ifelse(race_dw %in% c("3~American Indian/Alaskan Native", "4~Asian", "5~Native Hawaiian/Pacific Islander", "6~Two or More Races", "7~Other Single Race"), 'Other', 
                   NA))),
         race_match = ifelse(race_medicaid == race_dw, 1, 0),
         race = if_else(race_match == 1, race_medicaid, 
                if_else(is.na(race_medicaid), race_dw, 
                if_else(is.na(race_dw), race_medicaid, 
                NA)))) %>%
  select(-race_medicaid, -race_dw, -race_match) 
  
#------------------------------------------------------------------------------
# Group individuals together into households using phone number and address, assigning a unique ID to each household
  
household_ids <- study1_base_sample %>%
  distinct(phone_number, address_line_1, address_line_2, city, state, zip_code) %>%
  
# Only use the obs that have non-missing values of phone number and address
  
  filter(!is.na(phone_number) & !is.na(address_line_1) & !is.na(city) & !is.na(state) & !is.na(zip_code)) %>%
  
# Create a household-level ID
  
  mutate(household_id = sequence(n()))

study1_base_sample <- study1_base_sample %>%
  left_join(household_ids, by = c('phone_number', 'address_line_1', 'address_line_2', 'city', 'state', 'zip_code'))
  
# Save data

save(study1_base_sample, file = paste0(filepath, "/Data/Sample demographics/study1_base_sample.rda"))
```

## Pull procedural disenrollments during PHE unwinding year

```{r}

#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
# Load raw data

db_con <- dhs_dw(database = "ACPRD1", stored_db = TRUE, stored_creds = TRUE)

pd_dates <- dbGetQuery(conn = db_con, 
                          statement = 
'select distinct 
  recipient_nbr as ma_receipt_num,
  batch_date as pd_date
 from 
    ac_mh.pa_client_elig_daily
 where 
    ma_term_reason_code = \'042\'')

# Make var names lowercase

names(pd_dates) <- tolower(names(pd_dates))

# Convert disenrollment dates to R data format

pd_dates <- pd_dates %>%
  mutate(pd_date = as.Date(substring(as.character(pd_date), 1, 10), '%Y-%m-%d'))

# Save data

save(pd_dates, file = paste0(filepath, "/Data/Medicaid enrollment data/pd_dates.rda"))

#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
# Create analytic data sets

# Load relevant data

load(file = paste0(filepath, "/Data/Sample demographics/study1_base_sample.rda"))
load(file = paste0(filepath, "/Data/Medicaid enrollment data/pd_dates.rda"))

#-----------------------------------------------------------------------------
# Each client's earliest procedural disenrollment date that took place between 4/1/2023 and 4/1/2024

earliest_pd_dates <- study1_base_sample %>%
  filter(treat == 1) %>%
  select(ma_receipt_num) %>%
  left_join(pd_dates, by = c('ma_receipt_num')) %>%
  filter(pd_date >= as.Date('2023-04-01') & pd_date <= as.Date('2024-04-01')) %>%
  group_by(ma_receipt_num) %>%
  top_n(-1, pd_date) %>%
  ungroup() %>%
  distinct(ma_receipt_num, .keep_all = TRUE) 

# Save data

save(earliest_pd_dates, file = paste0(filepath, "/Data/Medicaid enrollment data/earliest_pd_dates.rda"))
```

## Medicaid enrollment

### Medicaid enrollment rates by day relative to date of earliest post-4/1/2023 PD

```{r}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample 

load(file = paste0(filepath, "/Data/Sample demographics/base_sample_demographics.rda"))

# Dates of PDs

load(file = paste0(filepath, "/Data/Medicaid enrollment data/procedural_disenrollment_dates.rda"))

# Medicaid enrollment episode dates for procedural disenrollees - BH dates in daily table

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_long_daily_transact1.rda"))

# Medicaid enrollment episode dates for procedural disenrollees - MA dates in daily table

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_long_daily_transact2.rda"))

# Medicaid enrollment episode dates for procedural disenrollees - CCBH weekly episodes 

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_long_ccbh_episodes.rda"))

# Medicaid enrollment episode dates for procedural disenrollees - PADHS 

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_long_padhs.rda"))

# Earliest post-4/1/2023 PD dates

load(file = paste0(filepath, "/Data/Medicaid enrollment data/earliest_procedural_disenroll_dates.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

# Take a random sample of the procedurally disenrolled clients to save memory

set.seed(62889)

analytic_sample <- earliest_procedural_disenroll_dates %>%
  slice_sample(n = 10000, replace = FALSE) %>%
  distinct(ma_receipt_num)

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create a data frame with 1 obs for each day within +/- 365 days of the person's earliest PD date (capped at 10/31/2024 to save memory), with their Medicaid enrollment status on each of these days. Do this separately for each enrollment date source.

#----------------------------------------------------------------------------
# Using the 'BH' dates in the daily table

dt_ccbh_daily_bh <- base_sample_demographics %>%
  inner_join(analytic_sample, by = c('ma_receipt_num')) %>%
  filter(treat == 1) %>%
  select(ma_receipt_num) %>%
  inner_join(earliest_procedural_disenroll_dates, by = c('ma_receipt_num')) %>%
  mutate(start_date = procedural_disenroll_date - 365, 
         end_date = pmin(procedural_disenroll_date + 365, as.Date('2024-10-31'))) %>%
  group_by(ma_receipt_num) %>%
  reframe(date = seq.Date(from = start_date,
                         to = end_date,
                         by = "day")) %>%
  ungroup() %>%
  distinct(ma_receipt_num, date) %>%
  
# Count each date in terms of the number of days and the number of weeks before or after the PD date
  
  left_join(earliest_procedural_disenroll_dates, by = c('ma_receipt_num')) %>%
  mutate(tau_days = as.numeric(date - procedural_disenroll_date), 
         tau_weeks = floor(tau_days / 7)) %>%
  
# Pull in the person's dates of Medicaid enrollment
  
  left_join(medicaid_enrollment_dates_long_daily_transact1, by = c('ma_receipt_num', 'date')) %>%
  mutate(medicaid_enrolled = replace_na(medicaid_enrolled, 0)) %>%
  
# Calc the % of the sample that was enrolled in Medicaid in each week between +/- 365 days of their PD

  group_by(tau_weeks) %>%
  summarise(pct_medicaid_enrolled = mean(medicaid_enrolled)) %>%
  ungroup() %>%
  mutate(source = 'BH dates in daily table')

#----------------------------------------------------------------------------
# Using the 'MA' dates in the daily table

dt_ccbh_daily_ma <- base_sample_demographics %>%
    inner_join(analytic_sample, by = c('ma_receipt_num')) %>%
  filter(treat == 1) %>%
  select(ma_receipt_num) %>%
  inner_join(earliest_procedural_disenroll_dates, by = c('ma_receipt_num')) %>%
  mutate(start_date = procedural_disenroll_date - 365, 
         end_date = pmin(procedural_disenroll_date + 365, as.Date('2024-10-31'))) %>%
  group_by(ma_receipt_num) %>%
  reframe(date = seq.Date(from = start_date,
                         to = end_date,
                         by = "day")) %>%
  ungroup() %>%
  distinct(ma_receipt_num, date) %>%
  
# Count each date in terms of the number of days and the number of weeks before or after the PD date
  
  left_join(earliest_procedural_disenroll_dates, by = c('ma_receipt_num')) %>%
  mutate(tau_days = as.numeric(date - procedural_disenroll_date), 
         tau_weeks = floor(tau_days / 7)) %>%
  
# Pull in the person's dates of Medicaid enrollment
  
  left_join(medicaid_enrollment_dates_long_daily_transact2, by = c('ma_receipt_num', 'date')) %>%
  mutate(medicaid_enrolled = replace_na(medicaid_enrolled, 0)) %>%
  
# Calc the % of the sample that was enrolled in Medicaid in each week between +/- 365 days of their PD

  group_by(tau_weeks) %>%
  summarise(pct_medicaid_enrolled = mean(medicaid_enrolled)) %>%
  ungroup() %>%
  mutate(source = 'MA dates in daily table')

#----------------------------------------------------------------------------
# Using CCBH weekly episode dates

dt_ccbh_episodes <- base_sample_demographics %>%
    inner_join(analytic_sample, by = c('ma_receipt_num')) %>%
  filter(treat == 1) %>%
  select(ma_receipt_num) %>%
  inner_join(earliest_procedural_disenroll_dates, by = c('ma_receipt_num')) %>%
  mutate(start_date = procedural_disenroll_date - 365, 
         end_date = pmin(procedural_disenroll_date + 365, as.Date('2024-10-31'))) %>%
  group_by(ma_receipt_num) %>%
  reframe(date = seq.Date(from = start_date,
                         to = end_date,
                         by = "day")) %>%
  ungroup() %>%
  distinct(ma_receipt_num, date) %>%
  
# Count each date in terms of the number of days and the number of weeks before or after the PD date
  
  left_join(earliest_procedural_disenroll_dates, by = c('ma_receipt_num')) %>%
  mutate(tau_days = as.numeric(date - procedural_disenroll_date), 
         tau_weeks = floor(tau_days / 7)) %>%
  
# Pull in the person's dates of Medicaid enrollment
  
  left_join(medicaid_enrollment_dates_long_ccbh_episodes, by = c('ma_receipt_num', 'date')) %>%
  mutate(medicaid_enrolled = replace_na(medicaid_enrolled, 0)) %>%
  
# Calc the % of the sample that was enrolled in Medicaid in each week between +/- 365 days of their PD

  group_by(tau_weeks) %>%
  summarise(pct_medicaid_enrolled = mean(medicaid_enrolled)) %>%
  ungroup() %>%
  mutate(source = 'CCBH')

#----------------------------------------------------------------------------
# Using PADHS enrollment dates

dt_padhs <- base_sample_demographics %>%
    inner_join(analytic_sample, by = c('ma_receipt_num')) %>%
  filter(treat == 1) %>%
  select(ma_receipt_num) %>%
  inner_join(earliest_procedural_disenroll_dates, by = c('ma_receipt_num')) %>%
  mutate(start_date = procedural_disenroll_date - 365, 
         end_date = pmin(procedural_disenroll_date + 365, as.Date('2024-10-31'))) %>%
  group_by(ma_receipt_num) %>%
  reframe(date = seq.Date(from = start_date,
                         to = end_date,
                         by = "day")) %>%
  ungroup() %>%
  distinct(ma_receipt_num, date) %>%
  
# Count each date in terms of the number of days and the number of weeks before or after the PD date
  
  left_join(earliest_procedural_disenroll_dates, by = c('ma_receipt_num')) %>%
  mutate(tau_days = as.numeric(date - procedural_disenroll_date), 
         tau_weeks = floor(tau_days / 7)) %>%
  
# Pull in the person's dates of Medicaid enrollment
  
  left_join(medicaid_enrollment_dates_long_padhs, by = c('ma_receipt_num', 'date')) %>%
  mutate(medicaid_enrolled = replace_na(medicaid_enrolled, 0)) %>%
  
# Calc the % of the sample that was enrolled in Medicaid in each week between +/- 365 days of their PD

  group_by(tau_weeks) %>%
  summarise(pct_medicaid_enrolled = mean(medicaid_enrolled)) %>%
  ungroup() %>%
  mutate(source = 'PADHS')

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create graph

#----------------------------------------------------------------------------
# Using only the CCBH weekly episode dates

# Combine the results from the two sources of Medicaid enrollment data

dt_ccbh_episodes %>%
  
# Plot graph
  
  ggplot(mapping = aes(x = tau_weeks, y = pct_medicaid_enrolled)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = 0), color = "red", linetype = "dashed") + 
  theme_bw() +
  scale_x_continuous(breaks = seq(-55,55,5), 
                     limits = c(-55,55)) +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  labs(x = "Weeks since PD", y = "Pct of sample enrolled in Medicaid", title = "Figure 1 - Medicaid enrollment rates over time for the PD sample (N = 46,465)") + 
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/medicaid-enrollment-rates-relative-to-disenrollment-date.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)

#----------------------------------------------------------------------------
# Using all 4 sources of enrollment dates

# Combine the results from the two sources of Medicaid enrollment data

bind_rows(dt_ccbh_daily_bh, dt_ccbh_daily_ma, dt_ccbh_episodes, dt_padhs) %>%
  
# Plot graph
  
  ggplot(mapping = aes(x = tau_weeks, y = pct_medicaid_enrolled, colour = source, group = source)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = 0), color = "red", linetype = "dashed") + 
  theme_bw() +
  scale_x_continuous(breaks = seq(-55,55,5), 
                     limits = c(-55,55)) +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  labs(x = "Weeks since PD", y = "Pct of sample enrolled in Medicaid", title = "Medicaid enrollment rates over time for the PD sample") + 
  theme(panel.background = element_blank(), 
        panel.border = element_blank(),
        legend.title = element_blank(),
        legend.position = 'bottom',
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/medicaid-enrollment-rates-relative-to-disenrollment-date-source-comparison.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)
```

### Percentage of days during PHE disenrollment freeze (4/1/2020 and 4/1/2023) that each base sample member was enrolled in Medicaid, by treatment status

```{r}

#----------------------------------------------------------------------------
# Load relevant data

# Base sample 

load(file = paste0(filepath, "/Data/Sample demographics/base_sample_demographics.rda"))

# Medicaid enrollment episode dates - CCBH weekly episodes 

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_ccbh_episodes.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

# Take a random sample of the procedurally disenrolled clients to save memory

set.seed(62889)

analytic_sample <- base_sample_demographics %>%
  slice_sample(n = 20000, replace = FALSE) 

#----------------------------------------------------------------------------
# For each person, create a data frame with 1 obs for each day between 4/1/2020 and 4/1/2023, with their Medicaid enrollment status on each of these days. 

dt <- analytic_sample %>%
  left_join(medicaid_enrollment_dates_ccbh_episodes, by = c('ma_receipt_num')) %>%
  mutate(elig_to_date = replace_na(elig_to_date, as.Date('2023-04-01'))) %>%
  filter(elig_from_date <= as.Date('2023-04-01') & elig_to_date >= as.Date('2020-04-01')) %>%
  mutate(elig_to_date = if_else(elig_from_date > as.Date('2023-04-01'), as.Date('2023-04-01'), elig_to_date)) %>%
  group_by(ma_receipt_num, treat, elig_from_date, elig_to_date) %>%
  reframe(date = list(seq.Date(from = elig_from_date,
                               to = elig_to_date,
                               by = "day"))) %>%
  unnest(date) %>%
  ungroup() %>%
  distinct(ma_receipt_num, treat, date) %>%
  mutate(medicaid_enrolled = 1) %>%
  right_join(analytic_sample %>%
             mutate(start_date = as.Date('2020-04-01'), 
                    end_date = as.Date('2023-04-01')) %>%
             group_by(ma_receipt_num, treat) %>%
             reframe(date = seq.Date(from = start_date,
                         to = end_date,
                         by = "day")) %>%
             ungroup() %>%
             distinct(ma_receipt_num, treat, date),
             by = c('ma_receipt_num', 'treat', 'date')) %>%
  mutate(medicaid_enrolled = replace_na(medicaid_enrolled, 0)) %>%
  
# Calc the percentage of days in this time period that each person was enrolled in Medicaid
  
  group_by(ma_receipt_num, treat) %>%
  summarise(pct_days_medicaid_enrolled_ccbh_episodes = mean(medicaid_enrolled)) %>%
  ungroup() 

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Graph the distribution of the percentage of days between 4/1/2020 and 4/1/2023 on which each sample member was enrolled in Medicaid. Do this separately by T and C group

dt %>%
  mutate(bin = cut(pct_days_medicaid_enrolled_ccbh_episodes, breaks = seq(0, 1, .05), right = TRUE, labels = FALSE), 
         bin = replace_na(bin, 1)) %>%
  group_by(treat, bin) %>%
  summarise(count = n()) %>%
  group_by(treat) %>%
  mutate(pct_of_total = count / sum(count)) %>%
  ungroup() %>%
  mutate(treat = ifelse(treat == 0, "Has not had PD since end of PHE", "Had PD since end of PHE")) %>%
  ggplot(aes(x = bin, y = pct_of_total, fill = treat)) +  
  geom_col(position = position_nudge(x = -.5), alpha = 0.5) +  
  scale_y_continuous(breaks = seq(0, 1, 0.1),
                    limits = c(0, 1), 
                    labels = scales::percent_format(accuracy = 1)) +  
  scale_x_continuous(breaks = seq(0, 20, 1), 
                    limits = c(0, 20),
                    labels = c('0%', ' ', '10%', ' ', '20%', ' ', '30%', ' ', '40%', ' ', '50%', ' ', '60%', ' ', '70%', ' ', '80%', ' ', '90%', ' ', '100%')) +
  labs(x = "Pct of days enrolled in Medicaid", 
       y = "Pct of sample members", 
       title = "Number of days on which person was enrolled in Medicaid during PHE, for base sample") +
  theme_bw() +
  theme(legend.title = element_blank(),
        legend.position = 'bottom',
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(), 
        plot.title = element_text(size = 10),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/days-enrolled-during-covid.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)
```

### Percentage of days between the person's PD and 10/31/2024 on which the person was enrolled in Medicaid 

```{r}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample 

load(file = paste0(filepath, "/Data/Sample demographics/base_sample_demographics.rda"))

# Dates of PDs

load(file = paste0(filepath, "/Data/Medicaid enrollment data/procedural_disenrollment_dates.rda"))

# Medicaid enrollment episode dates - BH dates in daily table

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_ccbh_daily_transact1.rda"))

# Medicaid enrollment episode dates - MA dates in daily table

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_ccbh_daily_transact2.rda"))

# Medicaid enrollment episode dates - CCBH weekly episodes 

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_ccbh_episodes.rda"))

# Medicaid enrollment episode dates - PADHS 

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_padhs.rda"))

# Earliest post-4/1/2023 PD dates

load(file = paste0(filepath, "/Data/Medicaid enrollment data/earliest_procedural_disenroll_dates.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

# Take a random sample of the procedurally disenrolled clients to save memory

set.seed(62889)

analytic_sample <- earliest_procedural_disenroll_dates %>%
  slice_sample(n = 10000, replace = FALSE) %>%

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# For this analysis, remove people whose earliest PD date was after 9/1/2024. That is too close to the 10/31/2024 deadline to have a big effect on loss of Medicaid, because it takes a few weeks for people to lose Medicaid after they pass their disenrollment date

  filter(procedural_disenroll_date <= as.Date('2024-09-01')) %>%

# Store the distinct list of clients as the base sample for this analysis

  distinct(ma_receipt_num)

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create a data frame with 1 obs for each day between the person's earliest PD date and 10/31/2024, with their Medicaid enrollment status on each of these days. 

#----------------------------------------------------------------------------
# 'BH' dates in the daily table

# First create a data frame with 1 obs for each day that each sample member was enrolled in Medicaid between their PD date and 10/31/2024. 

dt_ccbh_daily_bh <- analytic_sample %>%
  select(ma_receipt_num) %>%
  left_join(medicaid_enrollment_dates_ccbh_daily_transact1, by = c('ma_receipt_num')) %>%
  
# Join with the person's earliest PD date
  
  left_join(earliest_procedural_disenroll_dates, by = c('ma_receipt_num')) %>%
  
# Remove obs in which the start date of the enrollment episode is after 10/31/2024
  
  filter(elig_from_date <= as.Date('2024-10-31')) %>%
  
# Recode missing values of the enrollment episode end date as 10/31/2024
  
  mutate(elig_to_date = replace_na(elig_to_date, as.Date('2024-10-31'))) %>%
  
# Remove obs where the episode end date was before their PD date
  
  filter(elig_to_date >= procedural_disenroll_date) %>%
  
# Recode any episode start dates as the person's disenrollment date if they are before the disenrollment date
  
  mutate(elig_from_date = if_else(elig_from_date < procedural_disenroll_date, procedural_disenroll_date, elig_from_date)) %>%
  
# Deduplicate the data
  
  distinct(ma_receipt_num, elig_from_date, elig_to_date, procedural_disenroll_date) %>%
  
# Reshape the data to have 1 obs for each day during each enrollment episode
  
  group_by(ma_receipt_num, elig_from_date, elig_to_date) %>%
  reframe(date = list(seq.Date(from = elig_from_date,
                               to = elig_to_date,
                               by = "day"))) %>%
  unnest(date) %>%
  ungroup() %>%
  distinct(ma_receipt_num, date) %>%
  mutate(medicaid_enrolled = 1) %>%
  
# Join the person's Medicaid enrollment dates with a grid of all dates between their PD date and 10/31/2024

  right_join(analytic_sample %>%
             left_join(earliest_procedural_disenroll_dates, by = c('ma_receipt_num')) %>%
             mutate(start_date = procedural_disenroll_date, 
             end_date = as.Date('2024-12-31')) %>%
             group_by(ma_receipt_num) %>%
             reframe(date = seq.Date(from = start_date,
                         to = end_date,
                         by = "day")) %>%
             ungroup() %>%
             distinct(ma_receipt_num, date),
             by = c('ma_receipt_num', 'date')) %>%
  mutate(medicaid_enrolled = replace_na(medicaid_enrolled, 0)) %>%
  
# For each person, calc the % of days between their PD date and 10/31/2024 on which they were enrolled in Medicaid

  group_by(ma_receipt_num) %>%
  summarise(pct_days_medicaid_enrolled_ccbh_daily_transact1 = mean(medicaid_enrolled)) %>%
  ungroup() 

#----------------------------------------------------------------------------
# 'MA' dates in the daily table

dt_ccbh_daily_ma <- analytic_sample %>%
  select(ma_receipt_num) %>%
  left_join(medicaid_enrollment_dates_ccbh_daily_transact2, by = c('ma_receipt_num')) %>%
  left_join(earliest_procedural_disenroll_dates, by = c('ma_receipt_num')) %>%
  filter(elig_from_date <= as.Date('2024-10-31')) %>%
  mutate(elig_to_date = replace_na(elig_to_date, as.Date('2024-10-31'))) %>%
  filter(elig_to_date >= procedural_disenroll_date) %>%
  mutate(elig_from_date = if_else(elig_from_date < procedural_disenroll_date, procedural_disenroll_date, elig_from_date)) %>%
    distinct(ma_receipt_num, elig_from_date, elig_to_date, procedural_disenroll_date) %>%
  group_by(ma_receipt_num, elig_from_date, elig_to_date) %>%
  reframe(date = list(seq.Date(from = elig_from_date,
                               to = elig_to_date,
                               by = "day"))) %>%
  unnest(date) %>%
  ungroup() %>%
  distinct(ma_receipt_num, date) %>%
  mutate(medicaid_enrolled = 1) %>%
  right_join(analytic_sample %>%
             left_join(earliest_procedural_disenroll_dates, by = c('ma_receipt_num')) %>%
             mutate(start_date = procedural_disenroll_date, 
             end_date = as.Date('2024-12-31')) %>%
             group_by(ma_receipt_num) %>%
             reframe(date = seq.Date(from = start_date,
                         to = end_date,
                         by = "day")) %>%
             ungroup() %>%
             distinct(ma_receipt_num, date),
             by = c('ma_receipt_num', 'date')) %>%
  mutate(medicaid_enrolled = replace_na(medicaid_enrolled, 0)) %>%
  group_by(ma_receipt_num) %>%
  summarise(pct_days_medicaid_enrolled_ccbh_daily_transact2 = mean(medicaid_enrolled)) %>%
  ungroup() 

#----------------------------------------------------------------------------
# Dates in the CCBH weekly episodes table

dt_ccbh_episodes <- analytic_sample %>%
  select(ma_receipt_num) %>%
  left_join(medicaid_enrollment_dates_ccbh_episodes, by = c('ma_receipt_num')) %>%
  left_join(earliest_procedural_disenroll_dates, by = c('ma_receipt_num')) %>%
  filter(elig_from_date <= as.Date('2024-10-31')) %>%
  mutate(elig_to_date = replace_na(elig_to_date, as.Date('2024-10-31'))) %>%
  filter(elig_to_date >= procedural_disenroll_date) %>%
  mutate(elig_from_date = if_else(elig_from_date < procedural_disenroll_date, procedural_disenroll_date, elig_from_date)) %>%
    distinct(ma_receipt_num, elig_from_date, elig_to_date, procedural_disenroll_date) %>%
  group_by(ma_receipt_num, elig_from_date, elig_to_date) %>%
  reframe(date = list(seq.Date(from = elig_from_date,
                               to = elig_to_date,
                               by = "day"))) %>%
  unnest(date) %>%
  ungroup() %>%
  distinct(ma_receipt_num, date) %>%
  mutate(medicaid_enrolled = 1) %>%
  right_join(analytic_sample %>%
             left_join(earliest_procedural_disenroll_dates, by = c('ma_receipt_num')) %>%
             mutate(start_date = procedural_disenroll_date, 
             end_date = as.Date('2024-12-31')) %>%
             group_by(ma_receipt_num) %>%
             reframe(date = seq.Date(from = start_date,
                         to = end_date,
                         by = "day")) %>%
             ungroup() %>%
             distinct(ma_receipt_num, date),
             by = c('ma_receipt_num', 'date')) %>%
  mutate(medicaid_enrolled = replace_na(medicaid_enrolled, 0)) %>%
  group_by(ma_receipt_num) %>%
  summarise(pct_days_medicaid_enrolled_ccbh_episodes = mean(medicaid_enrolled)) %>%
  ungroup() 

#----------------------------------------------------------------------------
# Dates in the PADHS table

dt_padhs <- analytic_sample %>%
  select(ma_receipt_num) %>%
  left_join(medicaid_enrollment_dates_padhs, by = c('ma_receipt_num')) %>%
  left_join(earliest_procedural_disenroll_dates, by = c('ma_receipt_num')) %>%
  filter(elig_from_date <= as.Date('2024-10-31')) %>%
  mutate(elig_to_date = replace_na(elig_to_date, as.Date('2024-10-31'))) %>%
  filter(elig_to_date >= procedural_disenroll_date) %>%
  mutate(elig_from_date = if_else(elig_from_date < procedural_disenroll_date, procedural_disenroll_date, elig_from_date)) %>%
    distinct(ma_receipt_num, elig_from_date, elig_to_date, procedural_disenroll_date) %>%
  group_by(ma_receipt_num, elig_from_date, elig_to_date) %>%
  reframe(date = list(seq.Date(from = elig_from_date,
                               to = elig_to_date,
                               by = "day"))) %>%
  unnest(date) %>%
  ungroup() %>%
  distinct(ma_receipt_num, date) %>%
  mutate(medicaid_enrolled = 1) %>%
  right_join(analytic_sample %>%
             left_join(earliest_procedural_disenroll_dates, by = c('ma_receipt_num')) %>%
             mutate(start_date = procedural_disenroll_date, 
             end_date = as.Date('2024-12-31')) %>%
             group_by(ma_receipt_num) %>%
             reframe(date = seq.Date(from = start_date,
                         to = end_date,
                         by = "day")) %>%
             ungroup() %>%
             distinct(ma_receipt_num, date),
             by = c('ma_receipt_num', 'date')) %>%
  mutate(medicaid_enrolled = replace_na(medicaid_enrolled, 0)) %>%
  group_by(ma_receipt_num) %>%
  summarise(pct_days_medicaid_enrolled_padhs = mean(medicaid_enrolled)) %>%
  ungroup() 

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create graphs of the distribution of the percentage of days between a person's earliest PD date and 10/31/2024 on which they were enrolled in Medicaid. Create separate graphs by date source.

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# 'BH' dates in the daily table

plot1 <- dt_ccbh_daily_bh %>%
  mutate(bin = cut(pct_days_medicaid_enrolled_ccbh_daily_transact1, breaks = seq(0, 1, .05), right = TRUE, labels = FALSE), 
         bin = replace_na(bin, 1)) %>%
  group_by(bin) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  mutate(pct_of_total = count / sum(count)) %>%
  ggplot(aes(x = bin, y = pct_of_total)) +
  geom_bar(stat = "identity", position = position_nudge(x = -.5), colour = 'black') + 
  scale_y_continuous(breaks = seq(0, 0.4, 0.05),
                     limits = c(0, 0.4), 
                     labels = scales::percent_format(accuracy = 1)) +  
  scale_x_continuous(breaks = seq(0, 20, 1), 
                    limits = c(0, 20),
                   labels = c('0%', ' ', '10%', ' ', '20%', ' ', '30%', ' ', '40%', ' ', '50%', ' ', '60%', ' ', '70%', ' ', '80%', ' ', '90%', ' ', '100%')) +
  labs(x = "% of days enrolled in Medicaid", y = "% of sample members", title = "Using 'BH' dates from daily file") +
  theme_bw() +
  theme(legend.title = element_blank(),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(), 
        plot.caption = element_text(hjust = 0))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# 'MA' dates in the daily table

plot2 <- dt_ccbh_daily_ma %>%
  mutate(bin = cut(pct_days_medicaid_enrolled_ccbh_daily_transact2, breaks = seq(0, 1, .05), right = TRUE, labels = FALSE), 
         bin = replace_na(bin, 1)) %>%
  group_by(bin) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  mutate(pct_of_total = count / sum(count)) %>%
  ggplot(aes(x = bin, y = pct_of_total)) +
  geom_bar(stat = "identity", position = position_nudge(x = -.5), colour = 'black') + 
  scale_y_continuous(breaks = seq(0, 0.4, 0.05),
                     limits = c(0, 0.4), 
                     labels = scales::percent_format(accuracy = 1)) +  
  scale_x_continuous(breaks = seq(0, 20, 1), 
                    limits = c(0, 20),
                   labels = c('0%', ' ', '10%', ' ', '20%', ' ', '30%', ' ', '40%', ' ', '50%', ' ', '60%', ' ', '70%', ' ', '80%', ' ', '90%', ' ', '100%')) +
  labs(x = "% of days enrolled in Medicaid", y = "% of sample members", title = "Using 'MA' dates from daily file") +
  theme_bw() +
  theme(legend.title = element_blank(),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(), 
        plot.caption = element_text(hjust = 0))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Dates in the CCBH weekly episodes table

plot3 <- dt_ccbh_episodes %>%
  mutate(bin = cut(pct_days_medicaid_enrolled_ccbh_episodes, breaks = seq(0, 1, .05), right = TRUE, labels = FALSE), 
         bin = replace_na(bin, 1)) %>%
  group_by(bin) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  mutate(pct_of_total = count / sum(count)) %>%
  ggplot(aes(x = bin, y = pct_of_total)) +
  geom_bar(stat = "identity", position = position_nudge(x = -.5), colour = 'black') + 
  scale_y_continuous(breaks = seq(0, 0.4, 0.05),
                     limits = c(0, 0.4), 
                     labels = scales::percent_format(accuracy = 1)) +  
  scale_x_continuous(breaks = seq(0, 20, 1), 
                    limits = c(0, 20),
                   labels = c('0%', ' ', '10%', ' ', '20%', ' ', '30%', ' ', '40%', ' ', '50%', ' ', '60%', ' ', '70%', ' ', '80%', ' ', '90%', ' ', '100%')) +
  labs(x = "% of days enrolled in Medicaid", y = "% of sample members", title = "Using dates from CCBH weekly file") +
  theme_bw() +
  theme(legend.title = element_blank(),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(), 
        plot.caption = element_text(hjust = 0))

# Create a separate standalone version of this graph

dt_ccbh_episodes %>%
  mutate(bin = cut(pct_days_medicaid_enrolled_ccbh_episodes, breaks = seq(0, 1, .05), right = TRUE, labels = FALSE), 
         bin = replace_na(bin, 1)) %>%
  group_by(bin) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  mutate(pct_of_total = count / sum(count)) %>%
  ggplot(aes(x = bin, y = pct_of_total)) +
  geom_bar(stat = "identity", position = position_nudge(x = -.5), colour = 'black') + 
  scale_y_continuous(breaks = seq(0, 0.4, 0.05),
                     limits = c(0, 0.4), 
                     labels = scales::percent_format(accuracy = 1)) +  
  scale_x_continuous(breaks = seq(0, 20, 1), 
                    limits = c(0, 20),
                   labels = c('0%', ' ', '10%', ' ', '20%', ' ', '30%', ' ', '40%', ' ', '50%', ' ', '60%', ' ', '70%', ' ', '80%', ' ', '90%', ' ', '100%')) +
  labs(x = "Pct of days covered by Medicaid", y = "Pct of PD sample", title = "Pct of days covered by Medicaid between PD and 10/31/2024") +
  theme_bw() +
  theme(legend.title = element_blank(),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(), 
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/days-enrolled-after-procedural-disenrollment.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Dates in the PADHS table

plot4 <- dt_padhs %>%
  mutate(bin = cut(pct_days_medicaid_enrolled_padhs, breaks = seq(0, 1, .05), right = TRUE, labels = FALSE), 
         bin = replace_na(bin, 1)) %>%
  group_by(bin) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  mutate(pct_of_total = count / sum(count)) %>%
  ggplot(aes(x = bin, y = pct_of_total)) +
  geom_bar(stat = "identity", position = position_nudge(x = -.5), colour = 'black') + 
  scale_y_continuous(breaks = seq(0, 0.5, 0.05),
                     limits = c(0, 0.5), 
                     labels = scales::percent_format(accuracy = 1)) +  
  scale_x_continuous(breaks = seq(0, 20, 1), 
                    limits = c(0, 20),
                   labels = c('0%', ' ', '10%', ' ', '20%', ' ', '30%', ' ', '40%', ' ', '50%', ' ', '60%', ' ', '70%', ' ', '80%', ' ', '90%', ' ', '100%')) +
  labs(x = "% of days enrolled in Medicaid", y = "% of sample members", title = "Using dates from PADHS file") +
  theme_bw() +
  theme(legend.title = element_blank(),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(), 
        plot.caption = element_text(hjust = 0))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Plot all graphs in panel

chart_panel <- plot_grid(plot1, plot2, plot3, plot4, nrow = 2, ncol = 2)

plot_grid(chart_panel)

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/days-enrolled-after-procedural-disenrollment-source-comparison.png"), 
  plot = last_plot(),
  width = 7,
  height = 7)
```

### Among the people who lost Medicaid after their PD, how long were they off of Medicaid before they got back on? 

```{r}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample 

load(file = paste0(filepath, "/Data/Sample demographics/base_sample_demographics.rda"))

# Dates of PDs

load(file = paste0(filepath, "/Data/Medicaid enrollment data/procedural_disenrollment_dates.rda"))

# Medicaid enrollment episode dates - BH dates in daily table

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_ccbh_daily_transact1.rda"))

# Medicaid enrollment episode dates - MA dates in daily table

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_ccbh_daily_transact2.rda"))

# Medicaid enrollment episode dates - CCBH weekly episodes 

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_ccbh_episodes.rda"))

# Medicaid enrollment episode dates - PADHS 

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_padhs.rda"))

# Earliest post-4/1/2023 PD dates

load(file = paste0(filepath, "/Data/Medicaid enrollment data/earliest_procedural_disenroll_dates.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# For this analysis, keep only the people whose PD date was in May 2023. This ensures that I use roughly the same size of time window when seeing how long the person stayed off of Medicaid
  
analytic_sample <- earliest_procedural_disenroll_dates %>%
  mutate(disenrollment_month_year = format(procedural_disenroll_date, "%Y-%m")) %>%
  filter(disenrollment_month_year == "2023-05") %>%

# Store the distinct list of clients as the base sample for this analysis

  distinct(ma_receipt_num)

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create a data frame with 1 obs for each day between the person's earliest PD date and 10/31/2024, with their Medicaid enrollment status on each of these days. Do this separately for each date source.

#----------------------------------------------------------------------------
# 'BH' dates in the daily table

# First create a data frame with 1 obs for each day that each sample member was enrolled in Medicaid between their PD date and 10/31/2024. 

dt_ccbh_daily_bh <- analytic_sample %>%
  select(ma_receipt_num) %>%
  left_join(medicaid_enrollment_dates_ccbh_daily_transact1, by = c('ma_receipt_num')) %>%
  
# Join with the person's earliest PD date
  
  left_join(earliest_procedural_disenroll_dates, by = c('ma_receipt_num')) %>%
  
# Remove obs in which the start date of the enrollment episode is after 10/31/2024
  
  filter(elig_from_date <= as.Date('2024-10-31')) %>%
  
# Recode missing values of the enrollment episode end date as 10/31/2024
  
  mutate(elig_to_date = replace_na(elig_to_date, as.Date('2024-10-31'))) %>%
  
# Remove obs where the episode end date was before their PD date
  
  filter(elig_to_date >= procedural_disenroll_date) %>%
  
# Recode any episode start dates as the person's disenrollment date if they are before the disenrollment date
  
  mutate(elig_from_date = if_else(elig_from_date < procedural_disenroll_date, procedural_disenroll_date, elig_from_date)) %>%
  
# Deduplicate the data
  
  distinct(ma_receipt_num, elig_from_date, elig_to_date, procedural_disenroll_date) %>%
  
# Reshape the data to have 1 obs for each day during each enrollment episode
  
  group_by(ma_receipt_num, elig_from_date, elig_to_date) %>%
  reframe(date = list(seq.Date(from = elig_from_date,
                               to = elig_to_date,
                               by = "day"))) %>%
  unnest(date) %>%
  ungroup() %>%
  distinct(ma_receipt_num, date) %>%
  mutate(medicaid_enrolled = 1) %>%
  
# Join with a grid of dates between the person's procedural enrollment date and 10/31/2024

  right_join(earliest_procedural_disenroll_dates %>%
             inner_join(analytic_sample, by = c('ma_receipt_num')) %>%
             mutate(start_date = procedural_disenroll_date, 
                    end_date = as.Date('2024-10-31')) %>%
             group_by(ma_receipt_num) %>%
             reframe(date = seq.Date(from = start_date,
                         to = end_date,
                         by = "day")) %>%
            ungroup() %>%
            distinct(ma_receipt_num, date),
            by = c('ma_receipt_num', 'date')) %>%
  mutate(medicaid_enrolled = replace_na(medicaid_enrolled, 0)) %>%
  
# For each client, keep only the days from after their Medicaid enrollment ended and before they got back onto Medicaid
  
  group_by(ma_receipt_num) %>%
  mutate(first_one = which(medicaid_enrolled == 1)[1],
         after_first_one = row_number() > first_one,
         group_num = cumsum(medicaid_enrolled != lag(medicaid_enrolled, default = first(!after_first_one))),
         target_group = group_num[which(after_first_one & medicaid_enrolled == 0)[1]]) %>%
  filter(after_first_one == TRUE & medicaid_enrolled == 0 & group_num == target_group) %>%
  ungroup() %>%
  select(-first_one, -after_first_one, -group_num, -target_group) %>%

# Count the number of days for each client
  
  group_by(ma_receipt_num) %>%
  summarise(n_days_disenrolled = n()) %>%
  ungroup() 

#----------------------------------------------------------------------------
# 'MA' dates in the daily table

dt_ccbh_daily_ma <- analytic_sample %>%
  select(ma_receipt_num) %>%
  left_join(medicaid_enrollment_dates_ccbh_daily_transact2, by = c('ma_receipt_num')) %>%
  left_join(earliest_procedural_disenroll_dates, by = c('ma_receipt_num')) %>%
  filter(elig_from_date <= as.Date('2024-10-31')) %>%
  mutate(elig_to_date = replace_na(elig_to_date, as.Date('2024-10-31'))) %>%
  filter(elig_to_date >= procedural_disenroll_date) %>%
  mutate(elig_from_date = if_else(elig_from_date < procedural_disenroll_date, procedural_disenroll_date, elig_from_date)) %>%
  distinct(ma_receipt_num, elig_from_date, elig_to_date, procedural_disenroll_date) %>%
  group_by(ma_receipt_num, elig_from_date, elig_to_date) %>%
  reframe(date = list(seq.Date(from = elig_from_date,
                               to = elig_to_date,
                               by = "day"))) %>%
  unnest(date) %>%
  ungroup() %>%
  distinct(ma_receipt_num, date) %>%
  mutate(medicaid_enrolled = 1) %>%
  right_join(earliest_procedural_disenroll_dates %>%
             inner_join(analytic_sample, by = c('ma_receipt_num')) %>%
             mutate(start_date = procedural_disenroll_date, 
                    end_date = as.Date('2024-10-31')) %>%
             group_by(ma_receipt_num) %>%
             reframe(date = seq.Date(from = start_date,
                         to = end_date,
                         by = "day")) %>%
            ungroup() %>%
            distinct(ma_receipt_num, date),
            by = c('ma_receipt_num', 'date')) %>%
  mutate(medicaid_enrolled = replace_na(medicaid_enrolled, 0)) %>%
  group_by(ma_receipt_num) %>%
  mutate(first_one = which(medicaid_enrolled == 1)[1],
         after_first_one = row_number() > first_one,
         group_num = cumsum(medicaid_enrolled != lag(medicaid_enrolled, default = first(!after_first_one))),
         target_group = group_num[which(after_first_one & medicaid_enrolled == 0)[1]]) %>%
  filter(after_first_one & medicaid_enrolled == 0 & group_num == target_group) %>%
  ungroup() %>%
  select(-first_one, -after_first_one, -group_num, -target_group) %>%
  group_by(ma_receipt_num) %>%
  summarise(n_days_disenrolled = n()) %>%
  ungroup() 

#----------------------------------------------------------------------------
# Dates in CCBH weekly episodes table

dt_ccbh_episodes <- analytic_sample %>%
  select(ma_receipt_num) %>%
  left_join(medicaid_enrollment_dates_ccbh_episodes, by = c('ma_receipt_num')) %>%
  left_join(earliest_procedural_disenroll_dates, by = c('ma_receipt_num')) %>%
  filter(elig_from_date <= as.Date('2024-10-31')) %>%
  mutate(elig_to_date = replace_na(elig_to_date, as.Date('2024-10-31'))) %>%
  filter(elig_to_date >= procedural_disenroll_date) %>%
  mutate(elig_from_date = if_else(elig_from_date < procedural_disenroll_date, procedural_disenroll_date, elig_from_date)) %>%
  distinct(ma_receipt_num, elig_from_date, elig_to_date, procedural_disenroll_date) %>%
  group_by(ma_receipt_num, elig_from_date, elig_to_date) %>%
  reframe(date = list(seq.Date(from = elig_from_date,
                               to = elig_to_date,
                               by = "day"))) %>%
  unnest(date) %>%
  ungroup() %>%
  distinct(ma_receipt_num, date) %>%
  mutate(medicaid_enrolled = 1) %>%
  right_join(earliest_procedural_disenroll_dates %>%
             inner_join(analytic_sample, by = c('ma_receipt_num')) %>%
             mutate(start_date = procedural_disenroll_date, 
                    end_date = as.Date('2024-10-31')) %>%
             group_by(ma_receipt_num) %>%
             reframe(date = seq.Date(from = start_date,
                         to = end_date,
                         by = "day")) %>%
            ungroup() %>%
            distinct(ma_receipt_num, date),
            by = c('ma_receipt_num', 'date')) %>%
  mutate(medicaid_enrolled = replace_na(medicaid_enrolled, 0)) %>%
  group_by(ma_receipt_num) %>%
  mutate(first_one = which(medicaid_enrolled == 1)[1],
         after_first_one = row_number() > first_one,
         group_num = cumsum(medicaid_enrolled != lag(medicaid_enrolled, default = first(!after_first_one))),
         target_group = group_num[which(after_first_one & medicaid_enrolled == 0)[1]]) %>%
  filter(after_first_one & medicaid_enrolled == 0 & group_num == target_group) %>%
  ungroup() %>%
  select(-first_one, -after_first_one, -group_num, -target_group) %>%
  group_by(ma_receipt_num) %>%
  summarise(n_days_disenrolled = n()) %>%
  ungroup() 

#----------------------------------------------------------------------------
# Dates in PADHS table

dt_padhs <- analytic_sample %>%
  select(ma_receipt_num) %>%
  left_join(medicaid_enrollment_dates_padhs, by = c('ma_receipt_num')) %>%
  left_join(earliest_procedural_disenroll_dates, by = c('ma_receipt_num')) %>%
  filter(elig_from_date <= as.Date('2024-10-31')) %>%
  mutate(elig_to_date = replace_na(elig_to_date, as.Date('2024-10-31'))) %>%
  filter(elig_to_date >= procedural_disenroll_date) %>%
  mutate(elig_from_date = if_else(elig_from_date < procedural_disenroll_date, procedural_disenroll_date, elig_from_date)) %>%
  distinct(ma_receipt_num, elig_from_date, elig_to_date, procedural_disenroll_date) %>%
  group_by(ma_receipt_num, elig_from_date, elig_to_date) %>%
  reframe(date = list(seq.Date(from = elig_from_date,
                               to = elig_to_date,
                               by = "day"))) %>%
  unnest(date) %>%
  ungroup() %>%
  distinct(ma_receipt_num, date) %>%
  mutate(medicaid_enrolled = 1) %>%
  right_join(earliest_procedural_disenroll_dates %>%
             inner_join(analytic_sample, by = c('ma_receipt_num')) %>%
             mutate(start_date = procedural_disenroll_date, 
                    end_date = as.Date('2024-10-31')) %>%
             group_by(ma_receipt_num) %>%
             reframe(date = seq.Date(from = start_date,
                         to = end_date,
                         by = "day")) %>%
            ungroup() %>%
            distinct(ma_receipt_num, date),
            by = c('ma_receipt_num', 'date')) %>%
  mutate(medicaid_enrolled = replace_na(medicaid_enrolled, 0)) %>%
  group_by(ma_receipt_num) %>%
  mutate(first_one = which(medicaid_enrolled == 1)[1],
         after_first_one = row_number() > first_one,
         group_num = cumsum(medicaid_enrolled != lag(medicaid_enrolled, default = first(!after_first_one))),
         target_group = group_num[which(after_first_one & medicaid_enrolled == 0)[1]]) %>%
  filter(after_first_one & medicaid_enrolled == 0 & group_num == target_group) %>%
  ungroup() %>%
  select(-first_one, -after_first_one, -group_num, -target_group) %>%
  group_by(ma_receipt_num) %>%
  summarise(n_days_disenrolled = n()) %>%
  ungroup() 

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create graphs of the distribution of the number of days that a person was not enrolled on Medicaid between their first loss of coverage after their PD and their first time getting back onto Medicaid after that. Create separate graphs by date source.

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# 'BH' dates in the daily table

plot1 <- dt_ccbh_daily_bh %>%
  mutate(bin = cut(n_days_disenrolled, breaks = seq(0, 300, 25), right = TRUE, labels = FALSE), 
         bin = replace_na(bin, 13)) %>%
  group_by(bin) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  mutate(pct_of_total = count / sum(count)) %>%
  ggplot(aes(x = bin, y = pct_of_total)) +
  geom_bar(stat = "identity", position = position_nudge(x = -.5), colour = 'black') + 
  scale_y_continuous(breaks = seq(0, 0.8, 0.1),
                     limits = c(0, 0.8), 
                     labels = scales::percent_format(accuracy = 1)) +  
  scale_x_continuous(breaks = seq(0, 13, 1), 
                    limits = c(0, 13),
                   labels = c('0', ' ', '50', ' ', '100', ' ', '150', ' ', '200', ' ', '250', ' ', '300+', ' ')) +
  labs(x = "Number of consecutive days not on Medicaid", y = "% of sample members", title = "Using 'BH' dates from daily file") +
  theme_bw() +
  theme(legend.title = element_blank(),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(), 
        plot.caption = element_text(hjust = 0))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# 'MA' dates in the daily table

plot2 <- dt_ccbh_daily_ma %>%
  mutate(bin = cut(n_days_disenrolled, breaks = seq(0, 300, 25), right = TRUE, labels = FALSE), 
         bin = replace_na(bin, 13)) %>%
  group_by(bin) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  mutate(pct_of_total = count / sum(count)) %>%
  ggplot(aes(x = bin, y = pct_of_total)) +
  geom_bar(stat = "identity", position = position_nudge(x = -.5), colour = 'black') + 
  scale_y_continuous(breaks = seq(0, 0.8, 0.1),
                     limits = c(0, 0.8), 
                     labels = scales::percent_format(accuracy = 1)) +  
  scale_x_continuous(breaks = seq(0, 13, 1), 
                    limits = c(0, 13),
                   labels = c('0', ' ', '50', ' ', '100', ' ', '150', ' ', '200', ' ', '250', ' ', '300+', ' ')) +
  labs(x = "Number of consecutive days not on Medicaid", y = "% of sample members", title = "Using 'MA' dates from daily file") +
  theme_bw() +
  theme(legend.title = element_blank(),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(), 
        plot.caption = element_text(hjust = 0))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Dates in the CCBH weekly episodes table

plot3 <- dt_ccbh_episodes %>%
  mutate(bin = cut(n_days_disenrolled, breaks = seq(0, 300, 25), right = TRUE, labels = FALSE), 
         bin = replace_na(bin, 13)) %>%
  group_by(bin) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  mutate(pct_of_total = count / sum(count)) %>%
  ggplot(aes(x = bin, y = pct_of_total)) +
  geom_bar(stat = "identity", position = position_nudge(x = -.5), colour = 'black') + 
  scale_y_continuous(breaks = seq(0, 0.8, 0.1),
                     limits = c(0, 0.8), 
                     labels = scales::percent_format(accuracy = 1)) +  
  scale_x_continuous(breaks = seq(0, 13, 1), 
                    limits = c(0, 13),
                   labels = c('0', ' ', '50', ' ', '100', ' ', '150', ' ', '200', ' ', '250', ' ', '300+', ' ')) +
  labs(x = "Number of consecutive days not on Medicaid", y = "% of sample members", title = "Using dates from CCBH weekly file") +
  theme_bw() +
  theme(legend.title = element_blank(),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(), 
        plot.caption = element_text(hjust = 0))

# Create a separate standalone version of this graph

dt_ccbh_episodes %>%
  mutate(bin = cut(n_days_disenrolled, breaks = seq(0, 300, 25), right = TRUE, labels = FALSE), 
         bin = replace_na(bin, 13)) %>%
  group_by(bin) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  mutate(pct_of_total = count / sum(count)) %>%
  ggplot(aes(x = bin, y = pct_of_total)) +
  geom_bar(stat = "identity", position = position_nudge(x = -.5), colour = 'black') + 
  scale_y_continuous(breaks = seq(0, 0.8, 0.1),
                     limits = c(0, 0.8), 
                     labels = scales::percent_format(accuracy = 1)) +  
  scale_x_continuous(breaks = seq(0, 13, 1), 
                    limits = c(0, 13),
                   labels = c('0', ' ', '50', ' ', '100', ' ', '150', ' ', '200', ' ', '250', ' ', '300+', ' ')) +
  labs(x = "Consecutive days without Medicaid (N)", y = "Pct of May 2023 PD cohort", title = "Consecutive days without Medicaid between PD and 10/31/2024,\namong the May 2023 PD cohort (N = 2,503)") +
  theme_bw() +
  theme(legend.title = element_blank(),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(), 
        plot.caption = element_text(hjust = 0))

ggsave(paste0(filepath, "/Tables and figures/days-off-medicaid-after-disenrollment.png"), 
  plot = last_plot(),
  width = 7,
  height = 4)

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Dates in the PADHS table

plot4 <- dt_padhs %>%
  mutate(bin = cut(n_days_disenrolled, breaks = seq(0, 300, 25), right = TRUE, labels = FALSE), 
         bin = replace_na(bin, 13)) %>%
  group_by(bin) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  mutate(pct_of_total = count / sum(count)) %>%
  ggplot(aes(x = bin, y = pct_of_total)) +
  geom_bar(stat = "identity", position = position_nudge(x = -.5), colour = 'black') + 
  scale_y_continuous(breaks = seq(0, 0.8, 0.1),
                     limits = c(0, 0.8), 
                     labels = scales::percent_format(accuracy = 1)) +  
  scale_x_continuous(breaks = seq(0, 13, 1), 
                    limits = c(0, 13),
                   labels = c('0', ' ', '50', ' ', '100', ' ', '150', ' ', '200', ' ', '250', ' ', '300+', ' ')) +
  labs(x = "Number of consecutive days not on Medicaid", y = "% of sample members", title = "Using dates from PADHS file") +
  theme_bw() +
  theme(legend.title = element_blank(),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(), 
        plot.caption = element_text(hjust = 0))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Plot all graphs in panel

chart_panel <- plot_grid(plot1, plot2, plot3, plot4, nrow = 2, ncol = 2)

plot_grid(chart_panel)

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/days-off-medicaid-after-disenrollment-source-comparison.png"), 
  plot = last_plot(),
  width = 7,
  height = 7)
```

### Compare Medicaid enrollment dates across 4 data sources: 1) The 'MA' start and end dates in the CCBH daily transactions table 2) The 'BH' start and end dates in the CCBH daily transactions table 3) The start and end dates in the weekly CCBH episodes table, and 4) The start and end dates in the monthly PADHS feed

```{r}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample

load(file = paste0(filepath, "/Data/Sample demographics/base_sample_demographics.rda"))

# Dates of PDs

load(file = paste0(filepath, "/Data/Medicaid enrollment data/procedural_disenrollment_dates.rda"))

# Medicaid enrollment episode dates - CCBH daily transactions 'BH' dates

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_ccbh_daily_transact1.rda"))

# Medicaid enrollment episode dates - CCBH daily transactions 'MA' dates

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_ccbh_daily_transact2.rda"))

# Medicaid enrollment episode dates - CCBH weekly episodes table

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_ccbh_episodes.rda"))

# Medicaid enrollment episode dates - Monthly PADHS data

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_padhs.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Take a random sub-sample of the base study sample, to save memory

set.seed(62889)

analytic_sample <- base_sample_demographics %>%
  slice_sample(n = 25000, replace = FALSE)   

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create a data frame with 1 obs for each day that each sample member was enrolled in Medicaid, setting a floor at 4/1/2023 and a ceiling of 10/31/2024 to save memory. Do this separately for each of the 4 date sources being compared

#----------------------------------------------------------------------------
# 'BH' dates in the CCBH daily transactions table

medicaid_enrollment_dates_long_ccbh_daily_transact1 <- analytic_sample %>%
  select(ma_receipt_num) %>%
  left_join(medicaid_enrollment_dates_ccbh_daily_transact1, by = c('ma_receipt_num')) %>%
  
# Make the minimum start date 4/1/2023 and the maximum end date 10/31/2024
  
  filter(elig_from_date <= as.Date('2024-10-31')) %>%
  mutate(elig_to_date = replace_na(elig_to_date, as.Date('2024-10-31'))) %>%
  filter(elig_to_date >= as.Date('2023-04-01')) %>%
  mutate(elig_from_date = if_else(elig_from_date < as.Date('2023-04-01'), as.Date('2023-04-01'), elig_from_date)) %>%
  
# Deduplicate the data 
  
  distinct(ma_receipt_num, elig_from_date, elig_to_date) %>%
  
# Reshape the data to have 1 obs for each day during each enrollment episode
  
  group_by(ma_receipt_num, elig_from_date, elig_to_date) %>%
  reframe(date = list(seq.Date(from = elig_from_date,
                               to = elig_to_date,
                               by = "day"))) %>%
  unnest(date) %>%
  ungroup() %>%
  distinct(ma_receipt_num, date) %>%
  mutate(medicaid_enrolled = 1)

#----------------------------------------------------------------------------
# 'MA' dates in the CCBH daily transactions table

medicaid_enrollment_dates_long_ccbh_daily_transact2 <- analytic_sample %>%
  select(ma_receipt_num) %>%
  left_join(medicaid_enrollment_dates_ccbh_daily_transact2, by = c('ma_receipt_num')) %>%
  
# Make the minimum start date 4/1/2023 and the maximum end date 10/31/2024
  
  filter(elig_from_date <= as.Date('2024-10-31')) %>%
  mutate(elig_to_date = replace_na(elig_to_date, as.Date('2024-10-31'))) %>%
  filter(elig_to_date >= as.Date('2023-04-01')) %>%
  mutate(elig_from_date = if_else(elig_from_date < as.Date('2023-04-01'), as.Date('2023-04-01'), elig_from_date)) %>%
  
# Deduplicate the data 
  
  distinct(ma_receipt_num, elig_from_date, elig_to_date) %>%
  
# Reshape the data to have 1 obs for each day during each enrollment episode
  
  group_by(ma_receipt_num, elig_from_date, elig_to_date) %>%
  reframe(date = list(seq.Date(from = elig_from_date,
                               to = elig_to_date,
                               by = "day"))) %>%
  unnest(date) %>%
  ungroup() %>%
  distinct(ma_receipt_num, date) %>%
  mutate(medicaid_enrolled = 1)

#----------------------------------------------------------------------------
# Dates in the CCBH weekly episodes table

medicaid_enrollment_dates_long_ccbh_episodes <- analytic_sample %>%
  select(ma_receipt_num) %>%
  left_join(medicaid_enrollment_dates_ccbh_episodes, by = c('ma_receipt_num')) %>%
  
# Make the minimum start date 4/1/2023 and the maximum end date 10/31/2024
  
  filter(elig_from_date <= as.Date('2024-10-31')) %>%
  mutate(elig_to_date = replace_na(elig_to_date, as.Date('2024-10-31'))) %>%
  filter(elig_to_date >= as.Date('2023-04-01')) %>%
  mutate(elig_from_date = if_else(elig_from_date < as.Date('2023-04-01'), as.Date('2023-04-01'), elig_from_date)) %>%
  
# Deduplicate the data 
  
  distinct(ma_receipt_num, elig_from_date, elig_to_date) %>%
  
# Reshape the data to have 1 obs for each day during each enrollment episode
  
  group_by(ma_receipt_num, elig_from_date, elig_to_date) %>%
  reframe(date = list(seq.Date(from = elig_from_date,
                               to = elig_to_date,
                               by = "day"))) %>%
  unnest(date) %>%
  ungroup() %>%
  distinct(ma_receipt_num, date) %>%
  mutate(medicaid_enrolled = 1)

#----------------------------------------------------------------------------
# Dates in the PADHS monthly data

medicaid_enrollment_dates_long_padhs <- analytic_sample %>%
  select(ma_receipt_num) %>%
  left_join(medicaid_enrollment_dates_padhs, by = c('ma_receipt_num')) %>%
  
# Make the minimum start date 4/1/2023 and the maximum end date 10/31/2024
  
  filter(elig_from_date <= as.Date('2024-10-31')) %>%
  mutate(elig_to_date = replace_na(elig_to_date, as.Date('2024-10-31'))) %>%
  filter(elig_to_date >= as.Date('2023-04-01')) %>%
  mutate(elig_from_date = if_else(elig_from_date < as.Date('2023-04-01'), as.Date('2023-04-01'), elig_from_date)) %>%
  
# Deduplicate the data 
  
  distinct(ma_receipt_num, elig_from_date, elig_to_date) %>%
  
# Reshape the data to have 1 obs for each day during each enrollment episode
  
  group_by(ma_receipt_num, elig_from_date, elig_to_date) %>%
  reframe(date = list(seq.Date(from = elig_from_date,
                               to = elig_to_date,
                               by = "day"))) %>%
  unnest(date) %>%
  ungroup() %>%
  distinct(ma_receipt_num, date) %>%
  mutate(medicaid_enrolled = 1)

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create a data frame with 1 obs for each client for each day between 4/1/2023 and 10/31/2024, with their Medicaid enrollment status on each of these days according to each of the 4 date sources. 

dt <- analytic_sample %>%
  select(ma_receipt_num) %>%
  group_by(ma_receipt_num) %>%
  reframe(date = list(seq.Date(from = as.Date('2023-04-01'),
                               to = as.Date('2024-10-31'),
                               by = "day"))) %>%
  unnest(date) %>%
  ungroup() %>%
  
# Pull in the person's dates of Medicaid enrollment from each of the 4 sources
  
  left_join(medicaid_enrollment_dates_long_ccbh_daily_transact1 %>% rename(medicaid_enrolled1 = medicaid_enrolled), 
            by = c('ma_receipt_num', 'date')) %>%
  left_join(medicaid_enrollment_dates_long_ccbh_daily_transact2 %>% rename(medicaid_enrolled2 = medicaid_enrolled), 
            by = c('ma_receipt_num', 'date')) %>%
  left_join(medicaid_enrollment_dates_long_ccbh_episodes %>% rename(medicaid_enrolled3 = medicaid_enrolled), 
            by = c('ma_receipt_num', 'date')) %>%
  left_join(medicaid_enrollment_dates_long_padhs %>% rename(medicaid_enrolled4 = medicaid_enrolled), 
            by = c('ma_receipt_num', 'date')) %>%
  mutate_at(vars(medicaid_enrolled1, medicaid_enrolled2, medicaid_enrolled3, medicaid_enrolled4), ~ replace_na(., 0)) %>%

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Examine the concordance between the 4 sources of Medicaid enrollment dates

#----------------------------------------------------------------------------
# Calc the percentages of agreement and disagreement
  
  mutate(sources_agree_1v2 = ifelse(medicaid_enrolled1 == 0 & medicaid_enrolled2 == 0, 1, 
                             ifelse(medicaid_enrolled1 == 1 & medicaid_enrolled2 == 1, 1, 
                             0)), 
         source1_yes_source2_no = ifelse(medicaid_enrolled1 == 1 & medicaid_enrolled2 == 0, 1, 0), 
         source1_no_source2_yes = ifelse(medicaid_enrolled1 == 0 & medicaid_enrolled2 == 1, 1, 0), 
         
         sources_agree_1v3 = ifelse(medicaid_enrolled1 == 0 & medicaid_enrolled3 == 0, 1, 
                             ifelse(medicaid_enrolled1 == 1 & medicaid_enrolled3 == 1, 1, 
                             0)), 
         source1_yes_source3_no = ifelse(medicaid_enrolled1 == 1 & medicaid_enrolled3 == 0, 1, 0), 
         source1_no_source3_yes = ifelse(medicaid_enrolled1 == 0 & medicaid_enrolled3 == 1, 1, 0),         
         
         sources_agree_1v4 = ifelse(medicaid_enrolled1 == 0 & medicaid_enrolled4 == 0, 1, 
                             ifelse(medicaid_enrolled1 == 1 & medicaid_enrolled4 == 1, 1, 
                             0)),
         source1_yes_source4_no = ifelse(medicaid_enrolled1 == 1 & medicaid_enrolled4 == 0, 1, 0), 
         source1_no_source4_yes = ifelse(medicaid_enrolled1 == 0 & medicaid_enrolled4 == 1, 1, 0),         
         
         sources_agree_2v3 = ifelse(medicaid_enrolled2 == 0 & medicaid_enrolled3 == 0, 1, 
                             ifelse(medicaid_enrolled2 == 1 & medicaid_enrolled3 == 1, 1, 
                             0)), 
         source2_yes_source3_no = ifelse(medicaid_enrolled2 == 1 & medicaid_enrolled3 == 0, 1, 0), 
         source2_no_source3_yes = ifelse(medicaid_enrolled2 == 0 & medicaid_enrolled3 == 1, 1, 0),         
         
         sources_agree_2v4 = ifelse(medicaid_enrolled2 == 0 & medicaid_enrolled4 == 0, 1, 
                             ifelse(medicaid_enrolled2 == 1 & medicaid_enrolled4 == 1, 1, 
                             0)), 
         source2_yes_source4_no = ifelse(medicaid_enrolled2 == 1 & medicaid_enrolled4 == 0, 1, 0), 
         source2_no_source4_yes = ifelse(medicaid_enrolled2 == 0 & medicaid_enrolled4 == 1, 1, 0),        
         
         sources_agree_3v4 = ifelse(medicaid_enrolled3 == 0 & medicaid_enrolled4 == 0, 1, 
                             ifelse(medicaid_enrolled3 == 1 & medicaid_enrolled4 == 1, 1, 
                             0)),
         source3_yes_source4_no = ifelse(medicaid_enrolled3 == 1 & medicaid_enrolled4 == 0, 1, 0), 
         source3_no_source4_yes = ifelse(medicaid_enrolled3 == 0 & medicaid_enrolled4 == 1, 1, 0)) %>%
  summarise_at(vars(sources_agree_1v2, source1_yes_source2_no, source1_no_source2_yes, sources_agree_1v3, source1_yes_source3_no, source1_no_source3_yes, sources_agree_1v4, source1_yes_source4_no, source1_no_source4_yes, sources_agree_2v3, source2_yes_source3_no, source2_no_source3_yes, sources_agree_2v4, source2_yes_source4_no, source2_no_source4_yes, sources_agree_3v4, source3_yes_source4_no, source3_no_source4_yes), ~ mean(.)) 

#----------------------------------------------------------------------------
# Graph the results

mytheme <-   theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        plot.title = element_text(size = 7), 
        axis.title = element_text(size = 9),
        axis.text.x = element_blank(),
        legend.position = 'none',
        legend.box.just = "left",
        legend.justification = "left",
        legend.margin = margin(t = 10, r = 0, b = 0, l = 0),
        axis.text = element_text(size = 8),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank()) 

plot1 <- dt %>%
  select(sources_agree_1v2, source1_yes_source2_no, source1_no_source2_yes) %>%
  gather(concordance_measure, rate) %>%
  mutate(concordance_measure = ifelse(concordance_measure == 'sources_agree_1v2', 'Sources agree', 
                               ifelse(concordance_measure == 'source1_yes_source2_no', 'Enrolled according to 1, not 2', 
                               'Enrolled according to 2, not 1')), 
         concordance_measure = factor(concordance_measure, levels = c('Sources agree', 'Enrolled according to 1, not 2', 'Enrolled according to 2, not 1'))) %>%
  ggplot(aes(x = concordance_measure, y = rate, fill = concordance_measure)) +
  geom_bar(stat = "identity", colour = 'black', position = position_dodge(width = 0.9), width = 0.8) + 
  geom_text(aes(label = scales::percent(rate, accuracy = 0.1)), position = position_dodge(width = 0.9), hjust = 0.5, vjust = -1.1, size = 3) +
  scale_y_continuous(breaks = seq(0, 1, .2),
                     limits = c(0, 1), 
                     labels = scales::percent_format(accuracy = 1)) +  
  labs(x = " ", 
       y = " ",
       title = "'MA' dates (1) versus 'BH' dates (2)\nin PA_CLIENT_ELIG_DAILY") +
  theme_bw() +
  mytheme + 
  scale_fill_manual(values=c('#004C99', '#606060', '#D55353')) 

plot2 <- dt %>%
  select(sources_agree_1v3, source1_yes_source3_no, source1_no_source3_yes) %>%
  gather(concordance_measure, rate) %>%
  mutate(concordance_measure = ifelse(concordance_measure == 'sources_agree_1v3', 'Sources agree', 
                               ifelse(concordance_measure == 'source1_yes_source3_no', 'Enrolled according to 1, not 2', 
                               'Enrolled according to 2, not 1')), 
         concordance_measure = factor(concordance_measure, levels = c('Sources agree', 'Enrolled according to 1, not 2', 'Enrolled according to 2, not 1'))) %>%
  ggplot(aes(x = concordance_measure, y = rate, fill = concordance_measure)) +
  geom_bar(stat = "identity", colour = 'black', position = position_dodge(width = 0.9), width = 0.8) + 
  geom_text(aes(label = scales::percent(rate, accuracy = 0.1)), position = position_dodge(width = 0.9), hjust = 0.5, vjust = -1.1, size = 3) +
  scale_y_continuous(breaks = seq(0, 1, .2),
                     limits = c(0, 1), 
                     labels = scales::percent_format(accuracy = 1)) +  
  labs(x = " ", 
       y = " ",
       title = "'MA' dates in PA_CLIENT_ELIG_DAILY (1) vs. dates\nin CCBH_HC_ELIGIBILITY (2)") +
  theme_bw() +
  mytheme + 
  scale_fill_manual(values=c('#004C99', '#606060', '#D55353')) 

plot3 <- dt %>%
  select(sources_agree_1v4, source1_yes_source4_no, source1_no_source4_yes) %>%
  gather(concordance_measure, rate) %>%
  mutate(concordance_measure = ifelse(concordance_measure == 'sources_agree_1v4', 'Sources agree', 
                               ifelse(concordance_measure == 'source1_yes_source4_no', 'Enrolled according to 1, not 2', 
                               'Enrolled according to 2, not 1')), 
         concordance_measure = factor(concordance_measure, levels = c('Sources agree', 'Enrolled according to 1, not 2', 'Enrolled according to 2, not 1'))) %>%
  ggplot(aes(x = concordance_measure, y = rate, fill = concordance_measure)) +
  geom_bar(stat = "identity", colour = 'black', position = position_dodge(width = 0.9), width = 0.8) + 
  geom_text(aes(label = scales::percent(rate, accuracy = 0.1)), position = position_dodge(width = 0.9), hjust = 0.5, vjust = -1.1, size = 3) +
  scale_y_continuous(breaks = seq(0, 1, .2),
                     limits = c(0, 1), 
                     labels = scales::percent_format(accuracy = 1)) +  
  labs(x = " ", 
       y = " ",
       title = "'MA' dates in PA_CLIENT_ELIG_DAILY (1) vs. dates\nin AC_PADHS.ELIGIBILITY (2)") +
  theme_bw() +
  mytheme + 
  scale_fill_manual(values=c('#004C99', '#606060', '#D55353')) 

plot4 <- dt %>%
  select(sources_agree_2v3, source2_yes_source3_no, source2_no_source3_yes) %>%
  gather(concordance_measure, rate) %>%
  mutate(concordance_measure = ifelse(concordance_measure == 'sources_agree_2v3', 'Sources agree', 
                               ifelse(concordance_measure == 'source2_yes_source3_no', 'Enrolled according to 1, not 2', 
                               'Enrolled according to 2, not 1')), 
         concordance_measure = factor(concordance_measure, levels = c('Sources agree', 'Enrolled according to 1, not 2', 'Enrolled according to 2, not 1'))) %>%
  ggplot(aes(x = concordance_measure, y = rate, fill = concordance_measure)) +
  geom_bar(stat = "identity", colour = 'black', position = position_dodge(width = 0.9), width = 0.8) + 
  geom_text(aes(label = scales::percent(rate, accuracy = 0.1)), position = position_dodge(width = 0.9), hjust = 0.5, vjust = -1.1, size = 3) +
  scale_y_continuous(breaks = seq(0, 1, .2),
                     limits = c(0, 1), 
                     labels = scales::percent_format(accuracy = 1)) +  
  labs(x = " ", 
       y = " ",
       title = "'BH' dates in PA_CLIENT_ELIG_DAILY (1) vs. dates\nin CCBH_HC_ELIGIBILITY (2)") +
  theme_bw() +
  mytheme + 
  scale_fill_manual(values=c('#004C99', '#606060', '#D55353')) 

plot5 <- dt %>%
  select(sources_agree_2v4, source2_yes_source4_no, source2_no_source4_yes) %>%
  gather(concordance_measure, rate) %>%
  mutate(concordance_measure = ifelse(concordance_measure == 'sources_agree_2v4', 'Sources agree', 
                               ifelse(concordance_measure == 'source2_yes_source4_no', 'Enrolled according to 1, not 2', 
                               'Enrolled according to 2, not 1')), 
         concordance_measure = factor(concordance_measure, levels = c('Sources agree', 'Enrolled according to 1, not 2', 'Enrolled according to 2, not 1'))) %>%
  ggplot(aes(x = concordance_measure, y = rate, fill = concordance_measure)) +
  geom_bar(stat = "identity", colour = 'black', position = position_dodge(width = 0.9), width = 0.8) + 
  geom_text(aes(label = scales::percent(rate, accuracy = 0.1)), position = position_dodge(width = 0.9), hjust = 0.5, vjust = -1.1, size = 3) +
  scale_y_continuous(breaks = seq(0, 1, .2),
                     limits = c(0, 1), 
                     labels = scales::percent_format(accuracy = 1)) +  
  labs(x = " ", 
       y = " ",
       title = "'BH' dates in PA_CLIENT_ELIG_DAILY (1) vs. dates\nin AC_PADHS.ELIGIBILITY (2)") +
  theme_bw() +
  mytheme + 
  scale_fill_manual(values=c('#004C99', '#606060', '#D55353')) 

plot6 <- dt %>%
  select(sources_agree_3v4, source3_yes_source4_no, source3_no_source4_yes) %>%
  gather(concordance_measure, rate) %>%
  mutate(concordance_measure = ifelse(concordance_measure == 'sources_agree_3v4', 'Sources agree', 
                               ifelse(concordance_measure == 'source3_yes_source4_no', 'Enrolled according to 1, not 2', 
                               'Enrolled according to 2, not 1')), 
         concordance_measure = factor(concordance_measure, levels = c('Sources agree', 'Enrolled according to 1, not 2', 'Enrolled according to 2, not 1'))) %>%
  ggplot(aes(x = concordance_measure, y = rate, fill = concordance_measure)) +
  geom_bar(stat = "identity", colour = 'black', position = position_dodge(width = 0.9), width = 0.8) + 
  geom_text(aes(label = scales::percent(rate, accuracy = 0.1)), position = position_dodge(width = 0.9), hjust = 0.5, vjust = -1.1, size = 3) +
  scale_y_continuous(breaks = seq(0, 1, .2),
                     limits = c(0, 1), 
                     labels = scales::percent_format(accuracy = 1)) +  
  labs(x = " ", 
       y = " ",
       title = "Dates in CCBH_HC_ELIGIBILITY (1) vs. dates\nin AC_PADHS.ELIGIBILITY (2)") +
  theme_bw() +
  mytheme + 
  scale_fill_manual(values=c('#004C99', '#606060', '#D55353')) 

# Plot all graphs in panel

chart_panel <- plot_grid(plot1, plot2, plot3, plot4, plot5, plot6, nrow = 3, ncol = 2)

# Create a legend

legend <- get_legend(
  plot1 +
    guides(color = guide_legend(nrow = 1)) +
    theme(legend.position = 'bottom', 
          legend.justification = 'center',
          legend.text = element_text(size = 10),
          legend.title = element_blank()))

plot_grid(chart_panel, legend, ncol = 1, rel_heights = c(1, 0.09))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/medicaid-enrollment-dates-concordance-by-source.png"), 
  plot = last_plot(),
  width = 7,
  height = 9)
```

### Length of time between the person's earliest post-4/1/2023 eligibility recertification deadline and their earliest post-4/1/2023 PD

```{r}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample

load(file = paste0(filepath, "/Data/Sample demographics/base_sample_demographics.rda"))

# Dates of PDs

load(file = paste0(filepath, "/Data/Medicaid enrollment data/procedural_disenrollment_dates.rda"))

# Recertification deadlines

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_recert_deadlines.rda"))

# Earliest post-4/1/2023 PD dates

load(file = paste0(filepath, "/Data/Medicaid enrollment data/earliest_procedural_disenroll_dates.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

#----------------------------------------------------------------------------
# For each client, keep only their recertification deadline that falls closest to their earliest post-4/1/2023 PD date, either before or after this date

# Start with the clients who have a post-4/1/2023 recertification deadline in the CCBH data. There are some who don't but nonetheless have a PD. We will omit these people from this analysis since we don't know when their recert deadline was. 

dt <- base_sample_demographics %>%
  filter(treat == 1) %>%
  select(ma_receipt_num) %>%
  inner_join(medicaid_recert_deadlines, by = c('ma_receipt_num')) %>%
  inner_join(earliest_procedural_disenroll_dates, by = c('ma_receipt_num')) %>%
  
# Calc the number of days between the person's recert deadline and their PD date
  
  mutate(diff = as.numeric(procedural_disenroll_date - recert_deadline), 
         diff_abs = abs(diff)) %>%
  
# Keep only the recert deadlines that fall closest to the person's disenrollment date
  
  group_by(ma_receipt_num) %>%
  top_n(-1, diff_abs) %>%
  ungroup() 
  
# See if there are any clients with multiple recert deadlines that are tied for closest to their disenrollment date. 
  
dedups <- dt %>%
  group_by(ma_receipt_num) %>%
  mutate(count = n()) %>%
  ungroup() %>%
  filter(count > 1) %>%
  
# Result: There are a small handful. For these cases, keep their recert deadline that is before (instead of after) their disenrollment date
  
  filter(diff <= 0) %>%
  select(-count)

dt <- dt %>%
  bind_rows(dedups) %>%

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create graphs

#----------------------------------------------------------------------------
# Distribution of the number of days before or after the person's recertification deadline that their PD took places

# Create binned counts

  mutate(bin = ifelse(diff >= -100 & diff <= 100, cut(diff, breaks = seq(-100, 100, 5), right = TRUE, labels = FALSE), NA), 
         bin = bin + 1, 
         bin = ifelse(diff <= -100, 1, 
               ifelse(diff >= 100, 42, 
               bin))) %>%
  group_by(bin) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  mutate(pct_of_total = count / sum(count))

# Plot the figure

dt %>%
  ggplot(aes(x = bin, y = pct_of_total)) +
  geom_bar(stat = "identity", position = position_nudge(x = -.5), colour = 'black') + 
  scale_y_continuous(breaks = seq(0, 0.1, .01),
                     limits = c(0, 0.1), 
                     labels = scales::percent_format(accuracy = 1)) +  
  scale_x_continuous(breaks = seq(0, 42, 1), 
                    limits = c(0, 42),
                   labels = c(' ','-100+', ' ', '-90', ' ', '-80', ' ', '-70', ' ', '-60', ' ', '-50', ' ', '-40', ' ', '-30', ' ', '-20', ' ', '-10', ' ', '0', ' ', '10', ' ', '20', ' ', '30', ' ', '40', ' ', '50', ' ', '60', ' ', '70', ' ', '80', ' ', '90', ' ', '100+', ' ')) +
  labs(x = "Days (N)", y = "Pct of PD sample", title = "Number of days between person's post-4/1/2023 recertification deadline\nand their PD event") +
  theme_bw() +
  theme(legend.title = element_blank(),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(), 
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/days-between-recert-deadline-and-procedural-disenrollment.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)
```

### Timing of PDs during the pandemic freeze

```{r}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Dates of PDs

load(file = paste0(filepath, "/Data/Medicaid enrollment data/procedural_disenrollment_dates.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

# Keep only the PDs that happened between 4/1/2020 and 4/1/2023. There shouldn't be any b/c everyone was frozen on Medicaid at that time. 

dt <- procedural_disenrollment_dates %>%
  filter(procedural_disenroll_date < as.Date('2023-04-01')) %>%

# Count the number of disenrollments by month

  mutate(procedural_disenroll_month = format(procedural_disenroll_date, '%m-%Y'), 
         procedural_disenroll_month = factor(procedural_disenroll_month, levels = c("09-2022", "10-2022", "11-2022", "12-2022", "01-2023", "02-2023", "03-2023"))) %>%
  group_by(procedural_disenroll_month) %>%
  summarise(count = n()) %>%
  ungroup()

# Graph the distribution by month

dt %>%
  ggplot(aes(x = procedural_disenroll_month, y = count)) +
  geom_bar(stat = "identity", colour = 'black') + 
  scale_y_continuous(breaks = seq(0, 50, 5),
                     limits = c(0, 50)) +  
  # scale_x_continuous(breaks = seq(0, 42, 1), 
  #                   limits = c(0, 42),
  #                  labels = c(' ','-100+', ' ', '-90', ' ', '-80', ' ', '-70', ' ', '-60', ' ', '-50', ' ', '-40', ' ', '-30', ' ', '-20', ' ', '-10', ' ', '0', ' ', '10', ' ', '20', ' ', '30', ' ', '40', ' ', '50', ' ', '60', ' ', '70', ' ', '80', ' ', '90', ' ', '100+', ' ')) +
  labs(x = "Month-year", y = "PDs (N)", title = "Number of procedural Medicaid disenrollments by month") +
  theme_bw() +
  theme(legend.title = element_blank(),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(), 
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/medicaid-proc-disenrolls-by-month-during-covid.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)
```

## Employment outcomes

### Availability of UI data 

#### For entire base sample

```{r}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample 

load(file = paste0(filepath, "/Data/Sample demographics/base_sample_demographics.rda"))

# Dates of PDs

load(file = paste0(filepath, "/Data/Medicaid enrollment data/procedural_disenrollment_dates.rda"))

# UI earnings data for the sample

load(file = paste0(filepath, "/Data/PA unemployment insurance data/ui_earnings.rda"))

# Earliest post-4/1/2023 PD dates

load(file = paste0(filepath, "/Data/Medicaid enrollment data/earliest_procedural_disenroll_dates.rda"))

# Medicaid enrollment episode dates - CCBH version

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_ccbh_episodes.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

# Isolate the sample for this analysis. It's everyone who was enrolled in Medicaid as of 4/1/2023 and was 25 to 60 years old at that time. 

analytic_sample <- earliest_procedural_disenroll_dates %>%
  right_join(base_sample_demographics, by = c('ma_receipt_num')) %>%
  mutate(age_asof_04012023 = trunc((dob %--% as.Date('2023-04-01')) / years(1))) %>%
  filter(age_asof_04012023 >= 25 & age_asof_04012023 <= 60) %>%
  
# Calc the calendar quarter of each person's disenrollment date, for those who have one
  
  mutate(disenrollment_quarter = ifelse(is.na(procedural_disenroll_date), NA, str_remove(paste0(year(procedural_disenroll_date), quarters(procedural_disenroll_date)), "Q"))) %>%
    distinct(ma_receipt_num, treat, disenrollment_quarter) 

# Pull in the distinct quarters for which each person has UI data. Keep only the UI data from Q1 2020 to Q2 2024. I don't really care about having UI data further back than Q1 2020 for now
  
dt <- analytic_sample %>%
  inner_join(ui_earnings %>%
            distinct(ma_receipt_num, quarter) %>%
            filter(quarter %in% c('20201', '20202', '20203', '20204', '20211', '20212', '20213', '20214', '20221', '20222', '20223', '20224', '20231', '20232', '20233', '20234', '20241', '20242')), 
            by = c('ma_receipt_num')) %>%
  mutate(has_ui_data = 1) %>%
  
# Join the data with a grid of calendar quarters from Q1 2020 to Q2 2024 for each client

  right_join(test <- analytic_sample %>%
             group_by(ma_receipt_num, treat, disenrollment_quarter) %>%
             reframe(quarter = c('20201', '20202', '20203', '20204', '20211', '20212', '20213', '20214', '20221', '20222', '20223', '20224', '20231', '20232', '20233', '20234', '20241', '20242')) %>%
             ungroup(), 
             by = c('ma_receipt_num', 'treat', 'disenrollment_quarter', 'quarter')) %>%
  mutate(has_ui_data = replace_na(has_ui_data, 0)) 
  
#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create graphs of the percentage of all working-age base sample members with non-missing UI data

#----------------------------------------------------------------------------
# Only using T group members whose PD was in Q2 2023

# Keep all the C group members and only the T group members whose PD was in Q2 2023

dt %>%
  filter(is.na(disenrollment_quarter) | disenrollment_quarter == '20232') %>%

# Calc the percentages of the T and C groups that have non-missing UI data for each quarter

  group_by(treat, quarter) %>%
  summarise(pct_has_ui_data = mean(has_ui_data)) %>%
  ungroup() %>%
  
# Rename the treatment var for graphing
  
  mutate(treat = ifelse(treat == 0, "Has not had PD since end of PHE", "Had PD in Q2 2023")) %>%

# Create the graph

  ggplot(mapping = aes(x = quarter, y = pct_has_ui_data, colour = treat, group = treat)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = '20232'), color = "red", linetype = "dashed") + 
  theme_bw() +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  scale_x_discrete(labels = c('Q1 2020', ' ', 'Q3 2020', ' ', 'Q1 2021', ' ', 'Q3 2021', ' ', 'Q1 2022', ' ', 'Q3 2022', ' ', 'Q1 2023', ' ', 'Q3 2023', ' ', 'Q1 2024', ' ')) +
  labs(x = "Calendar quarter", y = "Pct of cohort with UI data", title = "Percentage of working-age sample with non-missing UI data,\nQ2 2023 PD cohort (N = 4,209) versus non-PD cohort (N = 93,710)") +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.title = element_text(size = 10),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/ui-data-availability-q22023-full-sample.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)

#----------------------------------------------------------------------------
# Only using T group members whose PD was in Q3 2023

# Keep all the C group members and only the T group members whose PD was in Q3 2023

dt %>%
  filter(is.na(disenrollment_quarter) | disenrollment_quarter == '20233') %>%

# Calc the percentages of the T and C groups that have non-missing UI data for each quarter

  group_by(treat, quarter) %>%
  summarise(pct_has_ui_data = mean(has_ui_data)) %>%
  ungroup() %>%
  
# Rename the treatment var for graphing
  
  mutate(treat = ifelse(treat == 0, "Has not had PD since end of PHE", "Had PD in Q3 2023")) %>%

# Create the graph

  ggplot(mapping = aes(x = quarter, y = pct_has_ui_data, colour = treat, group = treat)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = '20233'), color = "red", linetype = "dashed") + 
  theme_bw() +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  scale_x_discrete(labels = c('Q1 2020', ' ', 'Q3 2020', ' ', 'Q1 2021', ' ', 'Q3 2021', ' ', 'Q1 2022', ' ', 'Q3 2022', ' ', 'Q1 2023', ' ', 'Q3 2023', ' ', 'Q1 2024', ' ')) +
  labs(x = "Calendar quarter", y = "Pct of cohort with UI data", title = "Percentage of working-age sample with non-missing UI data,\nQ3 2023 PD cohort (N = 5,761) versus non-PD cohort (N = 93,710)") +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.title = element_text(size = 10),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/ui-data-availability-q32023-full-sample.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)

#----------------------------------------------------------------------------
# Only using T group members whose PD was in Q4 2023

# Keep all the C group members and only the T group members whose PD was in Q4 2023

dt %>%
  filter(is.na(disenrollment_quarter) | disenrollment_quarter == '20234') %>%

# Calc the percentages of the T and C groups that have non-missing UI data for each quarter

  group_by(treat, quarter) %>%
  summarise(pct_has_ui_data = mean(has_ui_data)) %>%
  ungroup() %>%
  
# Rename the treatment var for graphing
  
  mutate(treat = ifelse(treat == 0, "Has not had PD since end of PHE", "Had PD in Q4 2023")) %>%

# Create the graph

  ggplot(mapping = aes(x = quarter, y = pct_has_ui_data, colour = treat, group = treat)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = '20234'), color = "red", linetype = "dashed") + 
  theme_bw() +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  scale_x_discrete(labels = c('Q1 2020', ' ', 'Q3 2020', ' ', 'Q1 2021', ' ', 'Q3 2021', ' ', 'Q1 2022', ' ', 'Q3 2022', ' ', 'Q1 2023', ' ', 'Q3 2023', ' ', 'Q1 2024', ' ')) +
  labs(x = "Calendar quarter", y = "Pct of cohort with UI data", title = "Percentage of working-age sample with non-missing UI data,\nQ4 2023 PD cohort (N = 5,790) versus non-PD cohort (N = 93,710)") +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.title = element_text(size = 10),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/ui-data-availability-q42023-full-sample.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)

#----------------------------------------------------------------------------
# Only using T group members whose PD was in Q1 2024

# Keep all the C group members and only the T group members whose PD was in Q1 2024

dt %>%
  filter(is.na(disenrollment_quarter) | disenrollment_quarter == '20241') %>%

# Calc the percentages of the T and C groups that have non-missing UI data for each quarter

  group_by(treat, quarter) %>%
  summarise(pct_has_ui_data = mean(has_ui_data)) %>%
  ungroup() %>%
  
# Rename the treatment var for graphing
  
  mutate(treat = ifelse(treat == 0, "Has not had PD since end of PHE", "Had PD in Q1 2024")) %>%

# Create the graph

  ggplot(mapping = aes(x = quarter, y = pct_has_ui_data, colour = treat, group = treat)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = '20241'), color = "red", linetype = "dashed") + 
  theme_bw() +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  scale_x_discrete(labels = c('Q1 2020', ' ', 'Q3 2020', ' ', 'Q1 2021', ' ', 'Q3 2021', ' ', 'Q1 2022', ' ', 'Q3 2022', ' ', 'Q1 2023', ' ', 'Q3 2023', ' ', 'Q1 2024', ' ')) +
  labs(x = "Calendar quarter", y = "Pct of cohort with UI data", title = "Percentage of working-age sample with non-missing UI data,\nQ1 2024 PD cohort (N = 7,521) versus non-PD cohort (N = 93,710)") +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.title = element_text(size = 10),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/ui-data-availability-q12024-full-sample.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)

#----------------------------------------------------------------------------
# Only using T group members whose PD was in Q2 2024

# Keep all the C group members and only the T group members whose PD was in Q2 2024

dt %>%
  filter(is.na(disenrollment_quarter) | disenrollment_quarter == '20242') %>%

# Calc the percentages of the T and C groups that have non-missing UI data for each quarter

  group_by(treat, quarter) %>%
  summarise(pct_has_ui_data = mean(has_ui_data)) %>%
  ungroup() %>%
  
# Rename the treatment var for graphing
  
  mutate(treat = ifelse(treat == 0, "Has not had PD since end of PHE", "Had PD in Q2 2024")) %>%

# Create the graph

  ggplot(mapping = aes(x = quarter, y = pct_has_ui_data, colour = treat, group = treat)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = '20242'), color = "red", linetype = "dashed") + 
  theme_bw() +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  scale_x_discrete(labels = c('Q1 2020', ' ', 'Q3 2020', ' ', 'Q1 2021', ' ', 'Q3 2021', ' ', 'Q1 2022', ' ', 'Q3 2022', ' ', 'Q1 2023', ' ', 'Q3 2023', ' ', 'Q1 2024', ' ')) +
  labs(x = "Calendar quarter", y = "Pct of cohort with UI data", title = "Percentage of working-age sample with non-missing UI data,\nQ2 2024 PD cohort (N = 4,871) versus non-PD cohort (N = 93,710)") +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.title = element_text(size = 10),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/ui-data-availability-q22024-full-sample.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)
```

#### For people who were enrolled in MAGI Medicaid continuously between 4/1/2020 and 4/1/2023 

```{r}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample 

load(file = paste0(filepath, "/Data/Sample demographics/base_sample_demographics.rda"))

# Dates of PDs

load(file = paste0(filepath, "/Data/Medicaid enrollment data/procedural_disenrollment_dates.rda"))

# UI earnings data for the sample

load(file = paste0(filepath, "/Data/PA unemployment insurance data/ui_earnings.rda"))

# Earliest post-4/1/2023 PD dates

load(file = paste0(filepath, "/Data/Medicaid enrollment data/earliest_procedural_disenroll_dates.rda"))

# Medicaid enrollment episode dates - CCBH version

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_ccbh_episodes.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

#----------------------------------------------------------------------------
# Isolate the sample members who were enrolled in MAGI Medicaid continuously between 4/1/2020 and 4/1/2023 

analytic_sample <- base_sample_demographics %>%
  inner_join(medicaid_enrollment_dates_ccbh_episodes, by = c('ma_receipt_num')) %>%
  filter(category %in% c('MG') & program_status %in% c('91')) %>%
  
# Remove obs in which the start date of the enrollment episode is after 4/1/2023
  
  filter(elig_from_date <= as.Date('2023-04-01')) %>%
  
# Recode missing values of the enrollment episode end date as 4/1/2023, as well as values that are after 4/1/2023
  
  mutate(elig_to_date = replace_na(elig_to_date, as.Date('2023-04-01')), 
         elig_to_date = if_else(elig_to_date > as.Date('2023-04-01'), as.Date('2023-04-01'), elig_to_date)) %>%
  
# Remove obs where the episode end date was before 4/1/2020
  
  filter(elig_to_date >= as.Date('2020-04-01')) %>%
  
# Recode any episode start dates as 4/1/2020 if they are before 4/1/2020
  
  mutate(elig_from_date = if_else(elig_from_date < as.Date('2020-04-01'), as.Date('2020-04-01'), elig_from_date)) %>%
  
# Reshape the data to have 1 obs for each day during each enrollment episode
  
  group_by(ma_receipt_num, elig_from_date, elig_to_date) %>%
  reframe(date = list(seq.Date(from = elig_from_date,
                               to = elig_to_date,
                               by = "day"))) %>%
  unnest(date) %>%
  ungroup() %>%
  distinct(ma_receipt_num, date) %>%
  mutate(medicaid_enrolled = 1) %>%
  
# Drop the clients who have less than 1095 obs in this data frame. That means they did not have continuous Medicaid coverage between 4/1/2020 and 4/1/2023 (which is a 1095-day period)
  
  group_by(ma_receipt_num) %>%
  summarise(day_count = n()) %>%
  ungroup() %>%
  filter(day_count >= 1095) %>%
  select(ma_receipt_num) %>%

# Keep only the sample members who were 25 to 60 years old as of 4/1/2023

  inner_join(base_sample_demographics, by = c('ma_receipt_num')) %>%
  mutate(age_asof_04012023 = trunc((dob %--% as.Date('2023-04-01')) / years(1))) %>%
  filter(age_asof_04012023 >= 25 & age_asof_04012023 <= 60) %>%
  
# Calc the calendar quarter of each person's disenrollment date, for those who have one
  
  left_join(earliest_procedural_disenroll_dates, by = c('ma_receipt_num')) %>%
  mutate(disenrollment_quarter = ifelse(is.na(procedural_disenroll_date), NA, str_remove(paste0(year(procedural_disenroll_date), quarters(procedural_disenroll_date)), "Q"))) %>%
    distinct(ma_receipt_num, treat, disenrollment_quarter) 
  
# Pull in the distinct quarters for which each person has UI data. Keep only the UI data from Q1 2020 to Q2 2024. I don't really care about having UI data further back than Q1 2020 for now
  
dt <- analytic_sample %>%
  inner_join(ui_earnings %>%
            distinct(ma_receipt_num, quarter) %>%
            filter(quarter %in% c('20201', '20202', '20203', '20204', '20211', '20212', '20213', '20214', '20221', '20222', '20223', '20224', '20231', '20232', '20233', '20234', '20241', '20242')), 
            by = c('ma_receipt_num')) %>%
  mutate(has_ui_data = 1) %>%
  
# Join the data with a grid of calendar quarters from Q1 2020 to Q2 2024 for each client

  right_join(analytic_sample %>%
             group_by(ma_receipt_num, treat) %>%
             reframe(quarter = c('20201', '20202', '20203', '20204', '20211', '20212', '20213', '20214', '20221', '20222', '20223', '20224', '20231', '20232', '20233', '20234', '20241', '20242')) %>%
             ungroup(), 
             by = c('ma_receipt_num', 'treat', 'quarter')) %>%
  mutate(has_ui_data = replace_na(has_ui_data, 0)) 
  
#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create graphs of the percentage of all working-age continuous MAGI-enrolled base sample members with non-missing UI data

#----------------------------------------------------------------------------
# Only using T group members whose PD was in Q2 2023

# Keep all the C group members and only the T group members whose PD was in Q2 2023

dt %>%
  filter(is.na(disenrollment_quarter) | disenrollment_quarter == '20232') %>%

# Calc the percentages of the T and C groups that have non-missing UI data for each quarter

  group_by(treat, quarter) %>%
  summarise(pct_has_ui_data = mean(has_ui_data)) %>%
  ungroup() %>%
  
# Rename the treatment var for graphing
  
  mutate(treat = ifelse(treat == 0, "Has not had PD since end of PHE", "Had PD in Q2 2023")) %>%

# Create the graph

  ggplot(mapping = aes(x = quarter, y = pct_has_ui_data, colour = treat, group = treat)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = '20232'), color = "red", linetype = "dashed") + 
  theme_bw() +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  scale_x_discrete(labels = c('Q1 2020', ' ', 'Q3 2020', ' ', 'Q1 2021', ' ', 'Q3 2021', ' ', 'Q1 2022', ' ', 'Q3 2022', ' ', 'Q1 2023', ' ', 'Q3 2023', ' ', 'Q1 2024', ' ')) +
  labs(x = "Calendar quarter", y = "Pct of cohort with UI data", title = "Percentage of working-age sample with non-missing UI data,\nQ2 2023 PD cohort (N = 1,074) versus non-PD cohort (N = 20,552)") +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.title = element_text(size = 10),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/ui-data-availability-q22023-magi-continuously-enrolled.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)

#----------------------------------------------------------------------------
# Only using T group members whose PD was in Q3 2023

# Keep all the C group members and only the T group members whose PD was in Q3 2023

dt %>%
  filter(is.na(disenrollment_quarter) | disenrollment_quarter == '20233') %>%

# Calc the percentages of the T and C groups that have non-missing UI data for each quarter

  group_by(treat, quarter) %>%
  summarise(pct_has_ui_data = mean(has_ui_data)) %>%
  ungroup() %>%
  
# Rename the treatment var for graphing
  
  mutate(treat = ifelse(treat == 0, "Has not had PD since end of PHE", "Had PD in Q3 2023")) %>%

# Create the graph

  ggplot(mapping = aes(x = quarter, y = pct_has_ui_data, colour = treat, group = treat)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = '20233'), color = "red", linetype = "dashed") + 
  theme_bw() +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  scale_x_discrete(labels = c('Q1 2020', ' ', 'Q3 2020', ' ', 'Q1 2021', ' ', 'Q3 2021', ' ', 'Q1 2022', ' ', 'Q3 2022', ' ', 'Q1 2023', ' ', 'Q3 2023', ' ', 'Q1 2024', ' ')) +
  labs(x = "Calendar quarter", y = "Pct of cohort with UI data", title = "Percentage of working-age sample with non-missing UI data,\nQ3 2023 PD cohort (N = 1,560) versus non-PD cohort (N = 20,552)") +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.title = element_text(size = 10),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/ui-data-availability-q32023-magi-continuously-enrolled.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)

#----------------------------------------------------------------------------
# Only using T group members whose PD was in Q4 2023

# Keep all the C group members and only the T group members whose PD was in Q4 2023

dt %>%
  filter(is.na(disenrollment_quarter) | disenrollment_quarter == '20234') %>%

# Calc the percentages of the T and C groups that have non-missing UI data for each quarter

  group_by(treat, quarter) %>%
  summarise(pct_has_ui_data = mean(has_ui_data)) %>%
  ungroup() %>%
  
# Rename the treatment var for graphing
  
  mutate(treat = ifelse(treat == 0, "Has not had PD since end of PHE", "Had PD in Q4 2023")) %>%

# Create the graph

  ggplot(mapping = aes(x = quarter, y = pct_has_ui_data, colour = treat, group = treat)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = '20234'), color = "red", linetype = "dashed") + 
  theme_bw() +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  scale_x_discrete(labels = c('Q1 2020', ' ', 'Q3 2020', ' ', 'Q1 2021', ' ', 'Q3 2021', ' ', 'Q1 2022', ' ', 'Q3 2022', ' ', 'Q1 2023', ' ', 'Q3 2023', ' ', 'Q1 2024', ' ')) +
  labs(x = "Calendar quarter", y = "Pct of cohort with UI data", title = "Percentage of working-age sample with non-missing UI data,\nQ4 2023 PD cohort (N = 1,910) versus non-PD cohort (N = 20,552)") +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.title = element_text(size = 10),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/ui-data-availability-q42023-magi-continuously-enrolled.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)

#----------------------------------------------------------------------------
# Only using T group members whose PD was in Q1 2024

# Keep all the C group members and only the T group members whose PD was in Q1 2024

dt %>%
  filter(is.na(disenrollment_quarter) | disenrollment_quarter == '20241') %>%

# Calc the percentages of the T and C groups that have non-missing UI data for each quarter

  group_by(treat, quarter) %>%
  summarise(pct_has_ui_data = mean(has_ui_data)) %>%
  ungroup() %>%
  
# Rename the treatment var for graphing
  
  mutate(treat = ifelse(treat == 0, "Has not had PD since end of PHE", "Had PD in Q1 2024")) %>%

# Create the graph

  ggplot(mapping = aes(x = quarter, y = pct_has_ui_data, colour = treat, group = treat)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = '20241'), color = "red", linetype = "dashed") + 
  theme_bw() +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  scale_x_discrete(labels = c('Q1 2020', ' ', 'Q3 2020', ' ', 'Q1 2021', ' ', 'Q3 2021', ' ', 'Q1 2022', ' ', 'Q3 2022', ' ', 'Q1 2023', ' ', 'Q3 2023', ' ', 'Q1 2024', ' ')) +
  labs(x = "Calendar quarter", y = "Pct of cohort with UI data", title = "Percentage of working-age sample with non-missing UI data,\nQ1 2024 PD cohort (N = 2,416) versus non-PD cohort (N = 20,552)") +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.title = element_text(size = 10),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/ui-data-availability-q12024-magi-continuously-enrolled.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)

#----------------------------------------------------------------------------
# Only using T group members whose PD was in Q2 2024

# Keep all the C group members and only the T group members whose PD was in Q2 2024

dt %>%
  filter(is.na(disenrollment_quarter) | disenrollment_quarter == '20242') %>%

# Calc the percentages of the T and C groups that have non-missing UI data for each quarter

  group_by(treat, quarter) %>%
  summarise(pct_has_ui_data = mean(has_ui_data)) %>%
  ungroup() %>%
  
# Rename the treatment var for graphing
  
  mutate(treat = ifelse(treat == 0, "Has not had PD since end of PHE", "Had PD in Q2 2024")) %>%

# Create the graph

  ggplot(mapping = aes(x = quarter, y = pct_has_ui_data, colour = treat, group = treat)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = '20242'), color = "red", linetype = "dashed") + 
  theme_bw() +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  scale_x_discrete(labels = c('Q1 2020', ' ', 'Q3 2020', ' ', 'Q1 2021', ' ', 'Q3 2021', ' ', 'Q1 2022', ' ', 'Q3 2022', ' ', 'Q1 2023', ' ', 'Q3 2023', ' ', 'Q1 2024', ' ')) +
  labs(x = "Calendar quarter", y = "Pct of cohort with UI data", title = "Percentage of working-age sample with non-missing UI data,\nQ2 2024 PD cohort (N = 1,330) versus non-PD cohort (N = 20,552)") +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.title = element_text(size = 10),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/ui-data-availability-q22024-magi-continuously-enrolled.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)
```

### Employment outcomes by quarter relative to quarter of first post-4/1/2023 recertification deadline, only among the group that experienced a post-4/1/2023 PD from Medicaid

```{r}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample 

load(file = paste0(filepath, "/Data/Sample demographics/base_sample_demographics.rda"))

# UI earnings data for the sample

load(file = paste0(filepath, "/Data/PA unemployment insurance data/ui_earnings.rda"))

# Recertification deadlines

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_recert_deadlines.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

# Identify each sample member's earliest post-4/1/2023 Medicaid recertification deadline

analytic_sample <- medicaid_recert_deadlines %>%
  filter(recert_deadline >= as.Date('2023-04-01')) %>%
  group_by(ma_receipt_num) %>%
  top_n(-1, recert_deadline) %>%
  ungroup() %>% 
  
# Remove the sample members who did not have a Medicaid recertification deadline in 2023 or 2024. (Figure out why these people did not have a recertification deadline in these years; I thought everyone was supposed to have one)
  
  filter(recert_deadline <= as.Date('2024-12-31')) %>%

# Keep only the sample members who experienced a PD after 4/1/2023

  inner_join(base_sample_demographics %>% 
             filter(treat == 1) %>%
             select(ma_receipt_num, treat, dob), 
             by = c('ma_receipt_num')) %>%
  
# Keep only the sample members who were between 25 and 60 as of their earliest post-4/1/2023 recertification deadline. I plan to look at their earnings from roughly +/- 3 years from their recertification deadline, so this rule will roughly ensure that everyone in the analysis is of working age
  
  mutate(age = trunc((dob %--% recert_deadline) / years(1))) %>%
  filter(age >= 25 & age <= 60) %>%
  
# Calc the quarter of the person's recertification deadline
  
  mutate(recert_deadline_quarter = str_remove(paste0(year(recert_deadline), quarters(recert_deadline)), "Q")) 

# Calc each sample member's total UI earnings by quarter, and their quarterly employment status

dt <- ui_earnings %>%
  inner_join(analytic_sample, by = c('ma_receipt_num')) %>%
  group_by(ma_receipt_num, recert_deadline_quarter, quarter) %>%
  summarise(ui_earnings = sum(ui_earnings)) %>%
  ungroup() %>%
  mutate(ui_employed = ifelse(ui_earnings > 0, 1, 0),

# Calc the number of quarters since the person's quarter of recert deadline. Keep only values of -12 to 4. I don't really care about having UI data from more than 12 quarters prior to recert deadline, and we only have a maximum of 4 quarters' worth of post-deadline UI data available right now
  
        tau = quarter_diff(recert_deadline_quarter, quarter)) %>%
  filter(tau >= -12 & tau <= 4) %>%
  
# Calc the sample mean earnings in each quarter
  
  group_by(tau) %>%
  summarise(mean_earnings = mean(ui_earnings), 
            mean_employed = mean(ui_employed)) %>%
  ungroup()

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create graphs

#----------------------------------------------------------------------------
# Mean earnings by quarter relative to quarter of recert deadline

dt %>%
  ggplot(mapping = aes(x = tau, y = mean_earnings)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = 0), color = "red", linetype = "dashed") + 
  theme_bw() +
  scale_y_continuous(breaks = seq(0,7000,1000),
                     limits = c(0,7000),
                     labels = scales::dollar_format(accuracy = 1)) +
  scale_x_continuous(breaks = seq(-12,4,1), 
                     limits = c(-12,4)) +
  labs(x = "Quarters since post-PHE recert deadline", y = "Mean earnings ($)", title = "Mean UI earnings by quarter since post-PHE recertification deadline,\namong working-age PD sample (N = 31,162)") +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/earnings-over-time-since-recert-deadline.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)

#----------------------------------------------------------------------------
# Employment rate by quarter relative to quarter of disenrollment

dt %>%
  ggplot(mapping = aes(x = tau, y = mean_employed)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = 0), color = "red", linetype = "dashed") + 
  theme_bw() +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  scale_x_continuous(breaks = seq(-12,4,1), 
                     limits = c(-12,4)) +
  labs(x = "Quarters since post-PHE recert deadline", y = "Pct employed", title = "Employment rate by quarter since post-PHE recertification deadline,\namong working-age PD sample (N = 31,162)") +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/employment-over-time-since-recert-deadline.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)
```

### Employment outcomes by quarter relative to quarter of PD, only among the group that experienced a post-4/1/2023 PD from Medicaid

```{r}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample 

load(file = paste0(filepath, "/Data/Sample demographics/base_sample_demographics.rda"))

# Dates of PDs

load(file = paste0(filepath, "/Data/Medicaid enrollment data/procedural_disenrollment_dates.rda"))

# UI earnings data for the sample

load(file = paste0(filepath, "/Data/PA unemployment insurance data/ui_earnings.rda"))

# Earliest post-4/1/2023 PD dates

load(file = paste0(filepath, "/Data/Medicaid enrollment data/earliest_procedural_disenroll_dates.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

# Isolate the sample for this analysis. It's everyone who experienced a PD and was 25 to 60 years old as of 4/1/2023

analytic_sample <- earliest_procedural_disenroll_dates %>%
  inner_join(base_sample_demographics, by = c('ma_receipt_num')) %>%
  mutate(age_asof_04012023 = trunc((dob %--% as.Date('2023-04-01')) / years(1))) %>%
  filter(age_asof_04012023 >= 25 & age_asof_04012023 <= 60) %>%
  
# Calc the calendar quarter of the disenrollment dates
  
  mutate(disenrollment_quarter = str_remove(paste0(year(procedural_disenroll_date), quarters(procedural_disenroll_date)), "Q")) %>%
  distinct(ma_receipt_num, disenrollment_quarter)

# Calc each sample member's total UI earnings by quarter, and their quarterly employment status

dt <- ui_earnings %>%
  inner_join(analytic_sample, by = c('ma_receipt_num')) %>%
  group_by(ma_receipt_num, disenrollment_quarter, quarter) %>%
  summarise(ui_earnings = sum(ui_earnings)) %>%
  ungroup() %>%
  mutate(ui_employed = ifelse(ui_earnings > 0, 1, 0)) %>%
  
# Keep only the quarters from Q1 2020 to Q2 2024
  
  filter(quarter %in% c('20201', '20202', '20203', '20204', '20211', '20212', '20213', '20214', '20221', '20222', '20223', '20224', '20231', '20232', '20233', '20234', '20241', '20242')) 

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create graphs

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Employment by quarter

#----------------------------------------------------------------------------
# For cohort with PD in Q2 2023

# Keep only the T group members whose PD was in Q2 2023

dt %>%
  filter(disenrollment_quarter == "20232") %>%

# Calc the sample mean earnings in each quarter
  
  group_by(quarter) %>%
  summarise(mean_earnings = mean(ui_earnings), 
            mean_employed = mean(ui_employed)) %>%
  ungroup() %>%
  mutate(time = sequence(n())) %>%
  
# Create graph 
  
  ggplot(mapping = aes(x = time, y = mean_employed)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = 14), color = "red", linetype = "dashed") + 
  theme_bw() +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  scale_x_continuous(breaks = seq(1,18,1), 
                     limits = c(1,18),
                     labels = c('Q1 2020', ' ', 'Q3 2020', ' ', 'Q1 2021', ' ', 'Q3 2021', ' ', 'Q1 2022', ' ', 'Q3 2022', ' ', 'Q1 2023', ' ', 'Q3 2023', ' ', 'Q1 2024', ' ')) +
  labs(x = "Calendar quarter", y = "Pct employed", title = "Employment rate by quarter, among working-age sample\nthat had PD in Q2 2023 (N = 4,261)") +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/employment-over-time-since-pd-q22023.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)

#----------------------------------------------------------------------------
# For cohort with PD in Q3 2023

dt %>%
  filter(disenrollment_quarter == "20233") %>%
  group_by(quarter) %>%
  summarise(mean_earnings = mean(ui_earnings), 
            mean_employed = mean(ui_employed)) %>%
  ungroup() %>%
  mutate(time = sequence(n())) %>%
  
# Create graph 
  
  ggplot(mapping = aes(x = time, y = mean_employed)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = 15), color = "red", linetype = "dashed") + 
  theme_bw() +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  scale_x_continuous(breaks = seq(1,18,1), 
                     limits = c(1,18),
                     labels = c('Q1 2020', ' ', 'Q3 2020', ' ', 'Q1 2021', ' ', 'Q3 2021', ' ', 'Q1 2022', ' ', 'Q3 2022', ' ', 'Q1 2023', ' ', 'Q3 2023', ' ', 'Q1 2024', ' ')) +
  labs(x = "Calendar quarter", y = "Pct employed", title = "Employment rate by quarter, among working-age sample\nthat had PD in Q3 2023 (N = 5,862)") +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/employment-over-time-since-pd-q32023.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)

#----------------------------------------------------------------------------
# For cohort with PD in Q4 2023

dt %>%
  filter(disenrollment_quarter == "20234") %>%
  group_by(quarter) %>%
  summarise(mean_earnings = mean(ui_earnings), 
            mean_employed = mean(ui_employed)) %>%
  ungroup() %>%
  mutate(time = sequence(n())) %>%
  
# Create graph 
  
  ggplot(mapping = aes(x = time, y = mean_employed)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = 16), color = "red", linetype = "dashed") + 
  theme_bw() +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  scale_x_continuous(breaks = seq(1,18,1), 
                     limits = c(1,18),
                     labels = c('Q1 2020', ' ', 'Q3 2020', ' ', 'Q1 2021', ' ', 'Q3 2021', ' ', 'Q1 2022', ' ', 'Q3 2022', ' ', 'Q1 2023', ' ', 'Q3 2023', ' ', 'Q1 2024', ' ')) +
  labs(x = "Calendar quarter", y = "Pct employed", title = "Employment rate by quarter, among working-age sample\nthat had PD in Q4 2023 (N = 5,937)") +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/employment-over-time-since-pd-q42023.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Mean earnings by quarter 

#----------------------------------------------------------------------------
# For cohort with PD in Q2 2023

# Keep only the T group members whose PD was in Q2 2023

dt %>%
  filter(disenrollment_quarter == "20232") %>%

# Calc the sample mean earnings in each quarter
  
  group_by(quarter) %>%
  summarise(mean_earnings = mean(ui_earnings), 
            mean_employed = mean(ui_employed)) %>%
  ungroup() %>%
  mutate(time = sequence(n())) %>%
  
# Create graph 
  
  ggplot(mapping = aes(x = time, y = mean_earnings)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = 14), color = "red", linetype = "dashed") + 
  theme_bw() +
  scale_y_continuous(breaks = seq(0,7000,1000),
                     limits = c(0,7000),
                     labels = scales::dollar_format(accuracy = 1)) +
  scale_x_continuous(breaks = seq(1,18,1), 
                     limits = c(1,18),
                     labels = c('Q1 2020', ' ', 'Q3 2020', ' ', 'Q1 2021', ' ', 'Q3 2021', ' ', 'Q1 2022', ' ', 'Q3 2022', ' ', 'Q1 2023', ' ', 'Q3 2023', ' ', 'Q1 2024', ' ')) +
  labs(x = "Calendar quarter", y = "Mean earnings ($)", title = "Mean UI earnings by quarter, among working-age sample\nthat had PD in Q2 2023 (N = 4,261)") +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/earnings-over-time-since-pd-q22023.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)

#----------------------------------------------------------------------------
# For cohort with PD in Q3 2023

dt %>%
  filter(disenrollment_quarter == "20233") %>%
  group_by(quarter) %>%
  summarise(mean_earnings = mean(ui_earnings), 
            mean_employed = mean(ui_employed)) %>%
  ungroup() %>%
  mutate(time = sequence(n())) %>%
  
# Create graph 
  
  ggplot(mapping = aes(x = time, y = mean_earnings)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = 15), color = "red", linetype = "dashed") + 
  theme_bw() +
  scale_y_continuous(breaks = seq(0,7000,1000),
                     limits = c(0,7000),
                     labels = scales::dollar_format(accuracy = 1)) +
  scale_x_continuous(breaks = seq(1,18,1), 
                     limits = c(1,18),
                     labels = c('Q1 2020', ' ', 'Q3 2020', ' ', 'Q1 2021', ' ', 'Q3 2021', ' ', 'Q1 2022', ' ', 'Q3 2022', ' ', 'Q1 2023', ' ', 'Q3 2023', ' ', 'Q1 2024', ' ')) +
  labs(x = "Calendar quarter", y = "Mean earnings ($)", title = "Mean UI earnings by quarter, among working-age sample\nthat had PD in Q3 2023 (N = 5,862)") +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/earnings-over-time-since-pd-q32023.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)

#----------------------------------------------------------------------------
# For cohort with PD in Q4 2023

dt %>%
  filter(disenrollment_quarter == "20234") %>%
  group_by(quarter) %>%
  summarise(mean_earnings = mean(ui_earnings), 
            mean_employed = mean(ui_employed)) %>%
  ungroup() %>%
  mutate(time = sequence(n())) %>%
  
# Create graph 
  
  ggplot(mapping = aes(x = time, y = mean_earnings)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = 16), color = "red", linetype = "dashed") + 
  theme_bw() +
  scale_y_continuous(breaks = seq(0,7000,1000),
                     limits = c(0,7000),
                     labels = scales::dollar_format(accuracy = 1)) +
  scale_x_continuous(breaks = seq(1,18,1), 
                     limits = c(1,18),
                     labels = c('Q1 2020', ' ', 'Q3 2020', ' ', 'Q1 2021', ' ', 'Q3 2021', ' ', 'Q1 2022', ' ', 'Q3 2022', ' ', 'Q1 2023', ' ', 'Q3 2023', ' ', 'Q1 2024', ' ')) +
  labs(x = "Calendar quarter", y = "Mean earnings ($)", title = "Mean UI earnings by quarter, among working-age sample\nthat had PD in Q4 2023 (N = 5,937)") +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/earnings-over-time-since-pd-q42023.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)
```

### Diff-in-diff 1: Comparison of employment outcomes by calendar quarter between all C group members and only the T group members whose PD took place in QX 2023. Using X = 2, 3, and 4 

#### Among full sample

```{r}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample 

load(file = paste0(filepath, "/Data/Sample demographics/base_sample_demographics.rda"))

# Dates of PDs

load(file = paste0(filepath, "/Data/Medicaid enrollment data/procedural_disenrollment_dates.rda"))

# UI earnings data for the sample

load(file = paste0(filepath, "/Data/PA unemployment insurance data/ui_earnings.rda"))

# Earliest post-4/1/2023 PD dates

load(file = paste0(filepath, "/Data/Medicaid enrollment data/earliest_procedural_disenroll_dates.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

# Isolate the sample for this analysis. It's everyone who experienced a PD and was 25 to 60 years old as of 4/1/2023, plus everyone who did not experience a PD and was in this age range

analytic_sample <- earliest_procedural_disenroll_dates %>%
  inner_join(base_sample_demographics, by = c('ma_receipt_num')) %>%

# Calc the calendar quarter of the disenrollment dates
  
  mutate(disenrollment_quarter = str_remove(paste0(year(procedural_disenroll_date), quarters(procedural_disenroll_date)), "Q")) %>%
  distinct(ma_receipt_num, dob, treat, disenrollment_quarter) %>%
  
# Combine with all C group members
  
  bind_rows(test <- base_sample_demographics %>%
            filter(treat == 0) %>%
            mutate(disenrollment_quarter = NA) %>%
            select(ma_receipt_num, dob, treat, disenrollment_quarter)) %>%
  mutate(age_asof_04012023 = trunc((dob %--% as.Date('2023-04-01')) / years(1))) %>%
  filter(age_asof_04012023 >= 25 & age_asof_04012023 <= 60) 

# Calc each sample member's total UI earnings by quarter, and their quarterly employment status

dt <- ui_earnings %>%
  inner_join(analytic_sample, by = c('ma_receipt_num')) %>%
  group_by(ma_receipt_num, treat, disenrollment_quarter, quarter) %>%
  summarise(ui_earnings = sum(ui_earnings)) %>%
  ungroup() %>%
  mutate(ui_employed = ifelse(ui_earnings > 0, 1, 0)) %>%
  
# Keep only the quarters from Q1 2020 to Q2 2024
  
  filter(quarter %in% c('20201', '20202', '20203', '20204', '20211', '20212', '20213', '20214', '20221', '20222', '20223', '20224', '20231', '20232', '20233', '20234', '20241', '20242')) %>%
  
# Create a crosswalk of ordered calendar quarters for graphing

  inner_join(data.frame(quarter = c('20201', '20202', '20203', '20204', '20211', '20212', '20213', '20214', '20221', '20222', '20223', '20224', '20231', '20232', '20233', '20234', '20241', '20242'), 
                        time = c(1:18)), 
             by = c('quarter')) 

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create graphs

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Mean earnings 

#----------------------------------------------------------------------------
# Using only the T group members who became procedurally disenrolled in Q2 2023

dt %>%
  filter(disenrollment_quarter %in% c(NA, '20232')) %>%
  mutate(treat = ifelse(treat == 1, 'Had PD in Q2 2023', 'Has not had PD since end of PHE')) %>%
  group_by(quarter, time, treat) %>%
  summarise(mean_earnings = mean(ui_earnings), 
            mean_employed = mean(ui_employed)) %>%
  ungroup() %>% 
  ggplot(mapping = aes(x = time, y = mean_earnings, colour = treat, group = treat)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = 14), color = "red", linetype = "dashed") + 
  theme_bw() +
  scale_y_continuous(breaks = seq(0,7000,1000),
                     limits = c(0,7000),
                     labels = scales::dollar_format(accuracy = 1)) +
  scale_x_continuous(breaks = seq(1,18,1),
                     limits = c(1,18),
                     labels = c('Q1 2020', ' ', 'Q3 2020', ' ', 'Q1 2021', ' ', 'Q3 2021', ' ', 'Q1 2022', ' ', 'Q3 2022', ' ', 'Q1 2023', ' ', 'Q3 2023', ' ', 'Q1 2024', ' ')) +
  labs(x = "Calendar quarter", y = "Mean earnings ($)", title = "Mean UI earnings by quarter, among working-age sample that had PD\nin Q2 2023 (N = 4,240) vs. never had PD (N = 93,589)") +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/earnings-did1-descrip-q22023-full-sample.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)

#----------------------------------------------------------------------------
# Using only the T group members who became procedurally disenrolled in Q3 2023

dt %>%
  filter(disenrollment_quarter %in% c(NA, '20233')) %>%
  mutate(treat = ifelse(treat == 1, 'Had PD in Q3 2023', 'Has not had PD since end of PHE')) %>%
  group_by(quarter, time, treat) %>%
  summarise(mean_earnings = mean(ui_earnings), 
            mean_employed = mean(ui_employed)) %>%
  ungroup() %>% 
  ggplot(mapping = aes(x = time, y = mean_earnings, colour = treat, group = treat)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = 15), color = "red", linetype = "dashed") + 
  theme_bw() +
  scale_y_continuous(breaks = seq(0,7000,1000),
                     limits = c(0,7000),
                     labels = scales::dollar_format(accuracy = 1)) +
  scale_x_continuous(breaks = seq(1,18,1),
                     limits = c(1,18),
                     labels = c('Q1 2020', ' ', 'Q3 2020', ' ', 'Q1 2021', ' ', 'Q3 2021', ' ', 'Q1 2022', ' ', 'Q3 2022', ' ', 'Q1 2023', ' ', 'Q3 2023', ' ', 'Q1 2024', ' ')) +
  labs(x = "Calendar quarter", y = "Mean earnings ($)", title = "Mean UI earnings by quarter, among working-age sample that had PD\nin Q3 2023 (N = 5,862) vs. never had PD (N = 93,589)") +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/earnings-did1-descrip-q32023-full-sample.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)

#----------------------------------------------------------------------------
# Using only the T group members who became procedurally disenrolled in Q4 2023

dt %>%
  filter(disenrollment_quarter %in% c(NA, '20234')) %>%
  mutate(treat = ifelse(treat == 1, 'Had PD in Q4 2023', 'Has not had PD since end of PHE')) %>%
  group_by(quarter, time, treat) %>%
  summarise(mean_earnings = mean(ui_earnings), 
            mean_employed = mean(ui_employed)) %>%
  ungroup() %>% 
  ggplot(mapping = aes(x = time, y = mean_earnings, colour = treat, group = treat)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = 16), color = "red", linetype = "dashed") + 
  theme_bw() +
  scale_y_continuous(breaks = seq(0,7000,1000),
                     limits = c(0,7000),
                     labels = scales::dollar_format(accuracy = 1)) +
  scale_x_continuous(breaks = seq(1,18,1),
                     limits = c(1,18),
                     labels = c('Q1 2020', ' ', 'Q3 2020', ' ', 'Q1 2021', ' ', 'Q3 2021', ' ', 'Q1 2022', ' ', 'Q3 2022', ' ', 'Q1 2023', ' ', 'Q3 2023', ' ', 'Q1 2024', ' ')) +
  labs(x = "Calendar quarter", y = "Mean earnings ($)", title = "Mean UI earnings by quarter, among working-age sample that had PD\nin Q4 2023 (N = 5,937) vs. never had PD (N = 93,589)") +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/earnings-did1-descrip-q42023-full-sample.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Employment rate 

#----------------------------------------------------------------------------
# Using only the T group members who became procedurally disenrolled in Q2 2023

dt %>%
  filter(disenrollment_quarter %in% c(NA, '20232')) %>%
        mutate(treat = ifelse(treat == 1, 'Had PD in Q2 2023', 'Has not had PD since end of PHE')) %>%
  group_by(quarter, time, treat) %>%
  summarise(mean_earnings = mean(ui_earnings), 
            mean_employed = mean(ui_employed)) %>%
  ungroup() %>% 
  ggplot(mapping = aes(x = time, y = mean_employed, colour = treat, group = treat)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = 14), color = "red", linetype = "dashed") + 
  theme_bw() +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  scale_x_continuous(breaks = seq(1,18,1),
                     limits = c(1,18),
                     labels = c('Q1 2020', ' ', 'Q3 2020', ' ', 'Q1 2021', ' ', 'Q3 2021', ' ', 'Q1 2022', ' ', 'Q3 2022', ' ', 'Q1 2023', ' ', 'Q3 2023', ' ', 'Q1 2024', ' ')) +
  labs(x = "Calendar quarter", y = "Pct employed", title = "Employment rate by quarter, among working-age sample that had PD\nin Q2 2023 (N = 4,261) vs. never had PD (N = 93,589)") +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/employment-did1-descrip-q22023-full-sample.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)

#----------------------------------------------------------------------------
# Using only the T group members who became procedurally disenrolled in Q3 2023

dt %>%
  filter(disenrollment_quarter %in% c(NA, '20233')) %>%
        mutate(treat = ifelse(treat == 1, 'Had PD in Q3 2023', 'Has not had PD since end of PHE')) %>%
  group_by(quarter, time, treat) %>%
  summarise(mean_earnings = mean(ui_earnings), 
            mean_employed = mean(ui_employed)) %>%
  ungroup() %>% 
  ggplot(mapping = aes(x = time, y = mean_employed, colour = treat, group = treat)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = 15), color = "red", linetype = "dashed") + 
  theme_bw() +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  scale_x_continuous(breaks = seq(1,18,1),
                     limits = c(1,18),
                     labels = c('Q1 2020', ' ', 'Q3 2020', ' ', 'Q1 2021', ' ', 'Q3 2021', ' ', 'Q1 2022', ' ', 'Q3 2022', ' ', 'Q1 2023', ' ', 'Q3 2023', ' ', 'Q1 2024', ' ')) +
  labs(x = "Calendar quarter", y = "Pct employed", title = "Employment rate by quarter, among working-age sample that had PD\nin Q3 2023 (N = 5,862) vs. never had PD (N = 93,589)") +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/employment-did1-descrip-q32023-full-sample.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)

#----------------------------------------------------------------------------
# Using only the T group members who became procedurally disenrolled in Q4 2023

dt %>%
  filter(disenrollment_quarter %in% c(NA, '20234')) %>%
        mutate(treat = ifelse(treat == 1, 'Had PD in Q4 2023', 'Has not had PD since end of PHE')) %>%
  group_by(quarter, time, treat) %>%
  summarise(mean_earnings = mean(ui_earnings), 
            mean_employed = mean(ui_employed)) %>%
  ungroup() %>% 
  ggplot(mapping = aes(x = time, y = mean_employed, colour = treat, group = treat)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = 16), color = "red", linetype = "dashed") + 
  theme_bw() +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  scale_x_continuous(breaks = seq(1,18,1),
                     limits = c(1,18),
                     labels = c('Q1 2020', ' ', 'Q3 2020', ' ', 'Q1 2021', ' ', 'Q3 2021', ' ', 'Q1 2022', ' ', 'Q3 2022', ' ', 'Q1 2023', ' ', 'Q3 2023', ' ', 'Q1 2024', ' ')) +
  labs(x = "Calendar quarter", y = "Pct employed", title = "Employment rate by quarter, among working-age sample that had PD\nin Q4 2023 (N = 5,937) vs. never had PD (N = 93,589)") +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/employment-did1-descrip-q42023-full-sample.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)
```

### Diff-in-diff 2: Comparison of employment outcomes by quarter relative to the quarter of the person's first post-4/1/2023 eligibility recertification deadline

#### Among full sample

```{r}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample 

load(file = paste0(filepath, "/Data/Sample demographics/base_sample_demographics.rda"))

# Dates of PDs

load(file = paste0(filepath, "/Data/Medicaid enrollment data/procedural_disenrollment_dates.rda"))

# Recertification deadlines

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_recert_deadlines.rda"))

# UI earnings data for the sample

load(file = paste0(filepath, "/Data/PA unemployment insurance data/ui_earnings.rda"))

# Earliest post-4/1/2023 PD dates

load(file = paste0(filepath, "/Data/Medicaid enrollment data/earliest_procedural_disenroll_dates.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

# Identify each sample member's earliest post-4/1/2023 Medicaid recertification deadline

analytic_sample <- medicaid_recert_deadlines %>%
  filter(recert_deadline >= as.Date('2023-04-01')) %>%
  group_by(ma_receipt_num) %>%
  top_n(-1, recert_deadline) %>%
  ungroup() %>% 
  
# Remove the sample members who did not have a Medicaid recertification deadline in 2023 or 2024. (Figure out why these people did not have a recertification deadline in these years; I thought everyone was supposed to have one)
  
  filter(recert_deadline <= as.Date('2024-12-31')) %>%

# Keep only the sample members who were between 25 and 60 as of their earliest post-4/1/2023 recertification deadline. I plan to look at their earnings from roughly +/- 3 years from their recertification deadline, so this rule will roughly ensure that everyone in the analysis is of working age

  inner_join(base_sample_demographics %>% 
             select(ma_receipt_num, treat, dob), 
             by = c('ma_receipt_num')) %>%
  mutate(age = trunc((dob %--% recert_deadline) / years(1))) %>%
  filter(age >= 25 & age <= 60) %>%
  
# Calc the quarter of the person's recertification deadline
  
  mutate(recert_deadline_quarter = str_remove(paste0(year(recert_deadline), quarters(recert_deadline)), "Q")) 

# Calc each client's total UI earnings by quarter, and their quarterly employment status

dt <- ui_earnings %>%
  group_by(ma_receipt_num, quarter) %>%
  summarise(ui_earnings = sum(ui_earnings)) %>%
  ungroup() %>%
  mutate(ui_employed = ifelse(ui_earnings > 0, 1, 0)) %>%

# Keep only the UI outcomes for the analytic sample

  inner_join(analytic_sample, by = c('ma_receipt_num')) %>%
  
# Give groups more descriptive names for graphing
  
    mutate(treat = ifelse(treat == 1, 'Had PD since end of PHE', 'Has not had PD since end of PHE'),
  
# Calc the number of quarters since the quarter of the person's recertification deadline. Keep only values of -12 to 4. I don't really care about having UI data from more than 12 quarters prior to disenrollment, and we only have a maximum of 4 quarters' worth of post-deadline UI data available right now
  
        tau = quarter_diff(recert_deadline_quarter, quarter)) %>%
  filter(tau >= -12 & tau <= 4) %>%
  
# Calc the sample mean earnings in each quarter for the T and C groups
  
  group_by(tau, treat) %>%
  summarise(mean_earnings = mean(ui_earnings), 
            mean_employed = mean(ui_employed)) %>%
  ungroup()
  
#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create graphs

#----------------------------------------------------------------------------
# Mean earnings 

dt %>%
  ggplot(mapping = aes(x = tau, y = mean_earnings, colour = treat, group = treat)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = 0), color = "red", linetype = "dashed") + 
  theme_bw() +
  scale_y_continuous(breaks = seq(0,7000,1000),
                     limits = c(0,7000),
                     labels = scales::dollar_format(accuracy = 1)) +
  scale_x_continuous(breaks = seq(-12,4,1),
                     limits = c(-12,4)) +
  labs(x = "Quarters since post-PHE recert deadline", y = "Mean earnings ($)", title = "Earnings by quarter since post-PHE recertification deadline,\n among working-age sample") +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/earnings-did2-descrip-full-sample.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)

#----------------------------------------------------------------------------
# Mean employment

dt %>%
  ggplot(mapping = aes(x = tau, y = mean_employed, colour = treat, group = treat)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = 0), color = "red", linetype = "dashed") + 
  theme_bw() +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  scale_x_continuous(breaks = seq(-12,4,1),
                     limits = c(-12,4)) +
  labs(x = "Quarters since post-PHE recert deadline", y = "Pct employed", title = "Employment rate by quarter since post-PHE recertification deadline,\n among working-age sample") +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/employment-did2-descrip-full-sample.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)
```

## Treatment effect estimates

### Diff-in-diff 1: Comparison of outcomes by calendar quarter between all C group members and only the T group members whose PD took place in QX 2023. Using X = 2, 3, and 4 

#### UI employment outcomes

##### Among full sample

```{r, eval = TRUE}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample 

load(file = paste0(filepath, "/Data/Sample demographics/base_sample_demographics.rda"))

# Dates of PDs

load(file = paste0(filepath, "/Data/Medicaid enrollment data/procedural_disenrollment_dates.rda"))

# UI earnings data for the sample

load(file = paste0(filepath, "/Data/PA unemployment insurance data/ui_earnings.rda"))

# Earliest post-4/1/2023 PD dates

load(file = paste0(filepath, "/Data/Medicaid enrollment data/earliest_procedural_disenroll_dates.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Prepare data for analysis

# Isolate the sample for this analysis. It's everyone who experienced a PD and was 25 to 60 years old as of 4/1/2023, plus everyone who did not experience a PD and was in this age range

analytic_sample <- earliest_procedural_disenroll_dates %>%
  inner_join(base_sample_demographics, by = c('ma_receipt_num')) %>%

# Calc the calendar quarter of the disenrollment dates
  
  mutate(disenrollment_quarter = str_remove(paste0(year(procedural_disenroll_date), quarters(procedural_disenroll_date)), "Q")) %>%
  distinct(ma_receipt_num, dob, treat, disenrollment_quarter) %>%
  
# Combine with all C group members
  
  bind_rows(base_sample_demographics %>%
            filter(treat == 0) %>%
            mutate(disenrollment_quarter = NA) %>%
            select(ma_receipt_num, dob, treat, disenrollment_quarter)) %>%
  mutate(age_asof_04012023 = trunc((dob %--% as.Date('2023-04-01')) / years(1))) %>%
  filter(age_asof_04012023 >= 25 & age_asof_04012023 <= 60) 

# Calc each sample member's total UI earnings by quarter, and their quarterly employment status

dt <- ui_earnings %>%
  inner_join(analytic_sample, by = c('ma_receipt_num')) %>%
  group_by(ma_receipt_num, treat, disenrollment_quarter, quarter) %>%
  summarise(ui_earnings = sum(ui_earnings)) %>%
  ungroup() %>%
  mutate(ui_employed = ifelse(ui_earnings > 0, 1, 0)) %>%
  
# Keep only the quarters from Q1 2020 to Q2 2024
  
  filter(quarter %in% c('20201', '20202', '20203', '20204', '20211', '20212', '20213', '20214', '20221', '20222', '20223', '20224', '20231', '20232', '20233', '20234', '20241', '20242')) 

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Estimate treatment effects

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Simple 2x2 diff-in-diff

# Create shell data frame for results

model_results <- data.frame()

for(u in c('20232', '20233', '20234')){
for(v in c('ui_earnings', 'ui_employed')){
  
# Keep all C group members and only the T group members whose PD took place in the given quarter

model_data <- dt %>%
  filter(disenrollment_quarter %in% c(NA, u)) %>%
         
# Calc the number of quarters since the given PD quarter for each obs

  mutate(tau = quarter_diff('20232', quarter),
  
# Create a dummy var to indicate the post-treatment time period
  
        post = ifelse(tau > 0, 1, 0)) %>%
  
# Keep only the given outcome
  
  rename(outcome = all_of(v)) 

# Calc the simple 2x2 diff-in-diff inputs

mean_pre_treat <- mean(model_data$outcome[model_data$treat == 1 & model_data$post == 0], na.rm = TRUE)
mean_post_treat <- mean(model_data$outcome[model_data$treat == 1 & model_data$post == 1], na.rm = TRUE)
mean_pre_control <- mean(model_data$outcome[model_data$treat == 0 & model_data$post == 0], na.rm = TRUE)
mean_post_control <- mean(model_data$outcome[model_data$treat == 0 & model_data$post == 1], na.rm = TRUE)

# Calc the simple 2x2 diff-in-diff estimate using regression

model <- feols(outcome ~ treat*post,
                data = model_data, 
                notes = FALSE,
                vcov = "hetero")

# Add results to running table

model_results_add <- data.frame(variable = names(coef(model)),
                                effect = coef(model),
                                std_err = se(model),
                                p_value = fixest::pvalue(model)) %>%
  filter(variable == "treat:post") %>%
  select(-variable) %>%
  mutate(mean_pre_treat = mean_pre_treat, 
         mean_post_treat = mean_post_treat, 
         mean_pre_control = mean_pre_control, 
         mean_post_control = mean_post_control, 
         diff_in_diff_manual = (mean_post_treat - mean_pre_treat) - (mean_post_control - mean_pre_control), 
         outcome = v, 
         disenrollment_quarter = u, 
         method = "Simple 2x2")

model_results <- bind_rows(model_results, model_results_add)
}}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Simple event study model

for(u in c('20232', '20233', '20234')){
for(v in c('ui_earnings', 'ui_employed')){
  
# Keep all C group members and only the T group members whose PD took place in the given quarter

model_data <- dt %>%
  filter(disenrollment_quarter %in% c(NA, u)) %>%
         
# Calc the number of quarters since the given PD quarter for each obs

  mutate(tau = quarter_diff(u, quarter),
  
# Create a dummy var to indicate the post-treatment time period
  
        post = ifelse(tau > 0, 1, 0), 

# Create a time-varying dummy var for being treated in time t

        treated = ifelse(post == 1 & treat == 1, 1, 0)) %>%
  
# Keep only the given outcome
  
  rename(outcome = all_of(v)) 

#----------------------------------------------------------------------------
# Difference-in-differences version

# Run the diff-in-diff regression

model <- feols(outcome ~ treated,
                             data = model_data, 
                             vcov = "hetero")

# Add results to running table

model_results_add <- data.frame(variable = names(coef(model)),
                                effect = coef(model),
                                std_err = se(model),
                                p_value = fixest::pvalue(model)) %>%
  filter(variable == "treated") %>%
  select(-variable) %>%
  mutate(outcome = v, 
         disenrollment_quarter = u, 
         method = "TWFE done manually")

model_results <- bind_rows(model_results, model_results_add)

#----------------------------------------------------------------------------
# Event study version

# Run regression

model <- feols(outcome ~ i(tau, treat, ref = 0),
               data = model_data,
               vcov = 'hetero')

# Store regression results

event_study_data <- data.frame(variable = names(coef(model)), 
                               effect = coef(model), 
                               std_err = se(model)) %>%
  mutate(tau = as.numeric(str_replace_all(variable, "tau::|:treat", ""))) %>%
  right_join(model_data %>% 
            distinct(quarter, tau), 
            by = c('tau'))

# Create names for event study graph titles

if(v == 'ui_earnings'){v_title <- 'quarterly UI earnings'}
if(v == 'ui_employed'){v_title <- 'likelihood of employment'}
if(u == '20232'){u_title <- 'Q2 2023'}
if(u == '20233'){u_title <- 'Q3 2023'}
if(u == '20234'){u_title <- 'Q4 2023'}

# Create event study graph

plot <- event_study_data %>%
  ggplot(mapping = aes(x = tau, y = effect)) +
  geom_point(aes(shape = tau == 0, fill = tau == 0)) +
  scale_shape_manual(values = c(16, 21)) +
  scale_fill_manual(values = c("black", "white")) +
  geom_errorbar(aes(x = tau, 
                ymin = effect - 1.96*std_err, 
                ymax = effect + 1.96*std_err), 
                width = 0.2) + 
  geom_hline(aes(yintercept = 0), color = "black", linetype = "solid") + 
  geom_vline(aes(xintercept = 0), color = "red", linetype = "dashed") + 
  # scale_y_continuous(breaks = seq(-2000, 2000, 500),
  #                 limits = c(-2000, 2000), 
  #                 labels = scales::dollar_format(accuracy = 1)) +
  scale_x_continuous(breaks = seq(min(event_study_data$tau), max(event_study_data$tau), 1), 
                     limits = c(min(event_study_data$tau), max(event_study_data$tau)), 
                     labels = c('Q1 2020', ' ', 'Q3 2020', ' ', 'Q1 2021', ' ', 'Q3 2021', ' ', 'Q1 2022', ' ', 'Q3 2022', ' ', 'Q1 2023', ' ', 'Q3 2023', ' ', 'Q1 2024', ' ')) +
  labs(x = "Calendar quarter", y = "Treatment effect", title = paste0("Effect on ", v_title, " among working-age sample that had PD in ", u_title)) + 
  theme_bw() + 
  theme(panel.background = element_blank(), 
        legend.position = "none",
        panel.grid.minor.y = element_blank(),
        axis.text = element_text(size = 9),
        axis.title = element_text(size = 9),
        plot.title = element_text(size = 11),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank())

ggsave(paste0(filepath, "/Tables and figures/", "did1-eventstudy-simple-fullsample-", u, "-", v, ".png"), 
  plot = last_plot(),
  width = 7,
  height = 4)
}}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Event study with two-way fixed effects

for(u in c('20232', '20233', '20234')){
for(v in c('ui_earnings', 'ui_employed')){
  
# Keep all C group members and only the T group members whose PD took place in the given quarter

model_data <- dt %>%
  filter(disenrollment_quarter %in% c(NA, u)) %>%
         
# Calc the number of quarters since the given PD quarter for each obs

  mutate(tau = quarter_diff('20232', quarter),
  
# Create a dummy var to indicate the post-treatment time period
  
        post = ifelse(tau > 0, 1, 0), 

# Create a time-varying dummy var for being treated in time t

        treated = ifelse(post == 1 & treat == 1, 1, 0)) %>%
  
# Keep only the given outcome
  
  rename(outcome = all_of(v)) 

#----------------------------------------------------------------------------
# Difference-in-differences 

# Run the diff-in-diff regression

model <- feols(outcome ~ treated | quarter + ma_receipt_num,
                             data = model_data, 
                             vcov = "hetero")

# Add results to running table

model_results_add <- data.frame(variable = names(coef(model)),
                                effect = coef(model),
                                std_err = se(model),
                                p_value = fixest::pvalue(model)) %>%
  filter(variable == "treated") %>%
  select(-variable) %>%
  mutate(outcome = v, 
         disenrollment_quarter = u, 
         method = "TWFE done manually")

model_results <- bind_rows(model_results, model_results_add)

#----------------------------------------------------------------------------
# Event study

# Version with no fixed effects

model_simple <- feols(outcome ~ i(tau, treat, ref = 0),
               data = model_data,
               vcov = 'hetero')

event_study_data_simple <- data.frame(variable = names(coef(model_simple)), 
                               effect = coef(model_simple), 
                               std_err = se(model_simple)) %>%
  mutate(tau = as.numeric(str_replace_all(variable, "tau::|:treat", ""))) 

# Version with two-way fixed effects

model_twfe <- feols(outcome ~ i(tau, treat, ref = 0) | quarter + ma_receipt_num,
               data = model_data,
               vcov = 'hetero')

event_study_data_twfe <- data.frame(variable = names(coef(model_twfe)), 
                               effect = coef(model_twfe), 
                               std_err = se(model_twfe)) %>%
  mutate(tau = as.numeric(str_replace_all(variable, "tau::|:treat", ""))) 

# Create names for event study graph titles

if(v == 'ui_earnings'){v_title <- 'quarterly UI earnings'}
if(v == 'ui_employed'){v_title <- 'likelihood of employment'}
if(u == '20232'){u_title <- 'Q2 2023'}
if(u == '20233'){u_title <- 'Q3 2023'}
if(u == '20234'){u_title <- 'Q4 2023'}

# Create event study graph

plot <- event_study_data %>%
  ggplot(mapping = aes(x = tau, y = effect)) +
  geom_point(aes(shape = tau == 0, fill = tau == 0)) +
  scale_shape_manual(values = c(16, 21)) +
  scale_fill_manual(values = c("black", "white")) +
  geom_errorbar(aes(x = tau, 
                ymin = effect - 1.96*std_err, 
                ymax = effect + 1.96*std_err), 
                width = 0.2) + 
  geom_hline(aes(yintercept = 0), color = "black", linetype = "solid") + 
  geom_vline(aes(xintercept = 0), color = "red", linetype = "dashed") + 
  # scale_y_continuous(breaks = seq(-2000, 2000, 500),
  #                 limits = c(-2000, 2000), 
  #                 labels = scales::dollar_format(accuracy = 1)) +
  scale_x_continuous(breaks = seq(-14, 5, 1), 
                     limits = c(-14, 5), 
                     labels = c(' ', 'Q1 2020', ' ', 'Q3 2020', ' ', 'Q1 2021', ' ', 'Q3 2021', ' ', 'Q1 2022', ' ', 'Q3 2022', ' ', 'Q1 2023', ' ', 'Q3 2023', ' ', 'Q1 2024', ' ', ' ')) +
  labs(x = "Calendar quarter", y = "Treatment effect", title = paste0("Effect on ", v_title, " among those disenrolled in ", u_title)) + 
  theme_bw() + 
  theme(panel.background = element_blank(), 
        legend.position = "none",
        panel.grid.minor.y = element_blank(),
        axis.text = element_text(size = 9),
        axis.title = element_text(size = 9),
        plot.title = element_text(size = 11),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank())

ggsave(paste0(filepath, "/Tables and figures/", "did1-eventstudy-twfe-fullsample-", u, "-", v, ".png"), 
  plot = last_plot(),
  width = 7,
  height = 4)
}}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Using Callaway and Sant'Anna package

for(u in c('20232', '20233', '20234')){
for(v in c('ui_earnings', 'ui_employed')){
  
# Keep all C group members and only the T group members whose PD took place in the given quarter

model_data <- dt %>%
  filter(disenrollment_quarter %in% c(NA, u)) %>%
         
# Calc the number of quarters since the given PD quarter for each obs

  mutate(tau = quarter_diff('20232', quarter),

# Create a variable that records the quarter when each T group member first became treated. Make this variable = 0 for the C group members. 

        first_treat = as.numeric(substring(disenrollment_quarter, 1, 4)) + ((as.numeric(substring(disenrollment_quarter, 5,5)) - 1) / 4),
        first_treat = replace_na(first_treat, 0),

# Recode the 'quarter' variable in the following way. This makes the 'time to event' calculation work properly in the below model.

       quarter_callsant = as.numeric(substring(quarter, 1, 4)) + ((as.numeric(substring(quarter, 5,5)) - 1) / 4)) %>%

# Keep only the given outcome
  
  rename(outcome = all_of(v)) 

# The Callaway and Sant'Anna package requires the individual ID variable to be numeric, so create a new ID variable for each person in the panel

id_xwalk <- model_data %>%
  distinct(ma_receipt_num) %>%
  mutate(id_callsant = sequence(n())) 

model_data <- model_data %>% 
  left_join(id_xwalk, by = c('ma_receipt_num'))

# Run the regression

model <- att_gt(yname = "outcome",
                   gname = "first_treat",
                   idname = "id_callsant",
                   tname = "quarter_callsant",
                   xformla = ~1,
                   allow_unbalanced_panel = TRUE,
                   data = model_data)

# Add results to running table

model_stats <- aggte(model, type = "simple")

effect <- as.data.frame(as.matrix(summary(model_stats$overall.att))) %>%
  rownames_to_column() %>%
  filter(rowname == 'Mean')
effect <- effect$V1

std_err <- as.data.frame(as.matrix(summary(model_stats$overall.se))) %>%
  rownames_to_column() %>%
  filter(rowname == 'Mean')
std_err <- std_err$V1

p_value <- 2*pnorm(-abs(effect/std_err))

model_results_add <- data.frame(effect = effect, 
                                std_err = std_err, 
                                p_value = p_value) %>%
  mutate(outcome = v, 
         disenrollment_quarter = u, 
         method = "Callaway and Sant'Anna")

model_results <- bind_rows(model_results, model_results_add)

# Also save the event study plot 

event_study <- aggte(model, type = "dynamic")

plot <- ggdid(event_study, 
      xgap = 2,
      theming = FALSE) + 
  geom_hline(aes(yintercept = 0), color = "black", linetype = "solid") + 
  geom_vline(aes(xintercept = 0), color = "red", linetype = "dashed") + 
  theme_bw() + 
  # scale_y_continuous(breaks = seq(-3000, 2000, 500),
  #                   limits = c(-3000, 2000),
  #                   labels = dollar_format(accuracy = 1)) +
  scale_x_continuous(breaks = seq(-3.75, 0.75, 0.25),
                    limits = c(-3.75, 0.75)) +
  labs(y = "Treatment effect", x = "Calendar quarter") + 
  theme(panel.background = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position = 'none',
        plot.title = element_blank(),
        panel.grid.major.x = element_blank(),
        axis.text = element_text(size = 10),
        axis.title = element_text(size = 10)) 

ggsave(paste0(filepath, "/Tables and figures/", "did1-eventstudy-callsant-fullsample-", u, "-", v, ".png"), 
  plot = last_plot(),
  width = 7,
  height = 4)
}}

# Save results from the various treatment effect estimations

model_results_did1_full_sample <- model_results
save(model_results_did1_full_sample, file = paste0(filepath, "/Model outputs/model_results_did1_full_sample.rda"))
```

### Diff-in-diff 2: Comparison of outcomes by quarter relative to the quarter of the person's first post-4/1/2023 eligibility recertification deadline

#### Among full sample

```{r, eval = TRUE}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample 

load(file = paste0(filepath, "/Data/Sample demographics/base_sample_demographics.rda"))

# Dates of PDs

load(file = paste0(filepath, "/Data/Medicaid enrollment data/procedural_disenrollment_dates.rda"))

# Medicaid recertification deadlines

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_recert_deadlines.rda"))

# UI earnings data for the sample

load(file = paste0(filepath, "/Data/PA unemployment insurance data/ui_earnings.rda"))

# Earliest post-4/1/2023 PD dates

load(file = paste0(filepath, "/Data/Medicaid enrollment data/earliest_procedural_disenroll_dates.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Prepare data for analysis

# Identify each sample member's earliest post-4/1/2023 Medicaid recertification deadline

dt <- medicaid_recert_deadlines %>%
  filter(recert_deadline >= as.Date('2023-04-01')) %>%
  group_by(ma_receipt_num) %>%
  top_n(-1, recert_deadline) %>%
  ungroup() %>% 
  
# Remove the sample members who did not have a Medicaid recertification deadline in 2023 or 2024. 
  
  filter(recert_deadline <= as.Date('2024-12-31')) %>%

# Keep only the sample members who were between 25 and 60 as of their earliest post-4/1/2023 recertification deadline. I plan to look at their earnings from roughly +/- 3 years from their recertification deadline, so this rule will roughly ensure that everyone in the analysis is of working age

  inner_join(base_sample_demographics %>% 
             select(ma_receipt_num, treat, dob), 
             by = c('ma_receipt_num')) %>%
  mutate(age = trunc((dob %--% recert_deadline) / years(1))) %>%
  filter(age >= 25 & age <= 60) %>%
  
# Calc the quarter of the person's recertification deadline
  
  mutate(recert_deadline_quarter = str_remove(paste0(year(recert_deadline), quarters(recert_deadline)), "Q")) %>%

# Calc each client's total UI earnings by quarter, and their quarterly employment status

  left_join(ui_earnings, by = c('ma_receipt_num')) %>%
  group_by(ma_receipt_num, treat, recert_deadline_quarter, quarter) %>%
  summarise(ui_earnings = sum(ui_earnings)) %>%
  ungroup() %>%
  mutate(ui_employed = ifelse(ui_earnings > 0, 1, 0),

# Calc the number of quarters since the quarter of the person's recertification deadline. Keep only values of -12 to 4. I don't really care about having UI data from more than 12 quarters prior to disenrollment, and we only have a maximum of 4 quarters' worth of post-deadline UI data available right now
  
        tau = quarter_diff(recert_deadline_quarter, quarter)) %>%
  filter(tau >= -12 & tau <= 4) 

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Estimate treatment effects

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Simple 2x2 diff-in-diff

# Create shell data frame for results

model_results <- data.frame()

for(v in c('ui_earnings', 'ui_employed')){
  
# Create a dummy var to indicate the post-treatment time period

model_data <- dt %>%
  mutate(post = ifelse(tau > 0, 1, 0)) %>%
  
# Keep only the given outcome
  
  rename(outcome = all_of(v)) 

# Calc the simple 2x2 diff-in-diff inputs

mean_pre_treat <- mean(model_data$outcome[model_data$treat == 1 & model_data$post == 0], na.rm = TRUE)
mean_post_treat <- mean(model_data$outcome[model_data$treat == 1 & model_data$post == 1], na.rm = TRUE)
mean_pre_control <- mean(model_data$outcome[model_data$treat == 0 & model_data$post == 0], na.rm = TRUE)
mean_post_control <- mean(model_data$outcome[model_data$treat == 0 & model_data$post == 1], na.rm = TRUE)

# Calc the simple 2x2 diff-in-diff estimate using regression

model <- feols(outcome ~ treat*post,
                data = model_data, 
                notes = FALSE,
                vcov = "hetero")

# Add results to running table

model_results_add <- data.frame(variable = names(coef(model)),
                                effect = coef(model),
                                std_err = se(model),
                                p_value = fixest::pvalue(model)) %>%
  filter(variable == "treat:post") %>%
  select(-variable) %>%
  mutate(mean_pre_treat = mean_pre_treat, 
         mean_post_treat = mean_post_treat, 
         mean_pre_control = mean_pre_control, 
         mean_post_control = mean_post_control, 
         diff_in_diff_manual = (mean_post_treat - mean_pre_treat) - (mean_post_control - mean_pre_control), 
         outcome = v, 
         method = "Simple 2x2")

model_results <- bind_rows(model_results, model_results_add)
}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Simple event study model

for(v in c('ui_earnings', 'ui_employed')){
  
# Create a dummy var to indicate the post-treatment time period

model_data <- dt %>%
  mutate(post = ifelse(tau > 0, 1, 0),
         
# Create a time-varying dummy var for being treated in time t

        treated = ifelse(post == 1 & treat == 1, 1, 0)) %>%
  
# Keep only the given outcome
  
  rename(outcome = all_of(v)) 

#----------------------------------------------------------------------------
# Difference-in-differences version

# Run the diff-in-diff regression

model <- feols(outcome ~ treated,
                             data = model_data, 
                             vcov = "hetero")

# Add results to running table

model_results_add <- data.frame(variable = names(coef(model)),
                                effect = coef(model),
                                std_err = se(model),
                                p_value = fixest::pvalue(model)) %>%
  filter(variable == "treated") %>%
  select(-variable) %>%
  mutate(outcome = v, 
         method = "TWFE done manually")

model_results <- bind_rows(model_results, model_results_add)

#----------------------------------------------------------------------------
# Event study version

# Run regression

model <- feols(outcome ~ i(tau, treat, ref = 0),
               data = model_data,
               vcov = 'hetero')

# Store regression output

event_study_data <- data.frame(variable = names(coef(model)), 
                               effect = coef(model), 
                               std_err = se(model)) %>%
  mutate(tau = as.numeric(str_replace_all(variable, "tau::|:treat", ""))) 

# Create names for event study graph titles

if(v == 'ui_earnings'){v_title <- 'quarterly UI earnings'}
if(v == 'ui_employed'){v_title <- 'likelihood of employment'}

# Create event study graph

plot <- event_study_data %>%
  ggplot(mapping = aes(x = tau, y = effect)) +
  geom_point(aes(shape = tau == 0, fill = tau == 0)) +
  scale_shape_manual(values = c(16, 21)) +
  scale_fill_manual(values = c("black", "white")) +
  geom_errorbar(aes(x = tau, 
                ymin = effect - 1.96*std_err, 
                ymax = effect + 1.96*std_err), 
                width = 0.2) + 
  geom_hline(aes(yintercept = 0), color = "black", linetype = "solid") + 
  geom_vline(aes(xintercept = 0), color = "red", linetype = "dashed") + 
  # scale_y_continuous(breaks = seq(-2000, 2000, 500),
  #                 limits = c(-2000, 2000), 
  #                 labels = scales::dollar_format(accuracy = 1)) +
  scale_x_continuous(breaks = seq(-13, 5, 1), 
                     limits = c(-13, 5)) +
  labs(x = "Quarters since recertification deadline", y = "Treatment effect", title = paste0("Effect on ", v_title, " by time since recertification deadline")) + 
  theme_bw() + 
  theme(panel.background = element_blank(), 
        legend.position = "none",
        panel.grid.minor.y = element_blank(),
        axis.text = element_text(size = 9),
        axis.title = element_text(size = 9),
        plot.title = element_text(size = 11),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank())

ggsave(paste0(filepath, "/Tables and figures/", "did2-eventstudy-simple-fullsample", "-", v, ".png"), 
  plot = last_plot(),
  width = 7,
  height = 4)
}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Using Callaway and Sant'Anna package

for(v in c('ui_earnings', 'ui_employed')){
  
# Create a variable that records the quarter when each T group member first became treated. Make this variable = 0 for the C group members. 
  
model_data <- dt %>%
  mutate(first_treat = ifelse(treat == 1, as.numeric(substring(recert_deadline_quarter, 1, 4)) + ((as.numeric(substring(recert_deadline_quarter, 5,5)) - 1) / 4), 0),

# Recode the 'quarter' variable in the following way. This makes the 'time to event' calculation work properly in the below model.

       quarter_callsant = as.numeric(substring(quarter, 1, 4)) + ((as.numeric(substring(quarter, 5,5)) - 1) / 4)) %>%

# Keep only the given outcome
  
  rename(outcome = all_of(v)) 

# The Callaway and Sant'Anna package requires the individual ID variable to be numeric, so create a new ID variable for each person in the panel

id_xwalk <- model_data %>%
  distinct(ma_receipt_num) %>%
  mutate(id_callsant = sequence(n())) 

model_data <- model_data %>% 
  left_join(id_xwalk, by = c('ma_receipt_num'))

#----------------------------------------------------------------------------
# Difference-in-differences

# Run the regression

model <- att_gt(yname = "outcome",
                   gname = "first_treat",
                   idname = "id_callsant",
                   tname = "quarter_callsant",
                   xformla = ~1,
                   allow_unbalanced_panel = TRUE,
                   data = model_data)

# Add results to running table

model_stats <- aggte(model, type = "simple", na.rm = TRUE)

effect <- as.data.frame(as.matrix(summary(model_stats$overall.att))) %>%
  rownames_to_column() %>%
  filter(rowname == 'Mean')
effect <- effect$V1

std_err <- as.data.frame(as.matrix(summary(model_stats$overall.se))) %>%
  rownames_to_column() %>%
  filter(rowname == 'Mean')
std_err <- std_err$V1

p_value <- 2*pnorm(-abs(effect/std_err))

model_results_add <- data.frame(effect = effect, 
                                std_err = std_err, 
                                p_value = p_value) %>%
  mutate(outcome = v, 
         method = "Callaway and Sant'Anna")

model_results <- bind_rows(model_results, model_results_add)

#----------------------------------------------------------------------------
# Event study

# Convert model outputs to event study

event_study <- aggte(model, type = "dynamic", na.rm = TRUE)

# Create names for event study graph titles

if(v == 'ui_earnings'){v_title <- 'quarterly UI earnings'}
if(v == 'ui_employed'){v_title <- 'likelihood of employment'}

# Create graph

plot <- ggdid(event_study, 
      xgap = 2,
      theming = FALSE) + 
  geom_vline(aes(xintercept = 0), color = "red", linetype = "dashed") + 
  theme_bw() + 
  # scale_y_continuous(breaks = seq(-3000, 2000, 500),
  #                   limits = c(-3000, 2000),
  #                   labels = dollar_format(accuracy = 1)) +
  scale_x_continuous(breaks = seq(-3.75, 0.75, 0.25),
                    limits = c(-3.75, 0.75), 
                    labels = c(' ', '-14', ' ', '-12', ' ', '-10', ' ', '-8', ' ', '-6', ' ', '-4', ' ', '-2', ' ', '0', ' ', '2', ' ')) +
  labs(x = "Quarters since recertification deadline", y = "Treatment effect", title = paste0("Effect on ", v_title, " by time since recertification deadline")) + 
  theme(panel.background = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position = 'none',
        plot.title = element_blank(),
        panel.grid.major.x = element_blank(),
        axis.text = element_text(size = 12),
        axis.title = element_text(size = 12)) 

ggsave(paste0(filepath, "/Tables and figures/", "did2-eventstudy-callsant-fullsample","-", v, ".png"), 
  plot = last_plot(),
  width = 7,
  height = 4)
}

# Save results

model_results_did2_full_sample <- model_results
save(model_results_did2_full_sample, file = paste0(filepath, "/Model outputs/model_results_did2_full_sample.rda"))
```

# Study idea: Isolate the effect of Medicaid eligibility using regression discontinuity with income eligibility as cutoff score

## Pull base study sample

```{r}

#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
# Import raw data

#------------------------------------------------------------------------------
# Unique Medicaid clients who were enrolled in Medicaid on April 1, 2023 

db_con <- dhs_dw(database = "ACPRD1", stored_db = TRUE, stored_creds = TRUE)

study2_base_sample_raw <- dbGetQuery(conn = db_con, 
                          statement = 
'with magi_medicaid_enrollees_04012023 as
(select distinct 
  ma_receipt_num, 
  category, 
  program_status
 from 
    ac_mh.ccbh_hc_eligibility
 where
    elig_from_date <= to_date(\'01-APR-2023\', \'DD-MON-YYYY\')
    and elig_to_date >= to_date(\'01-APR-2023\', \'DD-MON-YYYY\'))
    
select 
  a.*,
  e.mci_uniq_id, 
  e.ssn, 
  e.date_of_birth as dob_medicaid, 
  g.dob as dob_dw, 
  g.dod, 
  e.member_gender as gender_medicaid,
  g.gender_common_desc as gender_dw, 
  e.race as race_medicaid, 
  g.race_common_desc as race_dw, 
  e.education_status, 
  e.living_situation,
  e.phone_number, 
  e.address_line_1, 
  e.address_line_2, 
  e.city,
  e.state, 
  e.zip_code
from 
    magi_medicaid_enrollees_04012023 a 
    left join ac_mh.t_ahci_clients e on e.ma_receipt_num = a.ma_receipt_num
    left join dw.dim_mci_unique @DW g on g.mci_uniq_id = e.mci_uniq_id')

# Make var names lowercase

names(study2_base_sample_raw) <- tolower(names(study2_base_sample_raw))

#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
# Clean up the data

study2_base_sample <- study2_base_sample_raw %>%

# Drop the clients who have more than one Medicaid ID number associated with the same MCI unique ID. We will not use these clients in the analysis because it's difficult to discern their true identify
  
  group_by(mci_uniq_id) %>%
  mutate(count = n()) %>%
  ungroup() %>%
  filter(count == 1) %>%
  select(-count) %>%
  
# Convert dates to R date format
  
  mutate_at(vars(dob_dw, dob_medicaid, dod), ~ as.Date(substring(as.character(.), 1, 10), '%Y-%m-%d')) %>%
  
# Decode some values
  
  mutate(living_situation_desc = ifelse(living_situation == 'L70', 'Living independently',
                            ifelse(living_situation == 'L71', 'Family setting',
                            ifelse(living_situation == 'L72', 'Living dependently',
                            ifelse(living_situation == 'L73', 'Supervised setting',
                            ifelse(living_situation == 'L74', 'Restrictive setting',
                            ifelse(living_situation == 'L75', 'Homeless',
                            NA))))))) %>%
  select(-living_situation) %>%
  
# Look for discrepancies between DOB from the Medicaid table and DOB from the Golden Record table. Use the DOB from one source if it's missing in the other source. Use the DOB from the Golden Record for any mismatches.
  
  mutate(dob_match = ifelse(dob_medicaid == dob_dw, 1, 0), 
         dob = if_else(dob_match == 1, dob_medicaid, 
               if_else(is.na(dob_medicaid), dob_dw, 
               if_else(is.na(dob_dw), dob_medicaid, 
               NA)))) %>%
  select(-dob_medicaid, -dob_dw, -dob_match) %>%
  
#------------------------------------------------------------------------------
# Look for discrepancies between gender from the Medicaid table and gender from the Golden Record table. Use the gender from one source if it's missing in the other source. Use the gender from the Golden Record table for any mismatches
  
  mutate(gender_medicaid = ifelse(gender_medicaid == 'M', 'Male', 
                           ifelse(gender_medicaid == 'F', 'Female', 
                           NA)), 
         gender_dw = ifelse(gender_dw == '1~Male', 'Male', 
                     ifelse(gender_dw == '2~Female', 'Female', 
                     NA)), 
         gender_match = ifelse(gender_medicaid == gender_dw, 1, 0),
         gender = if_else(gender_match == 1, gender_medicaid, 
                  if_else(is.na(gender_medicaid), gender_dw, 
                  if_else(is.na(gender_dw), gender_medicaid, 
               NA)))) %>%
  select(-gender_medicaid, -gender_dw, -gender_match) %>%
  
#------------------------------------------------------------------------------
# Look for discrepancies between race from the Medicaid table and race from the Golden Record table. Use the race from one source if it's missing in the other source. Use the race from the Golden Record table for any mismatches
  
  mutate(race_medicaid = ifelse(race_medicaid == 'W', 'White', 
                         ifelse(race_medicaid == 'B', 'Black', 
                         ifelse(race_medicaid %in% c('A', 'O'), 'Other', 
                         NA))),
         race_dw = ifelse(race_dw == "1~White", 'White', 
                   ifelse(race_dw == "2~Black/African American", 'Black', 
                   ifelse(race_dw %in% c("3~American Indian/Alaskan Native", "4~Asian", "5~Native Hawaiian/Pacific Islander", "6~Two or More Races", "7~Other Single Race"), 'Other', 
                   NA))),
         race_match = ifelse(race_medicaid == race_dw, 1, 0),
         race = if_else(race_match == 1, race_medicaid, 
                if_else(is.na(race_medicaid), race_dw, 
                if_else(is.na(race_dw), race_medicaid, 
                NA)))) %>%
  select(-race_medicaid, -race_dw, -race_match) 
  
#------------------------------------------------------------------------------
# Group individuals together into households using phone number and address, assigning a unique ID to each household
  
household_ids <- study2_base_sample %>%
  distinct(phone_number, address_line_1, address_line_2, city, state, zip_code) %>%
  
# Only use the obs that have non-missing values of phone number and address
  
  filter(!is.na(phone_number) & !is.na(address_line_1) & !is.na(city) & !is.na(state) & !is.na(zip_code)) %>%
  
# Create a household-level ID
  
  mutate(household_id = sequence(n()))

study2_base_sample <- study2_base_sample %>%
  left_join(household_ids, by = c('phone_number', 'address_line_1', 'address_line_2', 'city', 'state', 'zip_code'))
  
# Save data

save(study2_base_sample, file = paste0(filepath, "/Data/Sample demographics/study2_base_sample.rda"))
```

## Examine breakdown of disenrollment reasons among base sample

```{r}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample 

load(file = paste0(filepath, "/Data/Sample demographics/study2_base_sample.rda"))

# Medicaid disenrollments during unwinding year

load(file = paste0(filepath, "/Data/Medicaid enrollment data/unwinding_disenrollments.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

# Isolate the people who were on MG 91 Medicaid as of 4/1/2023

dt <- study2_base_sample %>%
  filter(category == 'MG' & program_status == '91') %>%
  distinct(ma_receipt_num) %>%
  
# Pull in the termination reasons for this group
  
  inner_join(unwinding_disenrollments, by = c('ma_receipt_num')) %>%
  
# Count the frequency of disenrollments by reason
  
  mutate(reason = ifelse(ma_term_reason_code %in% c('042', '966', '033', '001', '063', '056', '064'), ma_term_reason_desc, 'Other assorted reasons')) %>%
  group_by(reason) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  mutate(pct_of_total = percent(count / sum(count), accuracy = 0.1)) %>%
  select(reason, pct_of_total)
  
#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Latex table
  
kable_table <- dt %>%
kbl(caption = 'Reasons for unwinding disenrollment among people who were enrolled in income-based Medicaid as of 4/1/2023', 
      col.names = c('Reason for disenrollment', '% of all disenrollments'), 
      format.args = list(big.mark = ','), 
      align = c('l', 'l'),
      linesep = "",
    format = 'latex',
      booktabs = T) %>%
  kable_styling(latex_options = c('HOLD_position')) 

writeLines(kable_table)
```

## Distribution of household-level UI earnings for working-age base sample members who had a Medicaid disenrollment during unwinding year versus those who did not

### Using total household earnings from the 4 quarters prior to the quarter of the person's unwinding recert deadline

#### Looking only at MAGI-reason disenrollments

```{r}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample 

load(file = paste0(filepath, "/Data/Sample demographics/study2_base_sample.rda"))

# UI earnings for base sample

load(file = paste0(filepath, "/Data/PA unemployment insurance data/ui_earnings.rda"))

# Medicaid disenrollments during unwinding year

load(file = paste0(filepath, "/Data/Medicaid enrollment data/unwinding_disenrollments.rda"))

# Medicaid recertification deadlines during unwinding year

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_recert_deadlines.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

# Remove households that don't have at least one person with MG 91 Medicaid

dt <- study2_base_sample %>%
  mutate(mg91 = ifelse(category == 'MG' & program_status == '91', 1, 0)) %>%
  filter(!is.na(household_id)) %>%
  group_by(household_id) %>%
  mutate(has_mg91 = sum(mg91)) %>%
  ungroup() %>%
  filter(has_mg91 == 1) %>%
  select(ma_receipt_num, household_id, mg91) %>%

# Count the number of people in each Medicaid household. Omit people who could not be grouped into households due to data limitations

  group_by(household_id) %>%
  mutate(hh_size = n()) %>%
  ungroup() %>%
  
# Pull in each person's earliest unwinding recert deadline
  
  inner_join(medicaid_recert_deadlines %>%
             filter(recert_deadline >= as.Date('2023-04-01') & recert_deadline <= as.Date('2024-04-01')) %>%
             group_by(ma_receipt_num) %>%
             top_n(-1, recert_deadline) %>%
             distinct(ma_receipt_num, recert_deadline), 
             by = c('ma_receipt_num')) %>%
  mutate(recert_deadline_quarter = str_remove(paste0(year(recert_deadline), quarters(recert_deadline)), "Q")) %>%

# Pull in the UI data for everyone in the household

  inner_join(ui_earnings %>%
             select(ma_receipt_num, quarter, ui_earnings), 
             by = c('ma_receipt_num')) %>%
  
# Keep only the UI obs that are from the 4 quarters prior to the quarter of the person's unwinding recert deadline
  
  mutate(tau = quarter_diff(recert_deadline_quarter, quarter)) %>%
  filter(tau >= -4 & tau <= -1) %>%
  
# Keep only the sample members who have UI data on file for all 4 of these quarters
  
  group_by(ma_receipt_num, household_id, hh_size, tau) %>%
  summarise(earnings = sum(ui_earnings)) %>%
  group_by(ma_receipt_num) %>%
  mutate(obs_count = n()) %>%
  ungroup() %>%
  filter(obs_count == 4) %>%
  
# Roll up the total earnings by household
  
  group_by(household_id, hh_size) %>%
  mutate(hh_earnings = sum(earnings)) %>%
  ungroup() %>%
  distinct(ma_receipt_num, household_id, hh_size, hh_earnings) %>%
  
# Keep only the people who were between 25 and 60 years old as of 4/1/2023 and were on MG 91 Medicaid
  
  inner_join(study2_base_sample %>%
             select(ma_receipt_num, dob, category, program_status), 
             by = c('ma_receipt_num')) %>%
  mutate(age_asof_04012023 = trunc((dob %--% as.Date('2023-04-01')) / years(1))) %>%
  filter(age_asof_04012023 >= 25 & age_asof_04012023 <= 60 & category == 'MG' & program_status == '91') %>%
  
# Cap earnings at $80,000 for the histogram
  
  mutate(hh_earnings = pmin(hh_earnings, 80000)) %>%
  
# Pull in the data on MAGI-reason disenrollments during unwinding year. Retain the sample members who did not have a MAGI-reason disenrollment 
  
  left_join(unwinding_disenrollments %>%
            filter(reason_code == '966'), 
            by = c('ma_receipt_num')) %>%
  mutate(treat = ifelse(!is.na(disenroll_date), 'Disenrolled during unwinding due to income inelig.', 'Not disenrolled during unwinding due to income inelig.')) 

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create graphs

#----------------------------------------------------------------------------
# Among 1-person households
  
dt %>%
  filter(hh_size == 1) %>%
ggplot(aes(x = hh_earnings, group = treat, colour = treat)) +
  geom_density(linewidth = 1) +
  geom_segment(aes(x = 19391, xend = 19391, y = 0, yend = 0.000075),
              linetype = "dashed", color = "red") +
  annotate("text", x = 19391, y = 0.000078, label = "Income limit for 1-person HH = $19,391", size = 3) +
  scale_x_continuous(breaks = seq(0, 80000, 8000),
                     limits = c(0, 80000), 
                     labels = c('$0', '$8k', '$16k', '$24k', '$32k', '$40k', '$48k', '$56k', '$64k', '$72k', '$80k+')) +
  # scale_y_continuous(breaks = seq(0,1,0.1),
  #                    limits = c(0,1),
  #                    labels = scales::percent_format(accuracy = 1)) +
  theme_bw() +
  labs(title = "Distribution of total household-level earnings in the 4 quarters prior to the person's unwinding recert deadline, among working-age adults who were\nenrolled in MAGI Medicaid as of 4/1/2023, comparing those who were subsequently disenrolled due to\nincome ineligibility versus those who were not, looking only at 1-person households",
       x = "Total household UI earnings in 4 quarters prior to recert deadline",
       y = "Density") + 
      guides(color = guide_legend(nrow = 2)) + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        plot.title = element_text(size = 10),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study2-tauminus4-earnings-comparison-magi-disenroll-hh1.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)

#----------------------------------------------------------------------------
# Among 2-person households
  
dt %>%
  filter(hh_size == 2) %>%
ggplot(aes(x = hh_earnings, group = treat, colour = treat)) +
  geom_density(linewidth = 1) +
    geom_segment(aes(x = 26238, xend = 26238, y = 0, yend = 0.000075),
              linetype = "dashed", color = "red") +
  annotate("text", x = 26238, y = 0.000078, label = "Income limit for 2-person HH = $26,238", size = 3) +
  scale_x_continuous(breaks = seq(0, 80000, 8000),
                     limits = c(0, 80000), 
                     labels = c('$0', '$8k', '$16k', '$24k', '$32k', '$40k', '$48k', '$56k', '$64k', '$72k', '$80k+')) +
  # scale_y_continuous(breaks = seq(0,1,0.1),
  #                    limits = c(0,1),
  #                    labels = scales::percent_format(accuracy = 1)) +
  theme_bw() +
  labs(title = "Distribution of total household-level earnings in the 4 quarters prior to the person's unwinding recert deadline, among working-age adults who were\nenrolled in MAGI Medicaid as of 4/1/2023, comparing those who were subsequently disenrolled due to\nincome ineligibility versus those who were not, looking only at 2-person households",
       x = "Total household UI earnings in 4 quarters prior to recert deadline",
       y = "Density") + 
      guides(color = guide_legend(nrow = 2)) + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        plot.title = element_text(size = 10),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study2-tauminus4-earnings-comparison-magi-disenroll-hh2.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)

#----------------------------------------------------------------------------
# Among 3-person households
  
dt %>%
  filter(hh_size == 3) %>%
ggplot(aes(x = hh_earnings, group = treat, colour = treat)) +
  geom_density(linewidth = 1) +
    geom_segment(aes(x = 33069, xend = 33069, y = 0, yend = 0.000075),
              linetype = "dashed", color = "red") +
  annotate("text", x = 33069, y = 0.000078, label = "Income limit for 3-person HH = $33,069", size = 3) +
  scale_x_continuous(breaks = seq(0, 80000, 8000),
                     limits = c(0, 80000), 
                     labels = c('$0', '$8k', '$16k', '$24k', '$32k', '$40k', '$48k', '$56k', '$64k', '$72k', '$80k+')) +
  # scale_y_continuous(breaks = seq(0,1,0.1),
  #                    limits = c(0,1),
  #                    labels = scales::percent_format(accuracy = 1)) +
  theme_bw() +
  labs(title = "Distribution of total household-level earnings in the 4 quarters prior to the person's unwinding recert deadline, among working-age adults who were\nenrolled in MAGI Medicaid as of 4/1/2023, comparing those who were subsequently disenrolled due to\nincome ineligibility versus those who were not, looking only at 3-person households",
       x = "Total household UI earnings in 4 quarters prior to recert deadline",
       y = "Density") + 
      guides(color = guide_legend(nrow = 2)) + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        plot.title = element_text(size = 10),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study2-tauminus4-earnings-comparison-magi-disenroll-hh3.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)

#----------------------------------------------------------------------------
# Among 4-person households
  
dt %>%
  filter(hh_size == 4) %>%
ggplot(aes(x = hh_earnings, group = treat, colour = treat)) +
  geom_density(linewidth = 1) +
    geom_segment(aes(x = 39900, xend = 39900, y = 0, yend = 0.000075),
              linetype = "dashed", color = "red") +
  annotate("text", x = 39900, y = 0.000078, label = "Income limit for 4-person HH = $39,900", size = 3) +
  scale_x_continuous(breaks = seq(0, 80000, 8000),
                     limits = c(0, 80000), 
                     labels = c('$0', '$8k', '$16k', '$24k', '$32k', '$40k', '$48k', '$56k', '$64k', '$72k', '$80k+')) +
  # scale_y_continuous(breaks = seq(0,1,0.1),
  #                    limits = c(0,1),
  #                    labels = scales::percent_format(accuracy = 1)) +
  theme_bw() +
  labs(title = "Distribution of total household-level earnings in the 4 quarters prior to the person's unwinding recert deadline, among working-age adults who were\nenrolled in MAGI Medicaid as of 4/1/2023, comparing those who were subsequently disenrolled due to\nincome ineligibility versus those who were not, looking only at 4-person households",
       x = "Total household UI earnings in 4 quarters prior to recert deadline",
       y = "Density") + 
      guides(color = guide_legend(nrow = 2)) + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        plot.title = element_text(size = 10),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study2-tauminus4-earnings-comparison-magi-disenroll-hh4.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)
```

#### Looking at MAGI-reason and procedural disenrollments

```{r}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample 

load(file = paste0(filepath, "/Data/Sample demographics/study2_base_sample.rda"))

# UI earnings for base sample

load(file = paste0(filepath, "/Data/PA unemployment insurance data/ui_earnings.rda"))

# Medicaid disenrollments during unwinding year

load(file = paste0(filepath, "/Data/Medicaid enrollment data/unwinding_disenrollments.rda"))

# Medicaid recertification deadlines during unwinding year

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_recert_deadlines.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

# Remove households that don't have at least one person with MG 91 Medicaid

dt <- study2_base_sample %>%
  mutate(mg91 = ifelse(category == 'MG' & program_status == '91', 1, 0)) %>%
  filter(!is.na(household_id)) %>%
  group_by(household_id) %>%
  mutate(has_mg91 = sum(mg91)) %>%
  ungroup() %>%
  filter(has_mg91 == 1) %>%
  select(ma_receipt_num, household_id, mg91) %>%

# Count the number of people in each Medicaid household. Omit people who could not be grouped into households due to data limitations

  group_by(household_id) %>%
  mutate(hh_size = n()) %>%
  ungroup() %>%
  
# Pull in each person's earliest unwinding recert deadline
  
  inner_join(medicaid_recert_deadlines %>%
             filter(recert_deadline >= as.Date('2023-04-01') & recert_deadline <= as.Date('2024-04-01')) %>%
             group_by(ma_receipt_num) %>%
             top_n(-1, recert_deadline) %>%
             distinct(ma_receipt_num, recert_deadline), 
             by = c('ma_receipt_num')) %>%
  mutate(recert_deadline_quarter = str_remove(paste0(year(recert_deadline), quarters(recert_deadline)), "Q")) %>%

# Pull in the UI data for everyone in the household

  inner_join(ui_earnings %>%
             select(ma_receipt_num, quarter, ui_earnings), 
             by = c('ma_receipt_num')) %>%
  
# Keep only the UI obs that are from the 4 quarters prior to the quarter of the person's unwinding recert deadline
  
  mutate(tau = quarter_diff(recert_deadline_quarter, quarter)) %>%
  filter(tau >= -4 & tau <= -1) %>%
  
# Keep only the sample members who have UI data on file for all 4 of these quarters
  
  group_by(ma_receipt_num, household_id, hh_size, tau) %>%
  summarise(earnings = sum(ui_earnings)) %>%
  group_by(ma_receipt_num) %>%
  mutate(obs_count = n()) %>%
  ungroup() %>%
  filter(obs_count == 4) %>%
  
# Roll up the total earnings by household
  
  group_by(household_id, hh_size) %>%
  mutate(hh_earnings = sum(earnings)) %>%
  ungroup() %>%
  distinct(ma_receipt_num, household_id, hh_size, hh_earnings) %>%
  
# Keep only the people who were between 25 and 60 years old as of 4/1/2023 and were on MG 91 Medicaid
  
  inner_join(study2_base_sample %>%
             select(ma_receipt_num, dob, category, program_status), 
             by = c('ma_receipt_num')) %>%
  mutate(age_asof_04012023 = trunc((dob %--% as.Date('2023-04-01')) / years(1))) %>%
  filter(age_asof_04012023 >= 25 & age_asof_04012023 <= 60 & category == 'MG' & program_status == '91') %>%
  
# Cap earnings at $80,000 for the histogram
  
  mutate(hh_earnings = pmin(hh_earnings, 80000)) %>%
  
# Pull in the data on MAGI-reason and procedural disenrollments during unwinding year. Retain the sample members who did not have these types of disenrollments
  
  left_join(unwinding_disenrollments %>%
            filter(reason_code %in% c('042', '966')), 
            by = c('ma_receipt_num')) %>%
  mutate(treat = ifelse(!is.na(disenroll_date), 'Disenrolled during unwinding due to income inelig. or failing to complete paperwork', 'Not disenrolled during unwinding due to income inelig. or failing to complete paperwork')) 

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create graphs

#----------------------------------------------------------------------------
# Among 1-person households
  
dt %>%
  filter(hh_size == 1) %>%
ggplot(aes(x = hh_earnings, group = treat, colour = treat)) +
  geom_density(linewidth = 1) +
  geom_segment(aes(x = 19391, xend = 19391, y = 0, yend = 0.000075),
              linetype = "dashed", color = "red") +
  annotate("text", x = 19391, y = 0.000078, label = "Income limit for 1-person HH = $19,391", size = 3) +
  scale_x_continuous(breaks = seq(0, 80000, 8000),
                     limits = c(0, 80000), 
                     labels = c('$0', '$8k', '$16k', '$24k', '$32k', '$40k', '$48k', '$56k', '$64k', '$72k', '$80k+')) +
  # scale_y_continuous(breaks = seq(0,1,0.1),
  #                    limits = c(0,1),
  #                    labels = scales::percent_format(accuracy = 1)) +
  theme_bw() +
  labs(title = "Distribution of total household-level earnings in the 4 quarters prior to the person's unwinding recert deadline, among working-age adults who were\nenrolled in MAGI Medicaid as of 4/1/2023, comparing those who were subsequently disenrolled due to\nincome ineligibility or failing to complete paperwork versus those who were not,\nlooking only at 1-person households",
       x = "Total household UI earnings in 4 quarters prior to recert deadline",
       y = "Density") + 
      guides(color = guide_legend(nrow = 2)) + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        plot.title = element_text(size = 10),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study2-tauminus4-earnings-comparison-magi-or-pd-disenroll-hh1.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)

#----------------------------------------------------------------------------
# Among 2-person households
  
dt %>%
  filter(hh_size == 2) %>%
ggplot(aes(x = hh_earnings, group = treat, colour = treat)) +
  geom_density(linewidth = 1) +
geom_segment(aes(x = 26238, xend = 26238, y = 0, yend = 0.000075),
              linetype = "dashed", color = "red") +
  annotate("text", x = 26238, y = 0.000078, label = "Income limit for 2-person HH = $26,238", size = 3) +
  scale_x_continuous(breaks = seq(0, 80000, 8000),
                     limits = c(0, 80000), 
                     labels = c('$0', '$8k', '$16k', '$24k', '$32k', '$40k', '$48k', '$56k', '$64k', '$72k', '$80k+')) +
  # scale_y_continuous(breaks = seq(0,1,0.1),
  #                    limits = c(0,1),
  #                    labels = scales::percent_format(accuracy = 1)) +
  theme_bw() +
  labs(title = "Distribution of total household-level earnings in the 4 quarters prior to the person's unwinding recert deadline, among working-age adults who were\nenrolled in MAGI Medicaid as of 4/1/2023, comparing those who were subsequently disenrolled due to\nincome ineligibility or failing to complete paperwork versus those who were not,\nlooking only at 2-person households",
       x = "Total household UI earnings in 4 quarters prior to recert deadline",
       y = "Density") + 
      guides(color = guide_legend(nrow = 2)) + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        plot.title = element_text(size = 10),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study2-tauminus4-earnings-comparison-magi-or-pd-disenroll-hh2.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)

#----------------------------------------------------------------------------
# Among 3-person households
  
dt %>%
  filter(hh_size == 3) %>%
ggplot(aes(x = hh_earnings, group = treat, colour = treat)) +
  geom_density(linewidth = 1) +
    geom_segment(aes(x = 33069, xend = 33069, y = 0, yend = 0.000075),
              linetype = "dashed", color = "red") +
  annotate("text", x = 33069, y = 0.000078, label = "Income limit for 3-person HH = $33,069", size = 3) +
  scale_x_continuous(breaks = seq(0, 80000, 8000),
                     limits = c(0, 80000), 
                     labels = c('$0', '$8k', '$16k', '$24k', '$32k', '$40k', '$48k', '$56k', '$64k', '$72k', '$80k+')) +
  # scale_y_continuous(breaks = seq(0,1,0.1),
  #                    limits = c(0,1),
  #                    labels = scales::percent_format(accuracy = 1)) +
  theme_bw() +
  labs(title = "Distribution of total household-level earnings in the 4 quarters prior to the person's unwinding recert deadline, among working-age adults who were\nenrolled in MAGI Medicaid as of 4/1/2023, comparing those who were subsequently disenrolled due to\nincome ineligibility or failing to complete paperwork versus those who were not,\nlooking only at 3-person households",
       x = "Total household UI earnings in 4 quarters prior to recert deadline",
       y = "Density") + 
      guides(color = guide_legend(nrow = 2)) + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        plot.title = element_text(size = 10),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study2-tauminus4-earnings-comparison-magi-or-pd-disenroll-hh3.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)

#----------------------------------------------------------------------------
# Among 4-person households
  
dt %>%
  filter(hh_size == 4) %>%
ggplot(aes(x = hh_earnings, group = treat, colour = treat)) +
  geom_density(linewidth = 1) +
    geom_segment(aes(x = 39900, xend = 39900, y = 0, yend = 0.000075),
              linetype = "dashed", color = "red") +
  annotate("text", x = 39900, y = 0.000078, label = "Income limit for 4-person HH = $39,900", size = 3) +
  scale_x_continuous(breaks = seq(0, 80000, 8000),
                     limits = c(0, 80000), 
                     labels = c('$0', '$8k', '$16k', '$24k', '$32k', '$40k', '$48k', '$56k', '$64k', '$72k', '$80k+')) +
  # scale_y_continuous(breaks = seq(0,1,0.1),
  #                    limits = c(0,1),
  #                    labels = scales::percent_format(accuracy = 1)) +
  theme_bw() +
  labs(title = "Distribution of total household-level earnings in the 4 quarters prior to the person's unwinding recert deadline, among working-age adults who were\nenrolled in MAGI Medicaid as of 4/1/2023, comparing those who were subsequently disenrolled due to\nincome ineligibility or failing to complete paperwork versus those who were not,\nlooking only at 4-person households",
       x = "Total household UI earnings in 4 quarters prior to recert deadline",
       y = "Density") + 
      guides(color = guide_legend(nrow = 2)) + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        plot.title = element_text(size = 10),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study2-tauminus4-earnings-comparison-magi-or-pd-disenroll-hh4.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)
```

#### Looking at all types of disenrollments

```{r}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample 

load(file = paste0(filepath, "/Data/Sample demographics/study2_base_sample.rda"))

# UI earnings for base sample

load(file = paste0(filepath, "/Data/PA unemployment insurance data/ui_earnings.rda"))

# Medicaid disenrollments during unwinding year

load(file = paste0(filepath, "/Data/Medicaid enrollment data/unwinding_disenrollments.rda"))

# Medicaid recertification deadlines during unwinding year

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_recert_deadlines.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

# Remove households that don't have at least one person with MG 91 Medicaid

dt <- study2_base_sample %>%
  mutate(mg91 = ifelse(category == 'MG' & program_status == '91', 1, 0)) %>%
  filter(!is.na(household_id)) %>%
  group_by(household_id) %>%
  mutate(has_mg91 = sum(mg91)) %>%
  ungroup() %>%
  filter(has_mg91 == 1) %>%
  select(ma_receipt_num, household_id, mg91) %>%

# Count the number of people in each Medicaid household. Omit people who could not be grouped into households due to data limitations

  group_by(household_id) %>%
  mutate(hh_size = n()) %>%
  ungroup() %>%
  
# Pull in each person's earliest unwinding recert deadline
  
  inner_join(medicaid_recert_deadlines %>%
             filter(recert_deadline >= as.Date('2023-04-01') & recert_deadline <= as.Date('2024-04-01')) %>%
             group_by(ma_receipt_num) %>%
             top_n(-1, recert_deadline) %>%
             distinct(ma_receipt_num, recert_deadline), 
             by = c('ma_receipt_num')) %>%
  mutate(recert_deadline_quarter = str_remove(paste0(year(recert_deadline), quarters(recert_deadline)), "Q")) %>%

# Pull in the UI data for everyone in the household

  inner_join(ui_earnings %>%
             select(ma_receipt_num, quarter, ui_earnings), 
             by = c('ma_receipt_num')) %>%
  
# Keep only the UI obs that are from the 4 quarters prior to the quarter of the person's unwinding recert deadline
  
  mutate(tau = quarter_diff(recert_deadline_quarter, quarter)) %>%
  filter(tau >= -4 & tau <= -1) %>%
  
# Keep only the sample members who have UI data on file for all 4 of these quarters
  
  group_by(ma_receipt_num, household_id, hh_size, tau) %>%
  summarise(earnings = sum(ui_earnings)) %>%
  group_by(ma_receipt_num) %>%
  mutate(obs_count = n()) %>%
  ungroup() %>%
  filter(obs_count == 4) %>%
  
# Roll up the total earnings by household
  
  group_by(household_id, hh_size) %>%
  mutate(hh_earnings = sum(earnings)) %>%
  ungroup() %>%
  distinct(ma_receipt_num, household_id, hh_size, hh_earnings) %>%
  
# Keep only the people who were between 25 and 60 years old as of 4/1/2023 and were on MG 91 Medicaid
  
  inner_join(study2_base_sample %>%
             select(ma_receipt_num, dob, category, program_status), 
             by = c('ma_receipt_num')) %>%
  mutate(age_asof_04012023 = trunc((dob %--% as.Date('2023-04-01')) / years(1))) %>%
  filter(age_asof_04012023 >= 25 & age_asof_04012023 <= 60 & category == 'MG' & program_status == '91') %>%
  
# Cap earnings at $80,000 for the histogram
  
  mutate(hh_earnings = pmin(hh_earnings, 80000)) %>%
  
# Pull in the data on disenrollments during unwinding year. Retain the sample members who did not have a disenrollment
  
  left_join(unwinding_disenrollments, by = c('ma_receipt_num')) %>%
  mutate(treat = ifelse(!is.na(disenroll_date), 'Disenrolled during unwinding for any reason', 'Not disenrolled during unwinding')) 

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create graphs

#----------------------------------------------------------------------------
# Among 1-person households
  
dt %>%
  filter(hh_size == 1) %>%
ggplot(aes(x = hh_earnings, group = treat, colour = treat)) +
  geom_density(linewidth = 1) +
  geom_segment(aes(x = 19391, xend = 19391, y = 0, yend = 0.000075),
              linetype = "dashed", color = "red") +
  annotate("text", x = 19391, y = 0.000078, label = "Income limit for 1-person HH = $19,391", size = 3) +
  scale_x_continuous(breaks = seq(0, 80000, 8000),
                     limits = c(0, 80000), 
                     labels = c('$0', '$8k', '$16k', '$24k', '$32k', '$40k', '$48k', '$56k', '$64k', '$72k', '$80k+')) +
  # scale_y_continuous(breaks = seq(0,1,0.1),
  #                    limits = c(0,1),
  #                    labels = scales::percent_format(accuracy = 1)) +
  theme_bw() +
  labs(title = "Distribution of total household-level earnings in the 4 quarters prior to the person's unwinding recert deadline,\n among working-age adults who were enrolled in MAGI Medicaid as of 4/1/2023, comparing those who were\nsubsequently disenrolled for any reason versus those who were not, looking only at 1-person households",
       x = "Total household UI earnings in 4 quarters prior to recert deadline",
       y = "Density") + 
      guides(color = guide_legend(nrow = 2)) + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        plot.title = element_text(size = 10),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study2-tauminus4-earnings-comparison-any-disenroll-hh1.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)

#----------------------------------------------------------------------------
# Among 2-person households
  
dt %>%
  filter(hh_size == 2) %>%
ggplot(aes(x = hh_earnings, group = treat, colour = treat)) +
  geom_density(linewidth = 1) +
geom_segment(aes(x = 26238, xend = 26238, y = 0, yend = 0.000075),
              linetype = "dashed", color = "red") +
  annotate("text", x = 26238, y = 0.000078, label = "Income limit for 2-person HH = $26,238", size = 3) +
  scale_x_continuous(breaks = seq(0, 80000, 8000),
                     limits = c(0, 80000), 
                     labels = c('$0', '$8k', '$16k', '$24k', '$32k', '$40k', '$48k', '$56k', '$64k', '$72k', '$80k+')) +
  # scale_y_continuous(breaks = seq(0,1,0.1),
  #                    limits = c(0,1),
  #                    labels = scales::percent_format(accuracy = 1)) +
  theme_bw() +
  labs(title = "Distribution of total household-level earnings in the 4 quarters prior to the person's unwinding recert deadline,\n among working-age adults who were enrolled in MAGI Medicaid as of 4/1/2023, comparing those who were\nsubsequently disenrolled for any reason versus those who were not, looking only at 2-person households",
       x = "Total household UI earnings in 4 quarters prior to recert deadline",
       y = "Density") + 
      guides(color = guide_legend(nrow = 2)) + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        plot.title = element_text(size = 10),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study2-tauminus4-earnings-comparison-any-disenroll-hh2.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)

#----------------------------------------------------------------------------
# Among 3-person households
  
dt %>%
  filter(hh_size == 3) %>%
ggplot(aes(x = hh_earnings, group = treat, colour = treat)) +
  geom_density(linewidth = 1) +
    geom_segment(aes(x = 33069, xend = 33069, y = 0, yend = 0.000075),
              linetype = "dashed", color = "red") +
  annotate("text", x = 33069, y = 0.000078, label = "Income limit for 3-person HH = $33,069", size = 3) +
  scale_x_continuous(breaks = seq(0, 80000, 8000),
                     limits = c(0, 80000), 
                     labels = c('$0', '$8k', '$16k', '$24k', '$32k', '$40k', '$48k', '$56k', '$64k', '$72k', '$80k+')) +
  # scale_y_continuous(breaks = seq(0,1,0.1),
  #                    limits = c(0,1),
  #                    labels = scales::percent_format(accuracy = 1)) +
  theme_bw() +
  labs(title = "Distribution of total household-level earnings in the 4 quarters prior to the person's unwinding recert deadline,\n among working-age adults who were enrolled in MAGI Medicaid as of 4/1/2023, comparing those who were\nsubsequently disenrolled for any reason versus those who were not, looking only at 3-person households",
       x = "Total household UI earnings in 4 quarters prior to recert deadline",
       y = "Density") + 
      guides(color = guide_legend(nrow = 2)) + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        plot.title = element_text(size = 10),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study2-tauminus4-earnings-comparison-any-disenroll-hh3.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)

#----------------------------------------------------------------------------
# Among 4-person households
  
dt %>%
  filter(hh_size == 4) %>%
ggplot(aes(x = hh_earnings, group = treat, colour = treat)) +
  geom_density(linewidth = 1) +
    geom_segment(aes(x = 39900, xend = 39900, y = 0, yend = 0.000075),
              linetype = "dashed", color = "red") +
  annotate("text", x = 39900, y = 0.000078, label = "Income limit for 4-person HH = $39,900", size = 3) +
  scale_x_continuous(breaks = seq(0, 80000, 8000),
                     limits = c(0, 80000), 
                     labels = c('$0', '$8k', '$16k', '$24k', '$32k', '$40k', '$48k', '$56k', '$64k', '$72k', '$80k+')) +
  # scale_y_continuous(breaks = seq(0,1,0.1),
  #                    limits = c(0,1),
  #                    labels = scales::percent_format(accuracy = 1)) +
  theme_bw() +
  labs(title = "Distribution of total household-level earnings in the 4 quarters prior to the person's unwinding recert deadline,\n among working-age adults who were enrolled in MAGI Medicaid as of 4/1/2023, comparing those who were\nsubsequently disenrolled for any reason versus those who were not, looking only at 4-person households",
       x = "Total household UI earnings in 4 quarters prior to recert deadline",
       y = "Density") + 
      guides(color = guide_legend(nrow = 2)) + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        plot.title = element_text(size = 10),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study2-tauminus4-earnings-comparison-any-disenroll-hh4.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)
```

## Plot household-level UI earnings for working-age base sample members against likelihood of having a disenrollment during unwinding year

### Using total household earnings from the 4 quarters prior to the quarter of the person's unwinding recert deadline

#### Looking only at MAGI-reason disenrollments

```{r}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample 

load(file = paste0(filepath, "/Data/Sample demographics/study2_base_sample.rda"))

# UI earnings for base sample

load(file = paste0(filepath, "/Data/PA unemployment insurance data/ui_earnings.rda"))

# Medicaid disenrollments during unwinding year

load(file = paste0(filepath, "/Data/Medicaid enrollment data/unwinding_disenrollments.rda"))

# Medicaid recertification deadlines during unwinding year

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_recert_deadlines.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

# Remove households that don't have at least one person with MG 91 Medicaid

dt <- study2_base_sample %>%
  mutate(mg91 = ifelse(category == 'MG' & program_status == '91', 1, 0)) %>%
  filter(!is.na(household_id)) %>%
  group_by(household_id) %>%
  mutate(has_mg91 = sum(mg91)) %>%
  ungroup() %>%
  filter(has_mg91 == 1) %>%
  select(ma_receipt_num, household_id, mg91) %>%

# Count the number of people in each Medicaid household. Omit people who could not be grouped into households due to data limitations

  group_by(household_id) %>%
  mutate(hh_size = n()) %>%
  ungroup() %>%
  
# Pull in each person's earliest unwinding recert deadline
  
  inner_join(medicaid_recert_deadlines %>%
             filter(recert_deadline >= as.Date('2023-04-01') & recert_deadline <= as.Date('2024-04-01')) %>%
             group_by(ma_receipt_num) %>%
             top_n(-1, recert_deadline) %>%
             distinct(ma_receipt_num, recert_deadline), 
             by = c('ma_receipt_num')) %>%
  mutate(recert_deadline_quarter = str_remove(paste0(year(recert_deadline), quarters(recert_deadline)), "Q")) %>%

# Pull in the UI data for everyone in the household

  inner_join(ui_earnings %>%
             select(ma_receipt_num, quarter, ui_earnings), 
             by = c('ma_receipt_num')) %>%
  
# Keep only the UI obs that are from the 4 quarters prior to the quarter of the person's unwinding recert deadline
  
  mutate(tau = quarter_diff(recert_deadline_quarter, quarter)) %>%
  filter(tau >= -4 & tau <= -1) %>%
  
# Keep only the sample members who have UI data on file for all 4 of these quarters
  
  group_by(ma_receipt_num, household_id, hh_size, tau) %>%
  summarise(earnings = sum(ui_earnings)) %>%
  group_by(ma_receipt_num) %>%
  mutate(obs_count = n()) %>%
  ungroup() %>%
  filter(obs_count == 4) %>%
  
# Roll up the total earnings by household
  
  group_by(household_id, hh_size) %>%
  mutate(hh_earnings = sum(earnings)) %>%
  ungroup() %>%
  distinct(ma_receipt_num, household_id, hh_size, hh_earnings) %>%
  
# Keep only the people who were between 25 and 60 years old as of 4/1/2023 and were on MG 91 Medicaid
  
  inner_join(study2_base_sample %>%
             select(ma_receipt_num, dob, category, program_status), 
             by = c('ma_receipt_num')) %>%
  mutate(age_asof_04012023 = trunc((dob %--% as.Date('2023-04-01')) / years(1))) %>%
  filter(age_asof_04012023 >= 25 & age_asof_04012023 <= 60 & category == 'MG' & program_status == '91') %>%
  
# Cap earnings at $80,000 for the histogram
  
  mutate(hh_earnings = pmin(hh_earnings, 80000)) %>%
  
# Pull in the data on MAGI-reason disenrollments during unwinding year. Retain the sample members who did not have a MAGI-reason disenrollment 
  
  left_join(unwinding_disenrollments %>%
            filter(reason_code == '966'), 
            by = c('ma_receipt_num')) %>%
  mutate(treat = ifelse(!is.na(disenroll_date), 1, 0)) %>%
  
# Calc the mean likelihood of being treated by earnings bin and by household size
  
    mutate(bin = ifelse(hh_earnings <= 80000, cut(hh_earnings, breaks = seq(1, 80000, 1000), right = TRUE, labels = FALSE), 81),
          bin = replace_na(bin, 0)) %>%
  group_by(hh_size, bin) %>%
  summarise(pct_treat = mean(treat)) %>%
  ungroup()

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create graphs

#----------------------------------------------------------------------------
# Among 1-person households
  
dt %>%
  filter(hh_size == 1) %>%
ggplot(aes(x = bin, y = pct_treat)) +
  geom_line() +
  #geom_bar(stat = "identity", colour = 'black', position = position_nudge(x = 1)) + 
  geom_segment(aes(x = 21, xend = 21, y = 0, yend = 0.8),
              linetype = "dashed", color = "red") +
  annotate("text", x = 21, y = 0.83, label = "Income limit for 1-person HH = $19,391", size = 3) +
  scale_x_continuous(breaks = seq(0, 81, 1),
                     limits = c(-1,82), 
                     labels = c(' ', '$0', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$8k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$16k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$24k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$32k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$40k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$48k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$56k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$64k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$72k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$80k+')) +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  theme_bw() +
  labs(title = "Total household-level earnings in the 4 quarters prior to the person's unwinding recert deadline,\namong working-age adults who were enrolled in Medicaid as of 4/1/2023, plotted against likelihood of being\ndisenrolled due to income ineligibility, looking only at 1-person households",
       x = "Total household UI earnings in 4 quarters prior to recert deadline",
       y = "Likelihood of being disenrolled") + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        plot.title = element_text(size = 10),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study2-tauminus4-earnings-distrib-magi-disenroll-hh1.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)

#----------------------------------------------------------------------------
# Among 2-person households
  
dt %>%
  filter(hh_size == 2) %>%
ggplot(aes(x = bin, y = pct_treat)) +
  geom_line() +
  #geom_bar(stat = "identity", colour = 'black', position = position_nudge(x = 1)) + 
  geom_segment(aes(x = 27, xend = 27, y = 0, yend = 0.8),
              linetype = "dashed", color = "red") +
  annotate("text", x = 27, y = 0.83, label = "Income limit for 2-person HH = $26,238", size = 3) +
  scale_x_continuous(breaks = seq(0, 81, 1),
                     limits = c(-1,82), 
                     labels = c(' ', '$0', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$8k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$16k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$24k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$32k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$40k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$48k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$56k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$64k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$72k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$80k+')) +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  theme_bw() +
  labs(title = "Total household-level earnings in the 4 quarters prior to the person's unwinding recert deadline,\namong working-age adults who were enrolled in Medicaid as of 4/1/2023, plotted against likelihood of being\ndisenrolled due to income ineligibility, looking only at 2-person households",
       x = "Total household UI earnings in 4 quarters prior to recert deadline",
       y = "Likelihood of being disenrolled") + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        plot.title = element_text(size = 10),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study2-tauminus4-earnings-distrib-magi-disenroll-hh2.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)

#----------------------------------------------------------------------------
# Among 3-person households
  
dt %>%
  filter(hh_size == 3) %>%
ggplot(aes(x = bin, y = pct_treat)) +
  geom_line() +
  #geom_bar(stat = "identity", colour = 'black', position = position_nudge(x = 1)) + 
  geom_segment(aes(x = 35, xend = 35, y = 0, yend = 0.8),
              linetype = "dashed", color = "red") +
  annotate("text", x = 35, y = 0.83, label = "Income limit for 3-person HH = $33,069", size = 3) +
  scale_x_continuous(breaks = seq(0, 81, 1),
                     limits = c(-1,82), 
                     labels = c(' ', '$0', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$8k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$16k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$24k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$32k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$40k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$48k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$56k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$64k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$72k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$80k+')) +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  theme_bw() +
  labs(title = "Total household-level earnings in the 4 quarters prior to the person's unwinding recert deadline,\namong working-age adults who were enrolled in Medicaid as of 4/1/2023, plotted against likelihood of being\ndisenrolled due to income ineligibility, looking only at 3-person households",
       x = "Total household UI earnings in 4 quarters prior to recert deadline",
       y = "Likelihood of being disenrolled") + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        plot.title = element_text(size = 10),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study2-tauminus4-earnings-distrib-magi-disenroll-hh3.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)

#----------------------------------------------------------------------------
# Among 4-person households
  
dt %>%
  filter(hh_size == 4) %>%
ggplot(aes(x = bin, y = pct_treat)) +
  geom_line() +
  #geom_bar(stat = "identity", colour = 'black', position = position_nudge(x = 1)) + 
  geom_segment(aes(x = 41, xend = 41, y = 0, yend = 0.8),
              linetype = "dashed", color = "red") +
  annotate("text", x = 41, y = 0.83, label = "Income limit for 4-person HH = $39,900", size = 3) +
  scale_x_continuous(breaks = seq(0, 81, 1),
                     limits = c(-1,82), 
                     labels = c(' ', '$0', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$8k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$16k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$24k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$32k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$40k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$48k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$56k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$64k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$72k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$80k+')) +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  theme_bw() +
  labs(title = "Total household-level earnings in the 4 quarters prior to the person's unwinding recert deadline,\namong working-age adults who were enrolled in Medicaid as of 4/1/2023, plotted against likelihood of being\ndisenrolled due to income ineligibility, looking only at 4-person households",
       x = "Total household UI earnings in 4 quarters prior to recert deadline",
       y = "Likelihood of being disenrolled") + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        plot.title = element_text(size = 10),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study2-tauminus4-earnings-distrib-magi-disenroll-hh4.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)
```

#### Looking at MAGI-reason and procedural disenrollments

```{r}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample 

load(file = paste0(filepath, "/Data/Sample demographics/study2_base_sample.rda"))

# UI earnings for base sample

load(file = paste0(filepath, "/Data/PA unemployment insurance data/ui_earnings.rda"))

# Medicaid disenrollments during unwinding year

load(file = paste0(filepath, "/Data/Medicaid enrollment data/unwinding_disenrollments.rda"))

# Medicaid recertification deadlines during unwinding year

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_recert_deadlines.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

# Remove households that don't have at least one person with MG 91 Medicaid

dt <- study2_base_sample %>%
  mutate(mg91 = ifelse(category == 'MG' & program_status == '91', 1, 0)) %>%
  filter(!is.na(household_id)) %>%
  group_by(household_id) %>%
  mutate(has_mg91 = sum(mg91)) %>%
  ungroup() %>%
  filter(has_mg91 == 1) %>%
  select(ma_receipt_num, household_id, mg91) %>%

# Count the number of people in each Medicaid household. Omit people who could not be grouped into households due to data limitations

  group_by(household_id) %>%
  mutate(hh_size = n()) %>%
  ungroup() %>%
  
# Pull in each person's earliest unwinding recert deadline
  
  inner_join(medicaid_recert_deadlines %>%
             filter(recert_deadline >= as.Date('2023-04-01') & recert_deadline <= as.Date('2024-04-01')) %>%
             group_by(ma_receipt_num) %>%
             top_n(-1, recert_deadline) %>%
             distinct(ma_receipt_num, recert_deadline), 
             by = c('ma_receipt_num')) %>%
  mutate(recert_deadline_quarter = str_remove(paste0(year(recert_deadline), quarters(recert_deadline)), "Q")) %>%

# Pull in the UI data for everyone in the household

  inner_join(ui_earnings %>%
             select(ma_receipt_num, quarter, ui_earnings), 
             by = c('ma_receipt_num')) %>%
  
# Keep only the UI obs that are from the 4 quarters prior to the quarter of the person's unwinding recert deadline
  
  mutate(tau = quarter_diff(recert_deadline_quarter, quarter)) %>%
  filter(tau >= -4 & tau <= -1) %>%
  
# Keep only the sample members who have UI data on file for all 4 of these quarters
  
  group_by(ma_receipt_num, household_id, hh_size, tau) %>%
  summarise(earnings = sum(ui_earnings)) %>%
  group_by(ma_receipt_num) %>%
  mutate(obs_count = n()) %>%
  ungroup() %>%
  filter(obs_count == 4) %>%
  
# Roll up the total earnings by household
  
  group_by(household_id, hh_size) %>%
  mutate(hh_earnings = sum(earnings)) %>%
  ungroup() %>%
  distinct(ma_receipt_num, household_id, hh_size, hh_earnings) %>%
  
# Keep only the people who were between 25 and 60 years old as of 4/1/2023 and were on MG 91 Medicaid
  
  inner_join(study2_base_sample %>%
             select(ma_receipt_num, dob, category, program_status), 
             by = c('ma_receipt_num')) %>%
  mutate(age_asof_04012023 = trunc((dob %--% as.Date('2023-04-01')) / years(1))) %>%
  filter(age_asof_04012023 >= 25 & age_asof_04012023 <= 60 & category == 'MG' & program_status == '91') %>%
  
# Cap earnings at $80,000 for the histogram
  
  mutate(hh_earnings = pmin(hh_earnings, 80000)) %>%
  
# Pull in the data on MAGI-reason and procedural disenrollments during unwinding year. Retain the sample members who did not have these types of disenrollments
  
  left_join(unwinding_disenrollments %>%
            filter(reason_code %in% c('042', '966')), 
            by = c('ma_receipt_num')) %>%
  mutate(treat = ifelse(!is.na(disenroll_date), 1, 0)) %>%
  
# Calc the mean likelihood of being treated by earnings bin and by household size
  
    mutate(bin = ifelse(hh_earnings <= 80000, cut(hh_earnings, breaks = seq(1, 80000, 1000), right = TRUE, labels = FALSE), 81),
          bin = replace_na(bin, 0)) %>%
  group_by(hh_size, bin) %>%
  summarise(pct_treat = mean(treat)) %>%
  ungroup()

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create graphs

#----------------------------------------------------------------------------
# Among 1-person households
  
dt %>%
  filter(hh_size == 1) %>%
ggplot(aes(x = bin, y = pct_treat)) +
  geom_line() +
  #geom_bar(stat = "identity", colour = 'black', position = position_nudge(x = 1)) + 
  geom_segment(aes(x = 21, xend = 21, y = 0, yend = 0.8),
              linetype = "dashed", color = "red") +
  annotate("text", x = 21, y = 0.83, label = "Income limit for 1-person HH = $19,391", size = 3) +
  scale_x_continuous(breaks = seq(0, 81, 1),
                     limits = c(-1,82), 
                     labels = c(' ', '$0', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$8k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$16k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$24k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$32k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$40k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$48k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$56k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$64k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$72k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$80k+')) +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  theme_bw() +
  labs(title = "Total household-level earnings in the 4 quarters prior to the person's unwinding recert deadline,\namong working-age adults who were enrolled in Medicaid as of 4/1/2023, plotted against likelihood of being\ndisenrolled due to income ineligibility or failing to complete paperwork, looking only at 1-person households",
       x = "Total household UI earnings in 4 quarters prior to recert deadline",
       y = "Likelihood of being disenrolled") + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        plot.title = element_text(size = 10),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study2-tauminus4-earnings-distrib-magi-or-pd-disenroll-hh1.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)

#----------------------------------------------------------------------------
# Among 2-person households
  
dt %>%
  filter(hh_size == 2) %>%
ggplot(aes(x = bin, y = pct_treat)) +
  geom_line() +
  #geom_bar(stat = "identity", colour = 'black', position = position_nudge(x = 1)) + 
  geom_segment(aes(x = 27, xend = 27, y = 0, yend = 0.8),
              linetype = "dashed", color = "red") +
  annotate("text", x = 27, y = 0.83, label = "Income limit for 2-person HH = $26,238", size = 3) +
  scale_x_continuous(breaks = seq(0, 81, 1),
                     limits = c(-1,82), 
                     labels = c(' ', '$0', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$8k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$16k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$24k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$32k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$40k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$48k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$56k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$64k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$72k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$80k+')) +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  theme_bw() +
  labs(title = "Total household-level earnings in the 4 quarters prior to the person's unwinding recert deadline,\namong working-age adults who were enrolled in Medicaid as of 4/1/2023, plotted against likelihood of being\ndisenrolled due to income ineligibility or failing to complete paperwork, looking only at 2-person households",
       x = "Total household UI earnings in 4 quarters prior to recert deadline",
       y = "Likelihood of being disenrolled") + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        plot.title = element_text(size = 10),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study2-tauminus4-earnings-distrib-magi-or-pd-disenroll-hh2.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)

#----------------------------------------------------------------------------
# Among 3-person households
  
dt %>%
  filter(hh_size == 3) %>%
ggplot(aes(x = bin, y = pct_treat)) +
  geom_line() +
  #geom_bar(stat = "identity", colour = 'black', position = position_nudge(x = 1)) + 
  geom_segment(aes(x = 35, xend = 35, y = 0, yend = 0.8),
              linetype = "dashed", color = "red") +
  annotate("text", x = 35, y = 0.83, label = "Income limit for 3-person HH = $33,069", size = 3) +
  scale_x_continuous(breaks = seq(0, 81, 1),
                     limits = c(-1,82), 
                     labels = c(' ', '$0', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$8k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$16k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$24k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$32k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$40k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$48k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$56k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$64k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$72k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$80k+')) +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  theme_bw() +
  labs(title = "Total household-level earnings in the 4 quarters prior to the person's unwinding recert deadline,\namong working-age adults who were enrolled in Medicaid as of 4/1/2023, plotted against likelihood of being\ndisenrolled due to income ineligibility or failing to complete paperwork, looking only at 3-person households",
       x = "Total household UI earnings in 4 quarters prior to recert deadline",
       y = "Likelihood of being disenrolled") + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        plot.title = element_text(size = 10),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study2-tauminus4-earnings-distrib-magi-or-pd-disenroll-hh3.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)

#----------------------------------------------------------------------------
# Among 4-person households
  
dt %>%
  filter(hh_size == 4) %>%
ggplot(aes(x = bin, y = pct_treat)) +
  geom_line() +
  #geom_bar(stat = "identity", colour = 'black', position = position_nudge(x = 1)) + 
  geom_segment(aes(x = 41, xend = 41, y = 0, yend = 0.8),
              linetype = "dashed", color = "red") +
  annotate("text", x = 41, y = 0.83, label = "Income limit for 4-person HH = $39,900", size = 3) +
  scale_x_continuous(breaks = seq(0, 81, 1),
                     limits = c(-1,82), 
                     labels = c(' ', '$0', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$8k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$16k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$24k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$32k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$40k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$48k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$56k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$64k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$72k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$80k+')) +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  theme_bw() +
  labs(title = "Total household-level earnings in the 4 quarters prior to the person's unwinding recert deadline,\namong working-age adults who were enrolled in Medicaid as of 4/1/2023, plotted against likelihood of being\ndisenrolled due to income ineligibility or failing to complete paperwork, looking only at 4-person households",
       x = "Total household UI earnings in 4 quarters prior to recert deadline",
       y = "Likelihood of being disenrolled") + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        plot.title = element_text(size = 10),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study2-tauminus4-earnings-distrib-magi-or-pd-disenroll-hh4.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)
```

#### Looking at all types of disenrollments

```{r}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample 

load(file = paste0(filepath, "/Data/Sample demographics/study2_base_sample.rda"))

# UI earnings for base sample

load(file = paste0(filepath, "/Data/PA unemployment insurance data/ui_earnings.rda"))

# Medicaid disenrollments during unwinding year

load(file = paste0(filepath, "/Data/Medicaid enrollment data/unwinding_disenrollments.rda"))

# Medicaid recertification deadlines during unwinding year

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_recert_deadlines.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

# Remove households that don't have at least one person with MG 91 Medicaid

dt <- study2_base_sample %>%
  mutate(mg91 = ifelse(category == 'MG' & program_status == '91', 1, 0)) %>%
  filter(!is.na(household_id)) %>%
  group_by(household_id) %>%
  mutate(has_mg91 = sum(mg91)) %>%
  ungroup() %>%
  filter(has_mg91 == 1) %>%
  select(ma_receipt_num, household_id, mg91) %>%

# Count the number of people in each Medicaid household. Omit people who could not be grouped into households due to data limitations

  group_by(household_id) %>%
  mutate(hh_size = n()) %>%
  ungroup() %>%
  
# Pull in each person's earliest unwinding recert deadline
  
  inner_join(medicaid_recert_deadlines %>%
             filter(recert_deadline >= as.Date('2023-04-01') & recert_deadline <= as.Date('2024-04-01')) %>%
             group_by(ma_receipt_num) %>%
             top_n(-1, recert_deadline) %>%
             distinct(ma_receipt_num, recert_deadline), 
             by = c('ma_receipt_num')) %>%
  mutate(recert_deadline_quarter = str_remove(paste0(year(recert_deadline), quarters(recert_deadline)), "Q")) %>%

# Pull in the UI data for everyone in the household

  inner_join(ui_earnings %>%
             select(ma_receipt_num, quarter, ui_earnings), 
             by = c('ma_receipt_num')) %>%
  
# Keep only the UI obs that are from the 4 quarters prior to the quarter of the person's unwinding recert deadline
  
  mutate(tau = quarter_diff(recert_deadline_quarter, quarter)) %>%
  filter(tau >= -4 & tau <= -1) %>%
  
# Keep only the sample members who have UI data on file for all 4 of these quarters
  
  group_by(ma_receipt_num, household_id, hh_size, tau) %>%
  summarise(earnings = sum(ui_earnings)) %>%
  group_by(ma_receipt_num) %>%
  mutate(obs_count = n()) %>%
  ungroup() %>%
  filter(obs_count == 4) %>%
  
# Roll up the total earnings by household
  
  group_by(household_id, hh_size) %>%
  mutate(hh_earnings = sum(earnings)) %>%
  ungroup() %>%
  distinct(ma_receipt_num, household_id, hh_size, hh_earnings) %>%
  
# Keep only the people who were between 25 and 60 years old as of 4/1/2023 and were on MG 91 Medicaid
  
  inner_join(study2_base_sample %>%
             select(ma_receipt_num, dob, category, program_status), 
             by = c('ma_receipt_num')) %>%
  mutate(age_asof_04012023 = trunc((dob %--% as.Date('2023-04-01')) / years(1))) %>%
  filter(age_asof_04012023 >= 25 & age_asof_04012023 <= 60 & category == 'MG' & program_status == '91') %>%
  
# Cap earnings at $80,000 for the histogram
  
  mutate(hh_earnings = pmin(hh_earnings, 80000)) %>%
  
# Pull in the data on disenrollments during unwinding year. Retain the sample members who did not have a disenrollment
  
  left_join(unwinding_disenrollments, by = c('ma_receipt_num')) %>%
  mutate(treat = ifelse(!is.na(disenroll_date), 1, 0)) %>%
  
# Calc the mean likelihood of being treated by earnings bin and by household size
  
    mutate(bin = ifelse(hh_earnings <= 80000, cut(hh_earnings, breaks = seq(1, 80000, 1000), right = TRUE, labels = FALSE), 81),
          bin = replace_na(bin, 0)) %>%
  group_by(hh_size, bin) %>%
  summarise(pct_treat = mean(treat)) %>%
  ungroup()

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create graphs

#----------------------------------------------------------------------------
# Among 1-person households
  
dt %>%
  filter(hh_size == 1) %>%
ggplot(aes(x = bin, y = pct_treat)) +
  geom_line() +
  #geom_bar(stat = "identity", colour = 'black', position = position_nudge(x = 1)) + 
  geom_segment(aes(x = 21, xend = 21, y = 0, yend = 0.85),
              linetype = "dashed", color = "red") +
  annotate("text", x = 21, y = 0.87, label = "Income limit for 1-person HH = $19,391", size = 3) +
  scale_x_continuous(breaks = seq(0, 81, 1),
                     limits = c(-1,82), 
                     labels = c(' ', '$0', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$8k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$16k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$24k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$32k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$40k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$48k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$56k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$64k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$72k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$80k+')) +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  theme_bw() +
  labs(title = "Total household-level earnings in the 4 quarters prior to the person's unwinding recert deadline,\namong working-age adults who were enrolled in Medicaid as of 4/1/2023, plotted against likelihood of being\ndisenrolled for any reason, looking only at 1-person households",
       x = "Total household UI earnings in 4 quarters prior to recert deadline",
       y = "Likelihood of being disenrolled") + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        plot.title = element_text(size = 10),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study2-tauminus4-earnings-distrib-any-disenroll-hh1.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)

#----------------------------------------------------------------------------
# Among 2-person households
  
dt %>%
  filter(hh_size == 2) %>%
ggplot(aes(x = bin, y = pct_treat)) +
  geom_line() +
  #geom_bar(stat = "identity", colour = 'black', position = position_nudge(x = 1)) + 
  geom_segment(aes(x = 27, xend = 27, y = 0, yend = 0.85),
              linetype = "dashed", color = "red") +
  annotate("text", x = 27, y = 0.87, label = "Income limit for 2-person HH = $26,238", size = 3) +
  scale_x_continuous(breaks = seq(0, 81, 1),
                     limits = c(-1,82), 
                     labels = c(' ', '$0', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$8k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$16k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$24k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$32k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$40k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$48k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$56k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$64k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$72k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$80k+')) +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  theme_bw() +
  labs(title = "Total household-level earnings in the 4 quarters prior to the person's unwinding recert deadline,\namong working-age adults who were enrolled in Medicaid as of 4/1/2023, plotted against likelihood of being\ndisenrolled for any reason, looking only at 2-person households",
       x = "Total household UI earnings in 4 quarters prior to recert deadline",
       y = "Likelihood of being disenrolled") + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        plot.title = element_text(size = 10),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study2-tauminus4-earnings-distrib-any-disenroll-hh2.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)

#----------------------------------------------------------------------------
# Among 3-person households
  
dt %>%
  filter(hh_size == 3) %>%
ggplot(aes(x = bin, y = pct_treat)) +
  geom_line() +
  #geom_bar(stat = "identity", colour = 'black', position = position_nudge(x = 1)) + 
  geom_segment(aes(x = 35, xend = 35, y = 0, yend = 0.85),
              linetype = "dashed", color = "red") +
  annotate("text", x = 35, y = 0.87, label = "Income limit for 3-person HH = $33,069", size = 3) +
  scale_x_continuous(breaks = seq(0, 81, 1),
                     limits = c(-1,82), 
                     labels = c(' ', '$0', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$8k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$16k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$24k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$32k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$40k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$48k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$56k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$64k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$72k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$80k+')) +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  theme_bw() +
  labs(title = "Total household-level earnings in the 4 quarters prior to the person's unwinding recert deadline,\namong working-age adults who were enrolled in Medicaid as of 4/1/2023, plotted against likelihood of being\ndisenrolled for any reason, looking only at 3-person households",
       x = "Total household UI earnings in 4 quarters prior to recert deadline",
       y = "Likelihood of being disenrolled") + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        plot.title = element_text(size = 10),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study2-tauminus4-earnings-distrib-any-disenroll-hh3.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)

#----------------------------------------------------------------------------
# Among 4-person households
  
dt %>%
  filter(hh_size == 4) %>%
ggplot(aes(x = bin, y = pct_treat)) +
  geom_line() +
  #geom_bar(stat = "identity", colour = 'black', position = position_nudge(x = 1)) + 
  geom_segment(aes(x = 41, xend = 41, y = 0, yend = 0.85),
              linetype = "dashed", color = "red") +
  annotate("text", x = 41, y = 0.87, label = "Income limit for 4-person HH = $39,900", size = 3) +
  scale_x_continuous(breaks = seq(0, 81, 1),
                     limits = c(-1,82), 
                     labels = c(' ', '$0', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$8k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$16k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$24k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$32k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$40k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$48k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$56k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$64k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$72k', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '$80k+')) +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  theme_bw() +
  labs(title = "Total household-level earnings in the 4 quarters prior to the person's unwinding recert deadline,\namong working-age adults who were enrolled in Medicaid as of 4/1/2023, plotted against likelihood of being\ndisenrolled for any reason, looking only at 4-person households",
       x = "Total household UI earnings in 4 quarters prior to recert deadline",
       y = "Likelihood of being disenrolled") + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        plot.title = element_text(size = 10),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study2-tauminus4-earnings-distrib-any-disenroll-hh4.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)
```

# Study idea: Isolate effect of being required to recertify one's Medicaid eligibility, using randomly-assigned recertification deadlines during PHE unwinding year

## Pull base study sample

```{r}

#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
# Import raw data

#------------------------------------------------------------------------------
# Unique Medicaid clients who were enrolled in Medicaid on April 1, 2023 under MG 91 and who experienced at least one disenrollment between 4/1/2023 and 4/1/2024 for MAGI reasons

db_con <- dhs_dw(database = "ACPRD1", stored_db = TRUE, stored_creds = TRUE)

study3_base_sample_raw <- dbGetQuery(conn = db_con, 
                          statement = 
'with magi_medicaid_enrollees_04012023 as
(select distinct ma_receipt_num
 from 
    ac_mh.ccbh_hc_eligibility
 where
    category = \'MG\'
    and program_status = \'91\'
    and elig_from_date <= to_date(\'01-APR-2023\', \'DD-MON-YYYY\')
    and elig_to_date >= to_date(\'01-APR-2023\', \'DD-MON-YYYY\')),

magi_disenrollees as 
(select distinct 
  recipient_nbr as ma_receipt_num
 from 
    ac_mh.pa_client_elig_daily
 where 
    ma_term_reason_code = \'966\'
    and batch_date >= to_date(\'01-APR-2023\', \'DD-MON-YYYY\')
    and batch_date <= to_date(\'01-APR-2024\', \'DD-MON-YYYY\'))
    
select 
  a.ma_receipt_num,
  e.mci_uniq_id, 
  e.ssn, 
  e.date_of_birth as dob_medicaid, 
  g.dob as dob_dw, 
  g.dod, 
  e.member_gender as gender_medicaid,
  g.gender_common_desc as gender_dw, 
  e.race as race_medicaid, 
  g.race_common_desc as race_dw, 
  e.education_status, 
  e.living_situation,
  e.phone_number, 
  e.address_line_1, 
  e.address_line_2, 
  e.city,
  e.state, 
  e.zip_code
from 
    magi_medicaid_enrollees_04012023 a 
    inner join magi_disenrollees c on c.ma_receipt_num = a.ma_receipt_num
    left join ac_mh.t_ahci_clients e on e.ma_receipt_num = c.ma_receipt_num
    left join dw.dim_mci_unique @DW g on g.mci_uniq_id = e.mci_uniq_id')

# Make var names lowercase

names(study3_base_sample_raw) <- tolower(names(study3_base_sample_raw))

#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
# Clean up the data

#------------------------------------------------------------------------------
# Combine the treated and untreated samples

study3_base_sample <- study3_base_sample_raw %>%

# Drop the clients who have more than one Medicaid ID number associated with the same MCI unique ID. We will not use these clients in the analysis because it's difficult to discern their true identify
  
  group_by(mci_uniq_id) %>%
  mutate(count = n()) %>%
  ungroup() %>%
  filter(count == 1) %>%
  select(-count) %>%
  
# Convert dates to R date format
  
  mutate_at(vars(dob_dw, dob_medicaid, dod), ~ as.Date(substring(as.character(.), 1, 10), '%Y-%m-%d')) %>%
  
# Decode some values
  
  mutate(living_situation_desc = ifelse(living_situation == 'L70', 'Living independently',
                            ifelse(living_situation == 'L71', 'Family setting',
                            ifelse(living_situation == 'L72', 'Living dependently',
                            ifelse(living_situation == 'L73', 'Supervised setting',
                            ifelse(living_situation == 'L74', 'Restrictive setting',
                            ifelse(living_situation == 'L75', 'Homeless',
                            NA))))))) %>%
  select(-living_situation) %>%
  
# Look for discrepancies between DOB from the Medicaid table and DOB from the Golden Record table. Use the DOB from one source if it's missing in the other source. Use the DOB from the Golden Record for any mismatches.
  
  mutate(dob_match = ifelse(dob_medicaid == dob_dw, 1, 0), 
         dob = if_else(dob_match == 1, dob_medicaid, 
               if_else(is.na(dob_medicaid), dob_dw, 
               if_else(is.na(dob_dw), dob_medicaid, 
               NA)))) %>%
  select(-dob_medicaid, -dob_dw, -dob_match) %>%
  
#------------------------------------------------------------------------------
# Look for discrepancies between gender from the Medicaid table and gender from the Golden Record table. Use the gender from one source if it's missing in the other source. Use the gender from the Golden Record table for any mismatches
  
  mutate(gender_medicaid = ifelse(gender_medicaid == 'M', 'Male', 
                           ifelse(gender_medicaid == 'F', 'Female', 
                           NA)), 
         gender_dw = ifelse(gender_dw == '1~Male', 'Male', 
                     ifelse(gender_dw == '2~Female', 'Female', 
                     NA)), 
         gender_match = ifelse(gender_medicaid == gender_dw, 1, 0),
         gender = if_else(gender_match == 1, gender_medicaid, 
                  if_else(is.na(gender_medicaid), gender_dw, 
                  if_else(is.na(gender_dw), gender_medicaid, 
               NA)))) %>%
  select(-gender_medicaid, -gender_dw, -gender_match) %>%
  
#------------------------------------------------------------------------------
# Look for discrepancies between race from the Medicaid table and race from the Golden Record table. Use the race from one source if it's missing in the other source. Use the race from the Golden Record table for any mismatches
  
  mutate(race_medicaid = ifelse(race_medicaid == 'W', 'White', 
                         ifelse(race_medicaid == 'B', 'Black', 
                         ifelse(race_medicaid %in% c('A', 'O'), 'Other', 
                         NA))),
         race_dw = ifelse(race_dw == "1~White", 'White', 
                   ifelse(race_dw == "2~Black/African American", 'Black', 
                   ifelse(race_dw %in% c("3~American Indian/Alaskan Native", "4~Asian", "5~Native Hawaiian/Pacific Islander", "6~Two or More Races", "7~Other Single Race"), 'Other', 
                   NA))),
         race_match = ifelse(race_medicaid == race_dw, 1, 0),
         race = if_else(race_match == 1, race_medicaid, 
                if_else(is.na(race_medicaid), race_dw, 
                if_else(is.na(race_dw), race_medicaid, 
                NA)))) %>%
  select(-race_medicaid, -race_dw, -race_match) 
  
#------------------------------------------------------------------------------
# Group individuals together into households using phone number and address, assigning a unique ID to each household
  
household_ids <- study3_base_sample %>%
  distinct(phone_number, address_line_1, address_line_2, city, state, zip_code) %>%
  
# Only use the obs that have non-missing values of phone number and address
  
  filter(!is.na(phone_number) & !is.na(address_line_1) & !is.na(city) & !is.na(state) & !is.na(zip_code)) %>%
  
# Create a household-level ID
  
  mutate(household_id = sequence(n()))

study3_base_sample <- study3_base_sample %>%
  left_join(household_ids, by = c('phone_number', 'address_line_1', 'address_line_2', 'city', 'state', 'zip_code'))
  
# Save data

save(study3_base_sample, file = paste0(filepath, "/Data/Sample demographics/study3_base_sample.rda"))
```

## Distribution of recert deadlines during unwinding year for base sample

```{r}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample 

load(file = paste0(filepath, "/Data/Sample demographics/study3_base_sample.rda"))

# Recert deadlines during the unwinding year

load(file = paste0(filepath, "/Data/Medicaid enrollment data/study3_recert_deadlines.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

dt <- study3_base_sample %>%
  select(ma_receipt_num) %>%
  inner_join(study3_recert_deadlines, by = c('ma_receipt_num')) %>%
  
# Keep only the earliest recert deadline for each person
  
  group_by(ma_receipt_num) %>%
  top_n(-1, recert_deadline) %>%
  ungroup() %>%
  distinct(ma_receipt_num, recert_deadline) %>%
  
# Remove recert deadlines from after 3/31/2024
  
  filter(recert_deadline <= as.Date('2024-03-31')) %>%
  
# Count the density of deadlines by month
  
  mutate(recert_deadline_month = format(recert_deadline, "%Y-%m")) %>%
  group_by(recert_deadline_month) %>%
  summarise(n = n()) %>%
  ungroup()

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create graph

dt %>%
  ggplot(aes(x = recert_deadline_month, y = n)) +
  geom_bar(stat = "identity", colour = 'black') + 
  scale_y_continuous(breaks = seq(0, 1200, 200),
                     limits = c(0, 1200), 
                     labels = scales::comma) +  
  labs(x = "Month-year", y = "People with renewal deadline (N)", title = "Number of Medicaid enrollees with a renewal deadline, by month") +
  theme_bw() +
  theme(legend.title = element_blank(),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(), 
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study3-recert-deadlines-by-month.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)
```

## Distribution of disenrollment dates during unwinding year for base sample

```{r}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample 

load(file = paste0(filepath, "/Data/Sample demographics/study3_base_sample.rda"))

# MAGI-reason disenrollment dates for base sample

load(file = paste0(filepath, "/Data/Medicaid enrollment data/study3_magi_disenrollment_dates.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

dt <- study3_base_sample %>%
  select(ma_receipt_num) %>%
  inner_join(study3_magi_disenrollment_dates, by = c('ma_receipt_num')) %>%
  
# Keep only the earliest MAGI-reason disenrollment date for each person
  
  group_by(ma_receipt_num) %>%
  top_n(-1, magi_disenroll_date) %>%
  ungroup() %>%
  distinct(ma_receipt_num, magi_disenroll_date) %>%
  
# Count the density of disenrollments by day
  
  # mutate(recert_deadline_month = format(recert_deadline, "%Y-%m")) %>%
  group_by(magi_disenroll_date) %>%
  summarise(n = n()) %>%
  ungroup()

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create graph

dt %>%
  ggplot(aes(x = magi_disenroll_date, y = n)) +
  geom_line() + 
  scale_y_continuous(breaks = seq(0, 100, 10),
                     limits = c(0, 100), 
                     labels = scales::comma) +  
  labs(x = "Date", y = "Disenrollments for income ineligibility (N)", title = "Number of Medicaid disenrollments for income ineligibility during unwinding\nyear, by date") +
  theme_bw() +
  theme(legend.title = element_blank(),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(), 
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study3-magi-disenrollments-by-day.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)
```

## Percentages of T and C groups that were on Medicaid continuously during the entire covid disenrollment freeze, and mean number of days on Medicaid during covid disenrollment freeze (i.e. a baseline balance test)

```{r}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample 

load(file = paste0(filepath, "/Data/Sample demographics/study3_base_sample.rda"))

# Recert deadlines during the unwinding year

load(file = paste0(filepath, "/Data/Medicaid enrollment data/study3_recert_deadlines.rda"))

# Medicaid enrollment dates for everyone who was enrolled in Medicaid as of 4/1/2023

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_ccbh_episodes.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

# Define the C group as the cohort whose unwinding recert deadline was in April 2023, and the T group as those whose deadline was in March 2024

analytic_sample <- study3_base_sample %>%
  select(ma_receipt_num) %>%
  inner_join(study3_recert_deadlines, by = c('ma_receipt_num')) %>%
  group_by(ma_receipt_num) %>%
  top_n(-1, recert_deadline) %>%
  ungroup() %>%
  distinct(ma_receipt_num, recert_deadline) %>%
  mutate(recert_deadline_month = format(recert_deadline, "%Y-%m")) %>%
  # filter(recert_deadline_month %in% c("2023-04", "2024-03")) %>%
  # mutate(treat = ifelse(recert_deadline_month == "2024-03", 'Recert deadline was in Mar 2024', 'Recert deadline was in Apr 2023')) %>%
    filter(recert_deadline_month %in% c("2023-04", "2024-03")) %>%
  mutate(treat = ifelse(recert_deadline_month == "2023-04", 'Recert deadline was in Apr 2023', 'Recert deadline was in Mar 2024')) %>%
  select(ma_receipt_num, treat) 

#----------------------------------------------------------------------------
# Create a data frame with one obs per base sample member per date that they were enrolled in Medicaid between 4/1/2020 and 4/1/2023

dt <- analytic_sample %>%
  inner_join(medicaid_enrollment_dates_ccbh_episodes, by = c('ma_receipt_num')) %>%

# Remove obs in which the start date of the enrollment episode is after 4/1/2023
  
  filter(elig_from_date <= as.Date('2023-04-01')) %>%
  
# Recode any episode end dates as 4/1/2023 if they are after 4/1/2023
  
  mutate(elig_to_date = if_else(elig_to_date > as.Date('2023-04-01'), as.Date('2023-04-01'), elig_to_date)) %>%
  
# Recode missing values of the enrollment episode end date as 4/1/2023
  
  mutate(elig_to_date = replace_na(elig_to_date, as.Date('2023-04-01'))) %>%
  
# Remove obs where the episode end date was before 4/1/2020
  
  filter(elig_to_date >= as.Date('2020-04-01')) %>%
  
# Recode any episode start dates as 4/1/2020 if they are before 4/1/2020
  
  mutate(elig_from_date = if_else(elig_from_date < as.Date('2020-04-01'), as.Date('2020-04-01'), elig_from_date)) %>%
  
# Deduplicate the data
  
  distinct(ma_receipt_num, treat, elig_from_date, elig_to_date) %>%
  
# Reshape the data to have 1 obs for each day during each enrollment episode
  
  group_by(ma_receipt_num, treat, elig_from_date, elig_to_date) %>%
  reframe(date = list(seq.Date(from = elig_from_date,
                               to = elig_to_date,
                               by = "day"))) %>%
  unnest(date) %>%
  ungroup() %>%
  distinct(ma_receipt_num, treat, date) %>%
  
# Isolate the clients who were on Medicaid for the entire covid disenrollment freeze
  
  group_by(ma_receipt_num, treat) %>%
  summarise(days_count = n()) %>%
  ungroup() %>%
  mutate(enrolled_continuously_during_covid = ifelse(days_count == 1096, 1, 0)) %>%

# Calc the % of the sample that was enrolled in Medicaid continuously during the entire covid disenrollment freeze

  group_by(treat) %>%
  summarise(mean_days = mean(days_count),
            pct_continuously_enrolled = mean(enrolled_continuously_during_covid)) %>%
  ungroup() 

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create graphs

#----------------------------------------------------------------------------
# Mean number of days spent on Medicaid during covid disenrollment freeze

dt %>%
ggplot(aes(x = treat, y = mean_days, fill = treat)) +
  geom_bar(stat = "identity", position = position_dodge(), colour = 'black') + 
  geom_text(aes(label = round(mean_days, digits = 1)), position = position_dodge(width = 0.9), hjust = 0.5, vjust = -1, size = 4) +
  scale_y_continuous(breaks = seq(0,1000,100),
                     limits = c(0,1000)) +  
  labs(x = " ", y = "Days on Medicaid", title = "Mean number of days spent on Medicaid during the pandemic disenrollment freeze (4/1/2020 - 4/1/2023),\namong those who were on Medicaid as of 4/1/2023 and subsequently became disenrolled due to income\nineligibility during unwinding period") + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(), 
        plot.title = element_text(size = 10),
        legend.position = "none",
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study3-days-on-medicaid-during-covid.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)

#----------------------------------------------------------------------------
# Pct of sample that was on Medicaid continuously during covid disenrollment freeze

dt %>%
ggplot(aes(x = treat, y = pct_continuously_enrolled, fill = treat)) +
  geom_bar(stat = "identity", position = position_dodge(), colour = 'black') + 
  geom_text(aes(label = percent(pct_continuously_enrolled, accuracy = 0.1)), position = position_dodge(width = 0.9), hjust = 0.5, vjust = -1, size = 4) +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1), 
                     labels = percent_format()) +  
  labs(x = " ", y = "Pct of sample", title = "Pct of sample that was on Medicaid continuously during entire pandemic disenrollment freeze (4/1/20 - 4/1/23),\namong those who were on Medicaid as of 4/1/23 and subsequently became disenrolled due to income\nineligibility during unwinding period") + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(), 
        plot.title = element_text(size = 10),
        legend.position = "none",
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study3-continuously-on-medicaid-during-covid.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)
```

## Percentages of T and C groups that were on Medicaid by week between 4/1/2020 and 4/1/2023 (i.e. a pre-trend balance test)

```{r}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample 

load(file = paste0(filepath, "/Data/Sample demographics/study3_base_sample.rda"))

# Recert deadlines during the unwinding year

load(file = paste0(filepath, "/Data/Medicaid enrollment data/study3_recert_deadlines.rda"))

# Medicaid enrollment dates for everyone who was enrolled in Medicaid as of 4/1/2023

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_ccbh_episodes.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

# Define the C group as the cohort whose unwinding recert deadline was in April 2023, and the T group as those whose deadline was in March 2024

analytic_sample <- study3_base_sample %>%
  select(ma_receipt_num) %>%
  inner_join(study3_recert_deadlines, by = c('ma_receipt_num')) %>%
  group_by(ma_receipt_num) %>%
  top_n(-1, recert_deadline) %>%
  ungroup() %>%
  distinct(ma_receipt_num, recert_deadline) %>%
  mutate(recert_deadline_month = format(recert_deadline, "%Y-%m")) %>%
  # filter(recert_deadline_month %in% c("2023-04", "2024-03")) %>%
  # mutate(treat = ifelse(recert_deadline_month == "2024-03", 'Recert deadline was in Mar 2024', 'Recert deadline was in Apr 2023')) %>%
    filter(recert_deadline_month %in% c("2023-04", "2024-03")) %>%
  mutate(treat = ifelse(recert_deadline_month == "2023-04", 'Recert deadline was in Apr 2023', 'Recert deadline was in Mar 2024')) %>%
  select(ma_receipt_num, treat) 

#----------------------------------------------------------------------------
# Create a data frame with one obs per base sample member per date that they were enrolled in Medicaid between 4/1/2020 and 4/1/2023

dt1 <- analytic_sample %>%
  inner_join(medicaid_enrollment_dates_ccbh_episodes, by = c('ma_receipt_num')) %>%

# Remove obs in which the start date of the enrollment episode is after 4/1/2023
  
  filter(elig_from_date <= as.Date('2023-04-01')) %>%
  
# Recode missing values of the enrollment episode end date as 4/1/2023
  
  mutate(elig_to_date = replace_na(elig_to_date, as.Date('2023-04-01'))) %>%
  
# Remove obs where the episode end date was before 4/1/2020
  
  filter(elig_to_date >= as.Date('2020-04-01')) %>%
  
# Recode any episode start dates as 4/1/2020 if they are before 4/1/2020
  
  mutate(elig_from_date = if_else(elig_from_date < as.Date('2020-04-01'), as.Date('2020-04-01'), elig_from_date)) %>%
  
# Deduplicate the data
  
  distinct(ma_receipt_num, treat, elig_from_date, elig_to_date) %>%
  
# Reshape the data to have 1 obs for each day during each enrollment episode
  
  group_by(ma_receipt_num, treat, elig_from_date, elig_to_date) %>%
  reframe(date = list(seq.Date(from = elig_from_date,
                               to = elig_to_date,
                               by = "day"))) %>%
  unnest(date) %>%
  ungroup() %>%
  distinct(ma_receipt_num, treat, date) %>%
  mutate(medicaid_enrolled = 1)

#----------------------------------------------------------------------------
# Join with a grid of each date between 4/1/2020 and 4/1/2023

dt2 <- analytic_sample %>%
  mutate(start_date = as.Date('2020-04-01'), 
         end_date = as.Date('2023-04-01')) %>%
  group_by(ma_receipt_num, treat) %>%
  reframe(date = seq.Date(from = start_date,
                         to = end_date,
                         by = "day")) %>%
  ungroup() %>%
  mutate(tau_days = as.numeric(date - as.Date('2020-04-01')), 
         tau_weeks = floor(tau_days / 7)) 

dt <- dt1 %>%
  right_join(dt2, by = c('ma_receipt_num', 'treat', 'date')) %>%
  mutate(medicaid_enrolled = replace_na(medicaid_enrolled, 0)) %>%
  arrange(ma_receipt_num, date) %>%
  
# Calc the % of the sample that was enrolled in Medicaid in each week during the covid disenrollment freeze

  group_by(treat, tau_weeks) %>%
  summarise(pct_medicaid_enrolled = mean(medicaid_enrolled)) %>%
  ungroup() 

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create graph

dt %>%
  ggplot(mapping = aes(x = tau_weeks, y = pct_medicaid_enrolled, colour = treat, group = treat)) +
  geom_line() +
  geom_point() +
  theme_bw() +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  labs(x = "Week of pandemic disenrollment freeze", y = "Pct of sample enrolled in Medicaid", title = "Medicaid enrollment rates during pandemic disenrollment freeze, among those who were\ndisenrolled due to income ineligibility during unwinding year") + 
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        plot.title = element_text(size = 11),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study3-enrollment-rates-during-covid.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)
```

## Percentage of sample that was on Medicaid over time relative to recertification deadline during unwinding year (i.e. looking for a first-stage effect)

```{r}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample 

load(file = paste0(filepath, "/Data/Sample demographics/study3_base_sample.rda"))

# Recert deadlines during the unwinding year

load(file = paste0(filepath, "/Data/Medicaid enrollment data/study3_recert_deadlines.rda"))

# MAGI-reason disenrollment dates for base sample

load(file = paste0(filepath, "/Data/Medicaid enrollment data/study3_magi_disenrollment_dates.rda"))

# Medicaid enrollment dates for everyone who was enrolled in Medicaid as of 4/1/2023

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_ccbh_episodes.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

#----------------------------------------------------------------------------
# Create a data frame with one obs per base sample member per date that they were enrolled in Medicaid between 1/1/2020 and 12/31/2024

dt1 <- study3_base_sample %>%
  distinct(ma_receipt_num) %>%
  inner_join(medicaid_enrollment_dates_ccbh_episodes, by = c('ma_receipt_num')) %>%

# Remove obs in which the start date of the enrollment episode is after 12/31/2024
  
  filter(elig_from_date <= as.Date('2024-12-31')) %>%
  
# Recode missing values of the enrollment episode end date as 12/31/2024
  
  mutate(elig_to_date = replace_na(elig_to_date, as.Date('2024-12-31'))) %>%
  
# Remove obs where the episode end date was before 1/1/2020
  
  filter(elig_to_date >= as.Date('2020-01-01')) %>%
  
# Recode any episode start dates as 1/1/2020 if they are before 1/1/2020
  
  mutate(elig_from_date = if_else(elig_from_date < as.Date('2020-01-01'), as.Date('2020-01-01'), elig_from_date)) %>%
  
# Deduplicate the data
  
  distinct(ma_receipt_num, elig_from_date, elig_to_date) %>%
  
# Reshape the data to have 1 obs for each day during each enrollment episode
  
  group_by(ma_receipt_num, elig_from_date, elig_to_date) %>%
  reframe(date = list(seq.Date(from = elig_from_date,
                               to = elig_to_date,
                               by = "day"))) %>%
  unnest(date) %>%
  ungroup() %>%
  distinct(ma_receipt_num, date) %>%
  mutate(medicaid_enrolled = 1) %>%
  
#----------------------------------------------------------------------------
# Join with each person's unwinding MAGI-reason disenrollment date

  inner_join(study3_magi_disenrollment_dates %>%
             group_by(ma_receipt_num) %>%
             top_n(-1, magi_disenroll_date) %>%
             distinct(ma_receipt_num, magi_disenroll_date), 
             by = c('ma_receipt_num'))

#----------------------------------------------------------------------------
# Join with the enrollment dates with the recert deadlines

# Keep only the earliest post-4/1/2023 recert deadline for each person

dt2 <- study3_base_sample %>%
  select(ma_receipt_num) %>%
  inner_join(study3_recert_deadlines, by = c('ma_receipt_num')) %>%
  group_by(ma_receipt_num) %>%
  top_n(-1, recert_deadline) %>%
  ungroup() %>%
  distinct(ma_receipt_num, recert_deadline) %>%
  
# Pull in the Medicaid enrollment dates for the sample
  
  inner_join(dt1, by = c('ma_receipt_num')) 

#----------------------------------------------------------------------------
# Join with a grid of each date within +/- 365 days of the person's recert deadline, capped at 12/31/2024

dt3 <- study3_base_sample %>%
  select(ma_receipt_num) %>%
  inner_join(study3_recert_deadlines, by = c('ma_receipt_num')) %>%
  group_by(ma_receipt_num) %>%
  top_n(-1, recert_deadline) %>%
  ungroup() %>%
  distinct(ma_receipt_num, recert_deadline) %>%
  mutate(start_date = recert_deadline - 365, 
         end_date = pmin(recert_deadline + 365, as.Date('2024-12-31'))) %>%
  group_by(ma_receipt_num, recert_deadline) %>%
  reframe(date = seq.Date(from = start_date,
                         to = end_date,
                         by = "day")) %>%
  ungroup() %>%
  mutate(tau_days = as.numeric(date - recert_deadline), 
         tau_weeks = floor(tau_days / 7)) 

dt <- dt2 %>%
  right_join(dt3, by = c('ma_receipt_num', 'date')) %>%
  mutate(medicaid_enrolled = replace_na(medicaid_enrolled, 0)) %>%
  
# Calc the % of the sample that was enrolled in Medicaid in each week between +/- 365 days of their recert deadline

  group_by(tau_weeks) %>%
  summarise(pct_medicaid_enrolled = mean(medicaid_enrolled)) %>%
  ungroup() 

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create graph

dt %>%
  ggplot(mapping = aes(x = tau_weeks, y = pct_medicaid_enrolled)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = 0), color = "red", linetype = "dashed") + 
  theme_bw() +
  scale_x_continuous(breaks = seq(-55,55,5),
                     limits = c(-55,55)) +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  labs(x = "Weeks since recert deadline", y = "Pct of sample enrolled in Medicaid", title = "Medicaid enrollment rates over time relative to recertification deadline date, among those who\nwere disenrolled due to income ineligibility during unwinding year") + 
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        plot.title = element_text(size = 11),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study3-enrollment-rates-relative-to-recert-deadline.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)
```

## Percentage of sample that was on Medicaid over time relative to MAGI-reason disenrollment date during unwinding year (i.e. looking for a first-stage effect)

```{r}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample 

load(file = paste0(filepath, "/Data/Sample demographics/study3_base_sample.rda"))

# MAGI-reason disenrollment dates for base sample

load(file = paste0(filepath, "/Data/Medicaid enrollment data/study3_magi_disenrollment_dates.rda"))

# Medicaid enrollment dates for everyone who was enrolled in Medicaid as of 4/1/2023

load(file = paste0(filepath, "/Data/Medicaid enrollment data/medicaid_enrollment_dates_ccbh_episodes.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

#----------------------------------------------------------------------------
# Create a data frame with one obs per base sample member per date that they were enrolled in Medicaid between 1/1/2020 and 12/31/2024

dt1 <- study3_base_sample %>%
  distinct(ma_receipt_num) %>%
  inner_join(medicaid_enrollment_dates_ccbh_episodes, by = c('ma_receipt_num')) %>%

# Remove obs in which the start date of the enrollment episode is after 12/31/2024
  
  filter(elig_from_date <= as.Date('2024-12-31')) %>%
  
# Recode missing values of the enrollment episode end date as 12/31/2024
  
  mutate(elig_to_date = replace_na(elig_to_date, as.Date('2024-12-31'))) %>%
  
# Remove obs where the episode end date was before 1/1/2020
  
  filter(elig_to_date >= as.Date('2020-01-01')) %>%
  
# Recode any episode start dates as 1/1/2020 if they are before 1/1/2020
  
  mutate(elig_from_date = if_else(elig_from_date < as.Date('2020-01-01'), as.Date('2020-01-01'), elig_from_date)) %>%
  
# Deduplicate the data
  
  distinct(ma_receipt_num, elig_from_date, elig_to_date) %>%
  
# Reshape the data to have 1 obs for each day during each enrollment episode
  
  group_by(ma_receipt_num, elig_from_date, elig_to_date) %>%
  reframe(date = list(seq.Date(from = elig_from_date,
                               to = elig_to_date,
                               by = "day"))) %>%
  unnest(date) %>%
  ungroup() %>%
  distinct(ma_receipt_num, date) %>%
  mutate(medicaid_enrolled = 1)

#----------------------------------------------------------------------------
# Join the enrollment dates with the MAGI-reason disenrollment dates

# Keep only the earliest MAGI-reason disenrollment date for each person

dt2 <- study3_base_sample %>%
  select(ma_receipt_num) %>%
  inner_join(study3_magi_disenrollment_dates, by = c('ma_receipt_num')) %>%
  group_by(ma_receipt_num) %>%
  top_n(-1, magi_disenroll_date) %>%
  ungroup() %>%
  distinct(ma_receipt_num, magi_disenroll_date) %>%
  
# Pull in the Medicaid enrollment dates for the sample
  
  inner_join(dt1, by = c('ma_receipt_num')) 

#----------------------------------------------------------------------------
# Join with a grid of each date within +/- 365 days of the person's disenrollment date, capped at 12/31/2024

dt3 <- study3_base_sample %>%
  select(ma_receipt_num) %>%
  inner_join(study3_magi_disenrollment_dates, by = c('ma_receipt_num')) %>%
  group_by(ma_receipt_num) %>%
  top_n(-1, magi_disenroll_date) %>%
  ungroup() %>%
  distinct(ma_receipt_num, magi_disenroll_date) %>%
  mutate(start_date = magi_disenroll_date - 365, 
         end_date = pmin(magi_disenroll_date + 365, as.Date('2024-12-31'))) %>%
  group_by(ma_receipt_num, magi_disenroll_date) %>%
  reframe(date = seq.Date(from = start_date,
                         to = end_date,
                         by = "day")) %>%
  ungroup() %>%
  mutate(tau_days = as.numeric(date - magi_disenroll_date), 
         tau_weeks = floor(tau_days / 7)) 

dt <- dt2 %>%
  right_join(dt3, by = c('ma_receipt_num', 'date')) %>%
  mutate(medicaid_enrolled = replace_na(medicaid_enrolled, 0)) %>%
  
# Calc the % of the sample that was enrolled in Medicaid in each week between +/- 365 days of their MAGI-reason disenrollment

  group_by(tau_weeks) %>%
  summarise(pct_medicaid_enrolled = mean(medicaid_enrolled)) %>%
  ungroup() 

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create graph

dt %>%
  ggplot(mapping = aes(x = tau_weeks, y = pct_medicaid_enrolled)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = 0), color = "red", linetype = "dashed") + 
  theme_bw() +
  scale_x_continuous(breaks = seq(-55,55,5),
                     limits = c(-55,55)) +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  labs(x = "Weeks since disenrollment", y = "Pct of sample enrolled in Medicaid", title = "Medicaid enrollment rates over time, relative to date of disenrollment due to income ineligibility") + 
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        plot.title = element_text(size = 11),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study3-enrollment-rates-relative-to-disenrollment-date.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)
```

## UI data availability for T and C groups by calendar quarter

```{r}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample 

load(file = paste0(filepath, "/Data/Sample demographics/study3_base_sample.rda"))

# Recert deadlines during the unwinding year

load(file = paste0(filepath, "/Data/Medicaid enrollment data/study3_recert_deadlines.rda"))

# UI earnings

load(file = paste0(filepath, "/Data/PA unemployment insurance data/ui_earnings.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

# Define the C group as the cohort whose unwinding recert deadline was in April 2023, and the T group as those whose deadline was in March 2024

analytic_sample <- study3_base_sample %>%
  select(ma_receipt_num, dob) %>%
  inner_join(study3_recert_deadlines, by = c('ma_receipt_num')) %>%
  group_by(ma_receipt_num, dob) %>%
  top_n(-1, recert_deadline) %>%
  ungroup() %>%
  distinct(ma_receipt_num, dob, recert_deadline) %>%
  mutate(recert_deadline_month = format(recert_deadline, "%Y-%m")) %>%
  filter(recert_deadline_month %in% c("2023-04", "2024-03")) %>%
  mutate(treat = ifelse(recert_deadline_month == "2024-03", 'Recert deadline was in Mar 2024', 'Recert deadline was in Apr 2023')) %>% 
  
# Keep only the people who were between 25 and 60 years old as of 4/1/2023
  
  mutate(age_asof_04012023 = trunc((dob %--% as.Date('2023-04-01')) / years(1))) %>%
  filter(age_asof_04012023 >= 25 & age_asof_04012023 <= 60) %>%

# Pull in the distinct quarters for which each person has UI data. Keep only the UI data from Q1 2020 to Q3 2024. I don't really care about having UI data further back than Q1 2020 for now
  
  distinct(ma_receipt_num, treat) 

dt <- analytic_sample %>%
  inner_join(ui_earnings %>%
            distinct(ma_receipt_num, quarter) %>%
            filter(quarter %in% c('20201', '20202', '20203', '20204', '20211', '20212', '20213', '20214', '20221', '20222', '20223', '20224', '20231', '20232', '20233', '20234', '20241', '20242', '20243')), 
            by = c('ma_receipt_num')) %>%
  mutate(has_ui_data = 1) %>%
  
# Join the data with a grid of calendar quarters from Q1 2020 to Q3 2024 for each client

  right_join(analytic_sample %>%
             group_by(ma_receipt_num, treat) %>%
             reframe(quarter = c('20201', '20202', '20203', '20204', '20211', '20212', '20213', '20214', '20221', '20222', '20223', '20224', '20231', '20232', '20233', '20234', '20241', '20242', '20243')) %>%
             ungroup(), 
             by = c('ma_receipt_num', 'treat', 'quarter')) %>%
  mutate(has_ui_data = replace_na(has_ui_data, 0)) %>%

# Calc the percentages of the T and C groups that have non-missing UI data for each quarter

  group_by(treat, quarter) %>%
  summarise(pct_has_ui_data = mean(has_ui_data)) %>%
  ungroup() 

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create graph

dt %>%
  ggplot(mapping = aes(x = quarter, y = pct_has_ui_data, colour = treat, group = treat)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = '20242'), color = "red", linetype = "dashed") + 
  theme_bw() +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
  scale_x_discrete(labels = c('Q1 2020', ' ', 'Q3 2020', ' ', 'Q1 2021', ' ', 'Q3 2021', ' ', 'Q1 2022', ' ', 'Q3 2022', ' ', 'Q1 2023', ' ', 'Q3 2023', ' ', 'Q1 2024', ' ', 'Q3 2024')) +
  labs(x = "Calendar quarter", y = "Pct of cohort with UI data", title = "Percentage of working-age adults with non-missing UI data, among earlier versus later Medicaid\nrecertification cohorts that became disenrolled due to income ineligibility") +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.title = element_text(size = 10),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study3-ui-data-availability.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)
```

## Trends in outcomes for T and C groups in calendar time between 1/1/2020 and 12/31/2024

### UI outcomes

```{r}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample 

load(file = paste0(filepath, "/Data/Sample demographics/study3_base_sample.rda"))

# Recert deadlines during the unwinding year

load(file = paste0(filepath, "/Data/Medicaid enrollment data/study3_recert_deadlines.rda"))

# UI earnings

load(file = paste0(filepath, "/Data/PA unemployment insurance data/ui_earnings.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

# Define the C group as the cohort whose unwinding recert deadline was in April 2023, and the T group as those whose deadline was in March 2024

dt <- study3_base_sample %>%
  select(ma_receipt_num) %>%
  inner_join(study3_recert_deadlines, by = c('ma_receipt_num')) %>%
  group_by(ma_receipt_num) %>%
  top_n(-1, recert_deadline) %>%
  ungroup() %>%
  distinct(ma_receipt_num, recert_deadline) %>%
  mutate(recert_deadline_month = format(recert_deadline, "%Y-%m")) %>%
  filter(recert_deadline_month %in% c("2023-04", "2024-03")) %>%
  mutate(treat = ifelse(recert_deadline_month == "2024-03", 'Recert deadline was in Mar 2024', 'Recert deadline was in Apr 2023')) %>% 
  inner_join(ui_earnings %>% select(ma_receipt_num, quarter, ui_earnings), by = c('ma_receipt_num')) %>%
  mutate(employed = ifelse(ui_earnings > 0, 1, 0)) %>%
  filter(quarter %in% c('20201', '20202', '20203', '20204', '20211', '20212', '20213', '20214', '20221', '20222', '20223', '20224', '20231', '20232', '20233', '20234', '20241', '20242', '20243')) %>%
  mutate(quarter = factor(quarter, levels = c('20201', '20202', '20203', '20204', '20211', '20212', '20213', '20214', '20221', '20222', '20223', '20224', '20231', '20232', '20233', '20234', '20241', '20242', '20243'))) %>%
  group_by(treat, quarter) %>%
  summarise(pct_employed = mean(employed),
            mean_earnings = mean(ui_earnings)) %>%
  ungroup()

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create graphs

#----------------------------------------------------------------------------
# Employment rate

dt %>%
  ggplot(mapping = aes(x = quarter, y = pct_employed, colour = treat, group = treat)) +
  geom_line() +
  geom_point() +
  geom_vline(xintercept = which(levels(dt$quarter) == '20241') + 0.6, linetype = "dashed", color = "red") +  
  geom_vline(xintercept = '20232', linetype = "dashed", color = "red") +  
  theme_bw() +
  scale_y_continuous(breaks = seq(0.4, 0.9,0.1),
                     limits = c(0.4, 0.9),
                     labels = scales::percent_format(accuracy = 1)) +
  scale_x_discrete(labels = c('Q1 2020', ' ', 'Q3 2020', ' ', 'Q1 2021', ' ', 'Q3 2021', ' ', 'Q1 2022', ' ', 'Q3 2022', ' ', 'Q1 2023', ' ', 'Q3 2023', ' ', 'Q1 2024', ' ', 'Q3 2024')) +
  labs(x = "Calendar quarter", y = "Employment rate", title = "Employment rate by quarter, among earlier versus later Medicaid recertification cohorts that\nbecame disenrolled due to income ineligibility") +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        plot.title = element_text(size = 10),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study3-earnings-by-calendar-qtr.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)

#----------------------------------------------------------------------------
# Mean earnings

dt %>%
  ggplot(mapping = aes(x = quarter, y = mean_earnings, colour = treat, group = treat)) +
  geom_line() +
  geom_point() +
  geom_vline(xintercept = which(levels(dt$quarter) == '20241') + 0.6, linetype = "dashed", color = "red") +  
  geom_vline(xintercept = '20232', linetype = "dashed", color = "red") +  
  theme_bw() +
  scale_y_continuous(breaks = seq(1500,6500,500),
                     limits = c(1500, 6500),
                     labels = scales::dollar_format(accuracy = 1)) +
  scale_x_discrete(labels = c('Q1 2020', ' ', 'Q3 2020', ' ', 'Q1 2021', ' ', 'Q3 2021', ' ', 'Q1 2022', ' ', 'Q3 2022', ' ', 'Q1 2023', ' ', 'Q3 2023', ' ', 'Q1 2024', ' ', 'Q3 2024')) +
  labs(x = "Calendar quarter", y = "Mean earnings ($)", title = "Mean UI earnings by quarter, among earlier versus later Medicaid recertification cohorts that\nbecame disenrolled due to income ineligibility") +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        plot.title = element_text(size = 10),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study3-employment-by-calendar-qtr.png"), 
  plot = last_plot(),
  width = 7,
  height = 5)
```

# Study idea: Isolate effect of having 3 straight years of continuous Medicaid eligibility by comparing people who were enrolled on Medicaid on 3/18/2020 with those who were not

## Pull base study sample

```{r}

#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
# Import raw data

#------------------------------------------------------------------------------
# Unique Medicaid clients who were enrolled in Medicaid on March 1, 2020 

db_con <- dhs_dw(database = "ACPRD1", stored_db = TRUE, stored_creds = TRUE)

study4_base_sample_raw <- dbGetQuery(conn = db_con, 
                          statement = 
'with magi_medicaid_enrollees_04012020 as
(select distinct 
  ma_receipt_num, 
  category, 
  program_status
 from 
    ac_mh.ccbh_hc_eligibility
 where
    elig_from_date <= to_date(\'01-MAR-2020\', \'DD-MON-YYYY\')
    and elig_to_date >= to_date(\'01-MAR-2020\', \'DD-MON-YYYY\'))
    
select 
  a.*,
  e.mci_uniq_id, 
  e.ssn, 
  e.date_of_birth as dob_medicaid, 
  g.dob as dob_dw, 
  g.dod, 
  e.member_gender as gender_medicaid,
  g.gender_common_desc as gender_dw, 
  e.race as race_medicaid, 
  g.race_common_desc as race_dw, 
  e.education_status, 
  e.living_situation,
  e.phone_number, 
  e.address_line_1, 
  e.address_line_2, 
  e.city,
  e.state, 
  e.zip_code
from 
    magi_medicaid_enrollees_04012020 a 
    left join ac_mh.t_ahci_clients e on e.ma_receipt_num = a.ma_receipt_num
    left join dw.dim_mci_unique @DW g on g.mci_uniq_id = e.mci_uniq_id')

# Make var names lowercase

names(study4_base_sample_raw) <- tolower(names(study4_base_sample_raw))

#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
# Clean up the data

study4_base_sample <- study4_base_sample_raw %>%

# Drop the clients who have more than one Medicaid ID number associated with the same MCI unique ID. We will not use these clients in the analysis because it's difficult to discern their true identify
  
  group_by(mci_uniq_id) %>%
  mutate(count = n()) %>%
  ungroup() %>%
  filter(count == 1) %>%
  select(-count) %>%
  
# Convert dates to R date format
  
  mutate_at(vars(dob_dw, dob_medicaid, dod), ~ as.Date(substring(as.character(.), 1, 10), '%Y-%m-%d')) %>%
  
# Decode some values
  
  mutate(living_situation_desc = ifelse(living_situation == 'L70', 'Living independently',
                            ifelse(living_situation == 'L71', 'Family setting',
                            ifelse(living_situation == 'L72', 'Living dependently',
                            ifelse(living_situation == 'L73', 'Supervised setting',
                            ifelse(living_situation == 'L74', 'Restrictive setting',
                            ifelse(living_situation == 'L75', 'Homeless',
                            NA))))))) %>%
  select(-living_situation) %>%
  
# Look for discrepancies between DOB from the Medicaid table and DOB from the Golden Record table. Use the DOB from one source if it's missing in the other source. Use the DOB from the Golden Record for any mismatches.
  
  mutate(dob_match = ifelse(dob_medicaid == dob_dw, 1, 0), 
         dob = if_else(dob_match == 1, dob_medicaid, 
               if_else(is.na(dob_medicaid), dob_dw, 
               if_else(is.na(dob_dw), dob_medicaid, 
               NA)))) %>%
  select(-dob_medicaid, -dob_dw, -dob_match) %>%
  
#------------------------------------------------------------------------------
# Look for discrepancies between gender from the Medicaid table and gender from the Golden Record table. Use the gender from one source if it's missing in the other source. Use the gender from the Golden Record table for any mismatches
  
  mutate(gender_medicaid = ifelse(gender_medicaid == 'M', 'Male', 
                           ifelse(gender_medicaid == 'F', 'Female', 
                           NA)), 
         gender_dw = ifelse(gender_dw == '1~Male', 'Male', 
                     ifelse(gender_dw == '2~Female', 'Female', 
                     NA)), 
         gender_match = ifelse(gender_medicaid == gender_dw, 1, 0),
         gender = if_else(gender_match == 1, gender_medicaid, 
                  if_else(is.na(gender_medicaid), gender_dw, 
                  if_else(is.na(gender_dw), gender_medicaid, 
               NA)))) %>%
  select(-gender_medicaid, -gender_dw, -gender_match) %>%
  
#------------------------------------------------------------------------------
# Look for discrepancies between race from the Medicaid table and race from the Golden Record table. Use the race from one source if it's missing in the other source. Use the race from the Golden Record table for any mismatches
  
  mutate(race_medicaid = ifelse(race_medicaid == 'W', 'White', 
                         ifelse(race_medicaid == 'B', 'Black', 
                         ifelse(race_medicaid %in% c('A', 'O'), 'Other', 
                         NA))),
         race_dw = ifelse(race_dw == "1~White", 'White', 
                   ifelse(race_dw == "2~Black/African American", 'Black', 
                   ifelse(race_dw %in% c("3~American Indian/Alaskan Native", "4~Asian", "5~Native Hawaiian/Pacific Islander", "6~Two or More Races", "7~Other Single Race"), 'Other', 
                   NA))),
         race_match = ifelse(race_medicaid == race_dw, 1, 0),
         race = if_else(race_match == 1, race_medicaid, 
                if_else(is.na(race_medicaid), race_dw, 
                if_else(is.na(race_dw), race_medicaid, 
                NA)))) %>%
  select(-race_medicaid, -race_dw, -race_match) 
  
#------------------------------------------------------------------------------
# Group individuals together into households using phone number and address, assigning a unique ID to each household
  
household_ids <- study4_base_sample %>%
  distinct(phone_number, address_line_1, address_line_2, city, state, zip_code) %>%
  
# Only use the obs that have non-missing values of phone number and address
  
  filter(!is.na(phone_number) & !is.na(address_line_1) & !is.na(city) & !is.na(state) & !is.na(zip_code)) %>%
  
# Create a household-level ID
  
  mutate(household_id = sequence(n()))

study4_base_sample <- study4_base_sample %>%
  left_join(household_ids, by = c('phone_number', 'address_line_1', 'address_line_2', 'city', 'state', 'zip_code'))
  
# Save data

save(study4_base_sample, file = paste0(filepath, "/Data/Sample demographics/study4_base_sample.rda"))
```

## Pull Medicaid enrollment episode dates

```{r, eval = TRUE}

#-------------------------------------------------------------------------
#-------------------------------------------------------------------------
# Load raw data

db_con <- dhs_dw(database = "ACPRD1", stored_db = TRUE, stored_creds = TRUE)

study4_enrollment_dates_raw <- dbGetQuery(conn = db_con, 
                          statement = 
'with medicaid_enrollees_03012020 as
(select distinct
    ma_receipt_num
from 
    ac_mh.ccbh_hc_eligibility 
where
    elig_from_date <= to_date(\'01-MAR-2020\', \'DD-MON-YYYY\')
    and elig_to_date >= to_date(\'01-MAR-2020\', \'DD-MON-YYYY\'))

select distinct
  a.ma_receipt_num, 
  c.elig_from_date, 
  c.elig_to_date
from 
  medicaid_enrollees_03012020 a
  left join ac_mh.ccbh_hc_eligibility c on c.ma_receipt_num = a.ma_receipt_num')

# Make var names lowercase

names(study4_enrollment_dates_raw) <- tolower(names(study4_enrollment_dates_raw))

#-------------------------------------------------------------------------
#-------------------------------------------------------------------------
# Clean up the data

# Convert dates to R date format

study4_enrollment_dates <- study4_enrollment_dates_raw %>%
  mutate_at(vars(elig_from_date, elig_to_date), ~ as.Date(substring(as.character(.), 1, 10), '%Y-%m-%d')) %>%
  
# Remove any obs where the episode start date is after the episode end date. These are data quality issues I think. 
  
  filter(elig_from_date <= elig_to_date) %>%
  
# Recode certain end dates as missing values, meaning the benefit episode is still ongoing
  
  mutate(elig_to_date = if_else(elig_to_date == as.Date('2079-06-06'), NA, elig_to_date)) 
  
# Save data

save(study4_enrollment_dates, file = paste0(filepath, "/Data/Medicaid enrollment data/study4_enrollment_dates.rda"))
```

## Pull UI earnings in Q1 2020 

```{r}

#----------------------------------------------------------------------------
# UI quarterly earnings data in Q1 2020 for the base study sample

db_con <- dhs_dw(database = "ACPRD1", stored_db = TRUE, stored_creds = TRUE)

study4_earnings_raw <- dbGetQuery(conn = db_con, 
                          statement = 
'with magi_medicaid_enrollees_03012020 as
(select distinct 
  ma_receipt_num, 
  ssn
 from 
    ac_mh.ccbh_hc_eligibility
 where
    elig_from_date <= to_date(\'01-MAR-2020\', \'DD-MON-YYYY\')
    and elig_to_date >= to_date(\'01-MAR-2020\', \'DD-MON-YYYY\'))
    
select 
  a.*,
  d.request_period as quarter, 
  e.qtrly_wages as ui_earnings, 
  e.employer_legal_name, 
  e.address1 as employer_address1, 
  e.address2 as employer_address2, 
  e.city as employer_city, 
  e.state as employer_state, 
  e.zip as employer_zip, 
  e.naics as employer_naics
from 
  magi_medicaid_enrollees_03012020 a
  inner join ac_labor.historic_requests d on a.ssn = d.ssn
  left outer join ac_labor.historic_quarterly_wages e on d.mci_uniq_id = e.mci_uniq_id and e.filing_year || e.filing_quarter = d.request_period')

names(study4_earnings_raw) <- tolower(names(study4_earnings_raw))
  
# De-duplicate the data by client, quarter, and employer name (make sure I understand why any duplicates are occurring; are they duplicates in the raw UI data?)

study4_earnings <- study4_earnings_raw %>%
  distinct(ma_receipt_num, ssn, quarter, employer_legal_name, .keep_all = TRUE) %>%
  
# Recode missing values of earnings as zeroes
  
  mutate(ui_earnings = replace_na(ui_earnings, 0)) %>%
  
# Recode NAICS values of "-" as missing values
  
  mutate(employer_naics = ifelse(employer_naics == '-', NA, employer_naics))

# Load NAICS code lookup tables

naics_2017 <- read.csv("C:/Users/K011014/OneDrive - Allegheny County/Workforce development/Unemployment insurance data/NAICS code info/naics_lookup_2017.csv", 
                 header = T, 
                 colClasses = 'character',
                 na.strings = c("")) %>%
  select(naics_code, naics_sector_title, naics_subsector_title, naics_occupation) %>%
  rename(naics_code_2017 = naics_code,
         naics_sector_2017 = naics_sector_title, 
         naics_subsector_2017 = naics_subsector_title, 
         naics_industry_2017 = naics_occupation)

naics_2022 <- read.csv("C:/Users/K011014/OneDrive - Allegheny County/Workforce development/Unemployment insurance data/NAICS code info/naics_lookup_2022.csv", 
                       header = T, 
                       colClasses = 'character',
                       na.strings = c("")) %>%
  select(naics_national_industry, naics_sector_desc, naics_subsector_desc, naics_national_industry_desc) %>%
  rename(naics_code_2022 = naics_national_industry,
         naics_sector_2022 = naics_sector_desc, 
         naics_subsector_2022 = naics_subsector_desc, 
         naics_industry_2022 = naics_national_industry_desc)

# Join the UI data with the NAICS code lookup info

study4_earnings <- study4_earnings %>%
  left_join(naics_2017, by = c('employer_naics' = 'naics_code_2017')) %>%
  left_join(naics_2022, by = c('employer_naics' = 'naics_code_2022')) 

# Save data

save(study4_earnings, file = paste0(filepath, "/Data/PA unemployment insurance data/study4_earnings.rda"))
```

## Percentages of T and C groups that were on Medicaid by week between 4/1/2020 and 4/1/2023 

### Among everyone who had an episode end date around 3/18/2020

```{r}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample 

load(file = paste0(filepath, "/Data/Sample demographics/study4_base_sample.rda"))

# Medicaid enrollment episode dates

load(file = paste0(filepath, "/Data/Medicaid enrollment data/study4_enrollment_dates.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

#----------------------------------------------------------------------------
# Isolate the analytic sample

# Keep only the clients with MG 91 Medicaid on March 1, 2020

analytic_sample <- study4_base_sample %>%
  filter(category == 'MG' & program_status == '91') %>%
  select(ma_receipt_num) %>%
  inner_join(study4_enrollment_dates, by = c('ma_receipt_num')) %>%
  
# Keep only the clients who had an enrollment end date within +/- 30 days of 3/18/2020
  
  mutate(tau = trunc((elig_to_date %--% as.Date('2020-03-18')) / days(1))) %>%
  filter(abs(tau) <= 30) %>%
  
# Define the T group as those whose episode end date was on or after 3/18/2020, and the C group as those whose episode end date was before 3/18/2020
  
  mutate(treat = ifelse(tau >= 0, 'Ended an enrollment episode within 30 days after 3/18/2020', 'Ended an enrollment episode within 30 days before 3/18/2020')) %>%
  distinct(ma_receipt_num, treat)

#----------------------------------------------------------------------------
# Create a data frame with one obs per analytic sample member per date that they were enrolled in Medicaid between 4/1/2020 and 4/1/2023

dt1 <- analytic_sample %>%
  inner_join(study4_enrollment_dates, by = c('ma_receipt_num')) %>%

# Remove obs in which the start date of the enrollment episode is after 4/1/2023
  
  filter(elig_from_date <= as.Date('2023-04-01')) %>%
  
# Recode missing values of the enrollment episode end date as 4/1/2023
  
  mutate(elig_to_date = replace_na(elig_to_date, as.Date('2023-04-01'))) %>%
  
# Remove obs where the episode end date was before 4/1/2020
  
  filter(elig_to_date >= as.Date('2020-04-01')) %>%
  
# Recode any episode start dates as 4/1/2020 if they are before 4/1/2020
  
  mutate(elig_from_date = if_else(elig_from_date < as.Date('2020-04-01'), as.Date('2020-04-01'), elig_from_date)) %>%
  
# Deduplicate the data
  
  distinct(ma_receipt_num, treat, elig_from_date, elig_to_date) %>%
  
# Reshape the data to have 1 obs for each day during each enrollment episode
  
  group_by(ma_receipt_num, treat, elig_from_date, elig_to_date) %>%
  reframe(date = list(seq.Date(from = elig_from_date,
                               to = elig_to_date,
                               by = "day"))) %>%
  unnest(date) %>%
  ungroup() %>%
  distinct(ma_receipt_num, treat, date) %>%
  mutate(medicaid_enrolled = 1)

#----------------------------------------------------------------------------
# Join with a grid of each date between 4/1/2020 and 4/1/2023

dt2 <- analytic_sample %>%
  mutate(start_date = as.Date('2020-04-01'), 
         end_date = as.Date('2023-04-01')) %>%
  group_by(ma_receipt_num, treat) %>%
  reframe(date = seq.Date(from = start_date,
                         to = end_date,
                         by = "day")) %>%
  ungroup() %>%
  mutate(tau_days = as.numeric(date - as.Date('2020-04-01')), 
         tau_weeks = floor(tau_days / 7)) 

dt <- dt1 %>%
  right_join(dt2, by = c('ma_receipt_num', 'treat', 'date')) %>%
  mutate(medicaid_enrolled = replace_na(medicaid_enrolled, 0)) %>%
  arrange(ma_receipt_num, date) %>%
  
# Calc the % of the sample that was enrolled in Medicaid in each week during the covid disenrollment freeze

  group_by(treat, tau_weeks) %>%
  summarise(pct_medicaid_enrolled = mean(medicaid_enrolled)) %>%
  ungroup() 

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create graph

dt %>%
  ggplot(mapping = aes(x = tau_weeks, y = pct_medicaid_enrolled, colour = treat, group = treat)) +
  geom_line() +
  geom_point() +
  theme_bw() +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
    scale_x_continuous(breaks = seq(0,160,20),
                     limits = c(0,160)) +
  labs(x = "Week of pandemic disenrollment freeze", y = "Pct of sample enrolled in Medicaid", title = "Medicaid enrollment rates by week during pandemic disenrollment freeze") + 
  guides(color = guide_legend(nrow = 2)) + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        plot.title = element_text(size = 10),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study4-enrollment-rates-during-covid.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)
```

### Among those with HH UI earnings in Q1 2020 that were above 133% of FPL

```{r}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample 

load(file = paste0(filepath, "/Data/Sample demographics/study4_base_sample.rda"))

# Medicaid enrollment episode dates

load(file = paste0(filepath, "/Data/Medicaid enrollment data/study4_enrollment_dates.rda"))

# UI earnings for base sample

load(file = paste0(filepath, "/Data/PA unemployment insurance data/study4_earnings.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

#----------------------------------------------------------------------------
# Isolate the analytic sample

# Keep only the clients with MG 91 Medicaid on March 1, 2020

dt1 <- study4_base_sample %>%
  filter(category == 'MG' & program_status == '91') %>%
  inner_join(study4_enrollment_dates, by = c('ma_receipt_num')) %>%
  
# Keep only the clients who had an enrollment end date within +/- 30 days of 3/18/2020
  
  mutate(tau = trunc((elig_to_date %--% as.Date('2020-03-18')) / days(1))) %>%
  filter(abs(tau) <= 30) %>%

# Define the T group as those whose episode end date was on or after 3/18/2020, and the C group as those whose episode end date was before 3/18/2020
  
  mutate(treat = ifelse(tau >= 0, 'Ended an enrollment episode within 30 days after 3/18/2020', 'Ended an enrollment episode within 30 days before 3/18/2020')) %>%
  distinct(ma_receipt_num, household_id, treat)
  
#----------------------------------------------------------------------------
# Pull in the Q1 2020 household-level UI earnings for the analytic sample

analytic_sample <- study4_base_sample %>%
  select(ma_receipt_num, household_id) %>%
  filter(!is.na(household_id)) %>%
  group_by(household_id) %>%
  mutate(hh_size = n()) %>%
  ungroup() %>%
  inner_join(study4_earnings %>%
             filter(quarter == '20201') %>%
             select(ma_receipt_num, ui_earnings), 
             by = c('ma_receipt_num')) %>%
  group_by(household_id, hh_size) %>%
  summarise(hh_earnings_q12020 = sum(ui_earnings)) %>%
  ungroup() %>%
  inner_join(dt1, by = c('household_id')) %>%
  select(-household_id) %>%
  
# Keep only the sample members with a HH size of 1 to 4 people and whose Q1 2020 HH earnings was > 133% of the HH size-adjusted poverty line
  
  filter(hh_size <= 4) %>%
  mutate(keep = ifelse(hh_earnings_q12020 > 4242 & hh_size == 1, 1, 
                ifelse(hh_earnings_q12020 > 5732 & hh_size == 2, 1, 
                ifelse(hh_earnings_q12020 > 7222 & hh_size == 3, 1, 
                ifelse(hh_earnings_q12020 > 8712 & hh_size == 4, 1, 
                0))))) %>%
  filter(keep == 1) %>%
  select(ma_receipt_num, treat)

#----------------------------------------------------------------------------
# Create a data frame with one obs per analytic sample member per date that they were enrolled in Medicaid between 4/1/2020 and 4/1/2023

dt1 <- analytic_sample %>%
  inner_join(study4_enrollment_dates, by = c('ma_receipt_num')) %>%

# Remove obs in which the start date of the enrollment episode is after 4/1/2023
  
  filter(elig_from_date <= as.Date('2023-04-01')) %>%
  
# Recode missing values of the enrollment episode end date as 4/1/2023
  
  mutate(elig_to_date = replace_na(elig_to_date, as.Date('2023-04-01'))) %>%
  
# Remove obs where the episode end date was before 4/1/2020
  
  filter(elig_to_date >= as.Date('2020-04-01')) %>%
  
# Recode any episode start dates as 4/1/2020 if they are before 4/1/2020
  
  mutate(elig_from_date = if_else(elig_from_date < as.Date('2020-04-01'), as.Date('2020-04-01'), elig_from_date)) %>%
  
# Deduplicate the data
  
  distinct(ma_receipt_num, treat, elig_from_date, elig_to_date) %>%
  
# Reshape the data to have 1 obs for each day during each enrollment episode
  
  group_by(ma_receipt_num, treat, elig_from_date, elig_to_date) %>%
  reframe(date = list(seq.Date(from = elig_from_date,
                               to = elig_to_date,
                               by = "day"))) %>%
  unnest(date) %>%
  ungroup() %>%
  distinct(ma_receipt_num, treat, date) %>%
  mutate(medicaid_enrolled = 1)

#----------------------------------------------------------------------------
# Join with a grid of each date between 4/1/2020 and 4/1/2023

dt2 <- analytic_sample %>%
  mutate(start_date = as.Date('2020-04-01'), 
         end_date = as.Date('2023-04-01')) %>%
  group_by(ma_receipt_num, treat) %>%
  reframe(date = seq.Date(from = start_date,
                         to = end_date,
                         by = "day")) %>%
  ungroup() %>%
  mutate(tau_days = as.numeric(date - as.Date('2020-04-01')), 
         tau_weeks = floor(tau_days / 7)) 

dt <- dt1 %>%
  right_join(dt2, by = c('ma_receipt_num', 'treat', 'date')) %>%
  mutate(medicaid_enrolled = replace_na(medicaid_enrolled, 0)) %>%
  arrange(ma_receipt_num, date) %>%
  
# Calc the % of the sample that was enrolled in Medicaid in each week during the covid disenrollment freeze

  group_by(treat, tau_weeks) %>%
  summarise(pct_medicaid_enrolled = mean(medicaid_enrolled)) %>%
  ungroup() 

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create graph

dt %>%
  ggplot(mapping = aes(x = tau_weeks, y = pct_medicaid_enrolled, colour = treat, group = treat)) +
  geom_line() +
  geom_point() +
  theme_bw() +
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1),
                     labels = scales::percent_format(accuracy = 1)) +
    scale_x_continuous(breaks = seq(0,160,20),
                     limits = c(0,160)) +
  labs(x = "Week of pandemic disenrollment freeze", y = "Pct of sample enrolled in Medicaid", title = "Medicaid enrollment rates by week during pandemic disenrollment freeze, only looking at people whose\nQ1 2020 household earnings was above the Medicaid eligibility threshold") + 
  guides(color = guide_legend(nrow = 2)) + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        legend.title = element_blank(),
        legend.position = 'bottom',
        plot.title = element_text(size = 10),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study4-enrollment-rates-during-covid-high-earners.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)
```

## Percentage of all days on Medicaid during covid, and likelihood of continuous enrollment during covid, by end date of Medicaid episode relative to 3/18/2020

### Among everyone who had an episode end date around 3/18/2020

```{r}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample 

load(file = paste0(filepath, "/Data/Sample demographics/study4_base_sample.rda"))

# Medicaid enrollment episode dates

load(file = paste0(filepath, "/Data/Medicaid enrollment data/study4_enrollment_dates.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

#----------------------------------------------------------------------------
# Isolate the analytic sample

# Keep only the clients with MG 91 Medicaid on March 1, 2020

analytic_sample <- study4_base_sample %>%
  filter(category == 'MG' & program_status == '91') %>%
  select(ma_receipt_num) %>%
  inner_join(study4_enrollment_dates, by = c('ma_receipt_num')) %>%
  
# Keep only the clients who had an enrollment end date within +/- 30 days of 3/18/2020
  
  mutate(tau = trunc((elig_to_date %--% as.Date('2020-03-18')) / days(1))) %>%
  filter(abs(tau) <= 30) %>%
  distinct(ma_receipt_num, tau) 

#----------------------------------------------------------------------------
# Create a data frame with one obs per analytic sample member per date that they were enrolled in Medicaid between 4/1/2020 and 4/1/2023

dt <- analytic_sample %>%
  inner_join(study4_enrollment_dates, by = c('ma_receipt_num')) %>%

# Remove obs in which the start date of the enrollment episode is after 4/1/2023
  
  filter(elig_from_date <= as.Date('2023-04-01')) %>%
  
# Recode any episode end dates as 4/1/2023 if they are after 4/1/2023
  
  mutate(elig_to_date = if_else(elig_to_date > as.Date('2023-04-01'), as.Date('2023-04-01'), elig_to_date)) %>%
  
# Recode missing values of the enrollment episode end date as 4/1/2023
  
  mutate(elig_to_date = replace_na(elig_to_date, as.Date('2023-04-01'))) %>%
  
# Remove obs where the episode end date was before 4/1/2020
  
  filter(elig_to_date >= as.Date('2020-04-01')) %>%
  
# Recode any episode start dates as 4/1/2020 if they are before 4/1/2020
  
  mutate(elig_from_date = if_else(elig_from_date < as.Date('2020-04-01'), as.Date('2020-04-01'), elig_from_date)) %>%
  
# Deduplicate the data
  
  distinct(ma_receipt_num, tau, elig_from_date, elig_to_date) %>%
  
# Reshape the data to have 1 obs for each day during each enrollment episode
  
  group_by(ma_receipt_num, tau, elig_from_date, elig_to_date) %>%
  reframe(date = list(seq.Date(from = elig_from_date,
                               to = elig_to_date,
                               by = "day"))) %>%
  unnest(date) %>%
  ungroup() %>%
  distinct(ma_receipt_num, tau, date) %>%

# Calc the % of all days during the covid disenrollment freeze that each person was enrolled in Medicaid, and flag people who were continuously enrolled during covid

  group_by(ma_receipt_num, tau) %>%
  summarise(continuously_enrolled = ifelse(n() >= 1095, 1, 0),
            pct_days = n() / 1095) %>%
  ungroup() %>%
  group_by(tau) %>%
  summarise(person_count = n(),
            pct_days = ifelse(mean(pct_days) > 1, 1, mean(pct_days)),
            pct_continuously_enrolled = mean(continuously_enrolled)) %>%
  ungroup() 

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create graphs

#----------------------------------------------------------------------------
# Density of obs around cutoff date

dt %>%
ggplot(aes(x = tau, y = person_count)) +
  geom_line() +
    geom_vline(aes(xintercept = 0), color = "red", linetype = "dashed") + 
  scale_y_continuous(breaks = seq(0,2500,250),
                     limits = c(0,2500)) +  
  labs(x = "Days between enrollment episode end date and start of disenrollment freeze", y = "Number of people", title = "Number of people that had a Medicaid enrollment episode end within +/- 30 days of the start of the pandemic\ndisenrollment freeze") + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(), 
        plot.title = element_text(size = 10),
        legend.position = "none",
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study4-obs-density-around-cutoff.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)

#----------------------------------------------------------------------------
# Pct of all days of disenrollment freeze on which the person was enrolled in Medicaid

dt %>%
ggplot(aes(x = tau, y = pct_days)) +
  geom_line() + 
      geom_vline(aes(xintercept = 0), color = "red", linetype = "dashed") + 
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1)) +  
  labs(x = "Days between enrollment episode end date and start of disenrollment freeze", y = "Pct of all days spent on Medicaid", title = "Percentage of the 1,095-day disenrollment freeze on which the person was enrolled in Medicaid, by date of\nenrollment episode end date relative to the start of the disenrollment freeze") + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(), 
        plot.title = element_text(size = 10),
        legend.position = "none",
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study4-pct-of-covid-enrolled.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)

#----------------------------------------------------------------------------
# Pct of sample that was enrolled in Medicaid continuously during the covid disenrollment freeze

dt %>%
ggplot(aes(x = tau, y = pct_continuously_enrolled)) +
  geom_line() + 
  geom_vline(aes(xintercept = 0), color = "red", linetype = "dashed") + 
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1)) +  
  labs(x = "Days between enrollment episode end date and start of disenrollment freeze", y = "Likelihood", title = "Likelihood of being enrolled continuously in Medicaid during entire 1,095-day disenrollment freeze, by date of\nenrollment episode end date relative to the start of the disenrollment freeze") + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(), 
        plot.title = element_text(size = 10),
        legend.position = "none",
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study4-continuous-enrollment-likelihood.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)
```

### Among those with HH UI earnings in Q1 2020 that were above 133% of FPL

```{r}

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Load relevant data

# Base sample 

load(file = paste0(filepath, "/Data/Sample demographics/study4_base_sample.rda"))

# Medicaid enrollment episode dates

load(file = paste0(filepath, "/Data/Medicaid enrollment data/study4_enrollment_dates.rda"))

# UI earnings for base sample

load(file = paste0(filepath, "/Data/PA unemployment insurance data/study4_earnings.rda"))

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Analyze data

#----------------------------------------------------------------------------
# Isolate the analytic sample

# Keep only the clients with MG 91 Medicaid on March 1, 2020

dt1 <- study4_base_sample %>%
  filter(category == 'MG' & program_status == '91') %>%
  inner_join(study4_enrollment_dates, by = c('ma_receipt_num')) %>%
  
# Keep only the clients who had an enrollment end date within +/- 30 days of 3/18/2020
  
  mutate(tau = trunc((elig_to_date %--% as.Date('2020-03-18')) / days(1))) %>%
  filter(abs(tau) <= 30) %>%
  distinct(ma_receipt_num, household_id, tau) 
  
#----------------------------------------------------------------------------
# Pull in the Q1 2020 household-level UI earnings for the analytic sample

analytic_sample <- study4_base_sample %>%
  select(ma_receipt_num, household_id) %>%
  filter(!is.na(household_id)) %>%
  group_by(household_id) %>%
  mutate(hh_size = n()) %>%
  ungroup() %>%
  inner_join(study4_earnings %>%
             filter(quarter == '20201') %>%
             select(ma_receipt_num, ui_earnings), 
             by = c('ma_receipt_num')) %>%
  group_by(household_id, hh_size) %>%
  summarise(hh_earnings_q12020 = sum(ui_earnings)) %>%
  ungroup() %>%
  inner_join(dt1, by = c('household_id')) %>%
  select(-household_id) %>%
  
# Keep only the sample members with a HH size of 1 to 4 people and whose Q1 2020 HH earnings was > 133% of the HH size-adjusted poverty line
  
  filter(hh_size <= 4) %>%
  mutate(keep = ifelse(hh_earnings_q12020 > 4242 & hh_size == 1, 1, 
                ifelse(hh_earnings_q12020 > 5732 & hh_size == 2, 1, 
                ifelse(hh_earnings_q12020 > 7222 & hh_size == 3, 1, 
                ifelse(hh_earnings_q12020 > 8712 & hh_size == 4, 1, 
                0))))) %>%
  filter(keep == 1)
  
#----------------------------------------------------------------------------
# Create a data frame with one obs per analytic sample member per date that they were enrolled in Medicaid between 4/1/2020 and 4/1/2023

dt <- analytic_sample %>%
  inner_join(study4_enrollment_dates, by = c('ma_receipt_num')) %>%

# Remove obs in which the start date of the enrollment episode is after 4/1/2023
  
  filter(elig_from_date <= as.Date('2023-04-01')) %>%
  
# Recode any episode end dates as 4/1/2023 if they are after 4/1/2023
  
  mutate(elig_to_date = if_else(elig_to_date > as.Date('2023-04-01'), as.Date('2023-04-01'), elig_to_date)) %>%
  
# Recode missing values of the enrollment episode end date as 4/1/2023
  
  mutate(elig_to_date = replace_na(elig_to_date, as.Date('2023-04-01'))) %>%
  
# Remove obs where the episode end date was before 4/1/2020
  
  filter(elig_to_date >= as.Date('2020-04-01')) %>%
  
# Recode any episode start dates as 4/1/2020 if they are before 4/1/2020
  
  mutate(elig_from_date = if_else(elig_from_date < as.Date('2020-04-01'), as.Date('2020-04-01'), elig_from_date)) %>%
  
# Deduplicate the data
  
  distinct(ma_receipt_num, tau, elig_from_date, elig_to_date) %>%
  
# Reshape the data to have 1 obs for each day during each enrollment episode
  
  group_by(ma_receipt_num, tau, elig_from_date, elig_to_date) %>%
  reframe(date = list(seq.Date(from = elig_from_date,
                               to = elig_to_date,
                               by = "day"))) %>%
  unnest(date) %>%
  ungroup() %>%
  distinct(ma_receipt_num, tau, date) %>%

# Calc the % of all days during the covid disenrollment freeze that each person was enrolled in Medicaid, and flag people who were continuously enrolled during covid

  group_by(ma_receipt_num, tau) %>%
  summarise(continuously_enrolled = ifelse(n() >= 1095, 1, 0),
            pct_days = n() / 1095) %>%
  ungroup() %>%
  group_by(tau) %>%
  summarise(person_count = n(),
            pct_days = ifelse(mean(pct_days) > 1, 1, mean(pct_days)),
            pct_continuously_enrolled = mean(continuously_enrolled)) %>%
  ungroup() 

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
# Create graphs

#----------------------------------------------------------------------------
# Density of obs around cutoff date

dt %>%
ggplot(aes(x = tau, y = person_count)) +
  geom_line() +
    geom_vline(aes(xintercept = 0), color = "red", linetype = "dashed") + 
  scale_y_continuous(breaks = seq(0,750,50),
                     limits = c(0,750)) +  
  labs(x = "Days between enrollment episode end date and start of disenrollment freeze", y = "Number of people", title = "Number of people with Q1 2020 HH earnings above the Medicaid eligibility threshold that had a Medicaid\nenrollment episode end within +/- 30 days of the start of the pandemic disenrollment freeze") + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(), 
        plot.title = element_text(size = 10),
        legend.position = "none",
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study4-obs-density-around-cutoff-high-earners.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)

#----------------------------------------------------------------------------
# Pct of all days of disenrollment freeze on which the person was enrolled in Medicaid

dt %>%
ggplot(aes(x = tau, y = pct_days)) +
  geom_line() + 
      geom_vline(aes(xintercept = 0), color = "red", linetype = "dashed") + 
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1)) +  
  labs(x = "Days between enrollment episode end date and start of disenrollment freeze", y = "Pct of all days spent on Medicaid", title = "Percentage of the 1,095-day disenrollment freeze on which the person was enrolled in Medicaid, by date of\nenrollment episode end date relative to the start of the disenrollment freeze, looking only at people with\nQ1 2020 HH earnings above the Medicaid eligibility threshold") + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(), 
        plot.title = element_text(size = 10),
        legend.position = "none",
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study4-pct-of-covid-enrolled-high-earners.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)

#----------------------------------------------------------------------------
# Pct of sample that was enrolled in Medicaid continuously during the covid disenrollment freeze

dt %>%
ggplot(aes(x = tau, y = pct_continuously_enrolled)) +
  geom_line() + 
  geom_vline(aes(xintercept = 0), color = "red", linetype = "dashed") + 
  scale_y_continuous(breaks = seq(0,1,0.1),
                     limits = c(0,1)) +  
  labs(x = "Days between enrollment episode end date and start of disenrollment freeze", y = "Likelihood", title = "Likelihood of being enrolled continuously in Medicaid during entire 1,095-day disenrollment freeze, by date of\nenrollment episode end date relative to the start of the disenrollment freeze, looking only at people with\nQ1 2020 HH earnings above the Medicaid eligibility threshold") + 
  theme_bw() +
  theme(panel.background = element_blank(), 
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(), 
        plot.title = element_text(size = 10),
        legend.position = "none",
        plot.caption = element_text(hjust = 0))

# Save graph image

ggsave(paste0(filepath, "/Tables and figures/study4-continuous-enrollment-likelihood-high-earners.png"), 
  plot = last_plot(),
  width = 8,
  height = 5)
```



